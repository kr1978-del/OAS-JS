Prefix
<div id="box-data" style="display:none">[

Narrative
{"dt":"@1","line":"@2","cell":"@3","@{PV_Met01}{AE Frequency (AE/pd)}":"@4","@{PV_Met02}{Current Effeciency(%)}":"@5","m3":"@6","m4":"@7"}

Row separator	
,

Postfix
]</div>

<!-- OAS params -->
<div id="oas-params" style="display:none"
  data-gpr="@{GraphsPerRow}{1}"

  data-chart-type="@{PV_ChartType}{box}"

  data-theme-default="@{PV_Theme}{light}"
  data-grid-gap="@{PV_GridGap}{8}"

  data-targets="@{PV_Targets}{}"
  data-targets-enabled="@{PV_TargetsEnabled}{0}"
  data-target-color="@{PV_TargetColor}{#dc2626}"
  data-target-width="@{PV_TargetWidth}{1.5}"
  data-target-dash="@{PV_TargetDash}{dash}"

  data-points-mode="@{PV_PointsMode}{auto}"
  data-show-cell="@{PV_ShowCell}{1}"

  data-legend-font-size="@{PV_LegendFontSize}{11}"
  data-axis-title-size="@{PV_AxisTitleSize}{12}"
  data-axis-tick-size="@{PV_AxisTickSize}{12}"
  data-chart-title-size="@{PV_ChartTitleSize}{14}"

  data-chart-height="@{PV_ChartHeight}{320px}"

  data-report-title="@{PV_ReportTitle}{Boxplot analysis}"
  data-report-subtitle="@{PV_ReportSubtitle}{}"
  data-show-header="@{PV_ShowHeader}{1}"
  data-report-title-color="@{PV_ReportTitleColor}{}"
  data-report-subtitle-color="@{PV_ReportSubtitleColor}{}"
  data-report-title-size="@{PV_ReportTitleSize}{18}"
  data-report-subtitle-size="@{PV_ReportSubtitleSize}{12}"
  data-report-sep-color="@{PV_ReportSepColor}{}"

  data-date-title="@{PV_Attribute01}{Week}"
  data-line-title="@{PV_Attribute02}{Line}"
  data-legend-pos="@{PV_LegendPos}{auto}"
  data-legend-show="@{PV_LegendShow}{1}"
  data-mtitles="@{PV_MeasureTitles}{}"
  data-max-points="@{PV_MaxPointsPerChart}{25000}"
  data-border-color="@{PV_BorderColor}{#4b5563}"
></div>

<style>
  :root{ --frame-bg:#fff; --frame-bd:#4b5563; --icon-hover:rgba(0,0,0,.06); }
  [data-theme="dark"]{ --frame-bg:#0b1220; --frame-bd:#64748b; --icon-hover:rgba(255,255,255,.08); }
  [data-theme="paper"]{ --frame-bg:#f8fafc; --frame-bd:#64748b; --icon-hover:rgba(0,0,0,.06); }

  html,body{margin:0;padding:0}
  body{ color:#111827; }
  [data-theme="dark"] body{ color:#e5e7eb; }
  #chart-grid{width:100%;max-width:100%;min-width:0}

  .grid{display:grid;gap:var(--grid-gap, 8px);width:100%;max-width:100%;min-width:0}
  .cols1{grid-template-columns:repeat(1,minmax(0,1fr))}
  .cols2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .cols3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .cols4{grid-template-columns:repeat(4,minmax(0,1fr))}

  .sec{
    border:1px solid var(--frame-bd);
    border-radius:10px;
    padding:0;
    background:var(--frame-bg);
    position:relative;
    width:100%;
    box-sizing:border-box;
    margin:0;
    max-width:100%;
    overflow:hidden;
    min-width:0;
  }
  .plot{width:100%;min-width:0;}
  /* Ensure Plotly uses full available width (OAS sometimes leaves svg-container narrower) */
  .sec .js-plotly-plot{width:100%!important}
  .sec .js-plotly-plot .plot-container{width:100%!important}
  .sec .js-plotly-plot .svg-container{width:100%!important}

  .status-wrap{padding:10px 8px 10px; overflow:visible}
  .status-hint{font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial; opacity:.78; padding:0 0 6px}
  .status-ctx{font:11px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial; opacity:.78; margin:-2px 0 6px}

  /* Keep the scrollbar tight to the table (not full-card width) */
  .status-scroller{display:inline-block; max-width:100%; max-height:clamp(180px, 34vh, 460px); overflow:auto; overscroll-behavior:contain;
    border:1px solid var(--frame-bd); border-radius:10px; background:var(--frame-bg); padding:1px}

  .status-top{display:flex;align-items:center;justify-content:flex-start;gap:10px;margin:0 0 6px}
  .status-actions{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
  .status-btn{padding:6px 10px;border:1px solid #cdd0d4;border-radius:10px;background:rgba(255,255,255,.9);cursor:pointer;font:12px/1 system-ui;white-space:nowrap;color:#111827;display:inline-flex;align-items:center;gap:6px}
  .status-btn:hover{background:#f3f4f6}
  [data-theme="dark"] .status-btn{border-color:#334155;color:#e5e7eb;background:rgba(15,23,42,.9)}
  [data-theme="dark"] .status-btn:hover{background:#111827}

  /* Fullscreen status table */
  .status-wrap.fs{padding:12px 10px}
  .status-wrap.fs .status-scroller{max-height:calc(100vh - 128px)}
  .status-table tr.bin-row{ cursor:pointer }
  .status-table tr.bin-row:hover td{ background:rgba(2,132,199,.06) }
  [data-theme="dark"] .status-table tr.bin-row:hover td{ background:rgba(56,189,248,.12) }

  .menu-pop.bin-pop{ min-width: min(720px, calc(100vw - 20px)); max-width: min(860px, calc(100vw - 20px)); }
  .bin-pop .meta{ font:12px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial; opacity:.85; margin-bottom:8px }
  .bin-pop .actions{ display:flex; gap:6px; flex-wrap:wrap; margin:8px 0 }
  .bin-pop .mini{ width:100%; border-collapse:collapse; font:12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial; color:inherit }
  .bin-pop .mini th,.bin-pop .mini td{ border:1px solid #cdd0d4; padding:6px 8px; text-align:left; white-space:nowrap }
  .bin-pop .mini th{ position:sticky; top:0; background:var(--frame-bg); z-index:3 }
  .bin-pop .mini th.sortable{ cursor:pointer; user-select:none }
  .bin-pop .mini th.sortable:hover{ background:rgba(0,0,0,.03) }
  [data-theme="dark"] .bin-pop .mini th.sortable:hover{ background:rgba(255,255,255,.06) }
  .bin-pop .mini th .arr{ display:inline-block; min-width:10px; margin-left:6px; opacity:.7 }
  [data-theme="dark"] .bin-pop .mini th,[data-theme="dark"] .bin-pop .mini td{ border-color:#334155 }
  .status-table{width:max-content; max-width:100%; border-collapse:collapse; font:12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial; color:inherit}
  .status-table{outline:1px solid var(--frame-bd); outline-offset:-1px}
  .status-table th,.status-table td{border:1px solid var(--frame-bd); padding:6px 8px; text-align:right; white-space:nowrap}
  .status-table th{background:var(--frame-bg); text-align:center; position:sticky; top:0; z-index:6; box-shadow:0 1px 0 var(--frame-bd)}
  [data-theme="dark"] .status-table th{background:var(--frame-bg)}
  .status-table td:first-child,.status-table th:first-child{text-align:left}

  /* Subtle striping for row visibility (don't override shaded columns/cells) */
  .status-table tbody tr:nth-child(even) td:not(.col-in):not(.col-ext):not(.kstat){ background:rgba(0,0,0,.02) }
  [data-theme="dark"] .status-table tbody tr:nth-child(even) td:not(.col-in):not(.col-ext):not(.kstat){ background:rgba(255,255,255,.03) }

  /* Inliers / Extremes column shading */
  .status-table th.col-in, .status-table td.col-in{ background:rgba(34,197,94,.10) }
  .status-table th.col-ext, .status-table td.col-ext{ background:rgba(239,68,68,.10) }
  [data-theme="dark"] .status-table th.col-in, [data-theme="dark"] .status-table td.col-in{ background:rgba(34,197,94,.22) }
  [data-theme="dark"] .status-table th.col-ext, [data-theme="dark"] .status-table td.col-ext{ background:rgba(239,68,68,.22) }

  .status-table td.kstat{background:rgba(59,130,246,.06)}
  .status-table td.kstat.med{background:rgba(59,130,246,.10); font-weight:600}
  [data-theme="dark"] .status-table td.kstat{background:rgba(59,130,246,.14)}
  [data-theme="dark"] .status-table td.kstat.med{background:rgba(59,130,246,.20)}

  /* Modebar pinned top-right (same tuning as LineTrend_v2) */
  .js-plotly-plot .modebar{position:absolute!important;top:4px!important;right:2px!important;left:auto!important;transform:none!important;background:transparent!important;z-index:3!important;scale:.9;padding:0!important}
  .js-plotly-plot .modebar-group{margin:0!important;padding:0!important}
  .js-plotly-plot .modebar-btn{margin:0!important}
  .js-plotly-plot .modebar-group .modebar-btn:last-child{margin-right:0!important;padding-right:2px!important}
  .js-plotly-plot .modebar-group:last-child{margin-right:0!important;padding-right:0!important}

  /* Remove-mode hint (copied from LineTrend_v2 behavior) */
  .oas-removal-hint{position:fixed;z-index:2147483646;max-width:min(520px, calc(100vw - 16px));padding:8px 10px;border-radius:10px;background:rgba(255,255,255,.96);border:1px solid rgba(148,163,184,.6);box-shadow:0 8px 24px rgba(0,0,0,.12);font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#111827;opacity:0;transform:translateY(-6px);transition:opacity .15s ease, transform .15s ease}
  [data-theme="dark"] .oas-removal-hint{background:rgba(11,18,32,.96);border-color:rgba(51,65,85,.9);color:#e5e7eb}
  .oas-removal-hint.show{opacity:1;transform:translateY(0)}
  .oas-removal-hint.fade{opacity:0;transform:translateY(-6px)}
  .js-plotly-plot .modebar-btn .icon path{fill:none!important;stroke:#6b7280!important;stroke-width:80!important}
  .js-plotly-plot .modebar-btn:hover .icon path{stroke:#111827!important}
  [data-theme="dark"] .js-plotly-plot .modebar-btn .icon path{stroke:#9aa4b2!important}
  [data-theme="dark"] .js-plotly-plot .modebar-btn:hover .icon path{stroke:#e5e7eb!important}
  .js-plotly-plot .modebar-btn[data-on="1"] .icon path{stroke:#111827!important}
  [data-theme="dark"] .js-plotly-plot .modebar-btn[data-on="1"] .icon path{stroke:#e5e7eb!important}

  /* Highlight: applied filter/remove (persistent state) */
  .js-plotly-plot .modebar-btn[data-applied="1"]{background:rgba(37,99,235,.08)!important;border-radius:8px}
  [data-theme="dark"] .js-plotly-plot .modebar-btn[data-applied="1"]{background:rgba(59,130,246,.18)!important}
  .js-plotly-plot .modebar-btn[data-applied="1"][data-kind="filter"] .icon path{stroke:#2563eb!important}
  [data-theme="dark"] .js-plotly-plot .modebar-btn[data-applied="1"][data-kind="filter"] .icon path{stroke:#60a5fa!important}
  .js-plotly-plot .modebar-btn[data-applied="1"][data-kind="remove"]{background:rgba(239,68,68,.10)!important}
  [data-theme="dark"] .js-plotly-plot .modebar-btn[data-applied="1"][data-kind="remove"]{background:rgba(248,113,113,.18)!important}
  .js-plotly-plot .modebar-btn[data-applied="1"][data-kind="remove"] .icon path{stroke:#ef4444!important}
  [data-theme="dark"] .js-plotly-plot .modebar-btn[data-applied="1"][data-kind="remove"] .icon path{stroke:#fca5a5!important}

  /* Menus/popovers */
  .menu-pop{
    position:fixed;
    z-index:2147483646;
    background:#fff;
    border:1px solid #e5e7eb;
    border-radius:10px;
    padding:10px;
    box-shadow:0 6px 24px rgba(0,0,0,.12);
    min-width:200px;
    max-width:340px;
    font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial;
    user-select:none;
  }
  .menu-pop, .menu-pop *{ box-sizing:border-box }
  .menu-pop .group{ display:flex; flex-direction:column; gap:6px }
  .menu-pop .row{ display:flex; flex-wrap:wrap; gap:6px; align-items:center }
  .menu-pop.vlist{ flex-direction:column; align-items:stretch; gap:6px; min-width:200px; flex-wrap:nowrap; max-width:340px }
  .menu-pop.vlist .hdr{ margin-bottom:2px }
  .menu-pop.vlist button{ width:100%; text-align:left }
  .menu-pop.vlist input{ width:100% }
  .menu-pop.vlist label{ width:100% }
  .menu-pop.vlist label.opt{display:flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid #cdd0d4;border-radius:8px;background:#fff;cursor:pointer}
  .menu-pop.vlist label.opt:hover{background:#f3f4f6}
  .menu-pop.vlist label.opt input{width:auto;margin:0}
  [data-theme="dark"] .menu-pop.vlist label.opt{border-color:#394357;color:#e5e7eb;background:#0f172a}
  [data-theme="dark"] .menu-pop.vlist label.opt:hover{background:#1f2937}
  .menu-pop .hdr{font-weight:700;margin-bottom:6px;width:100%}
  .menu-pop .hdr.hdr-top{ display:flex; align-items:center; justify-content:space-between; gap:8px }
  .menu-pop .hdr.hdr-top .ttl{ flex:1; min-width:0 }
  .menu-pop .xbtn{ width:22px !important; height:22px; line-height:20px; padding:0; border-radius:999px; text-align:center; font-weight:800; display:inline-flex; align-items:center; justify-content:center }
  .menu-pop .xbtn:hover{ background:#f3f4f6 }
  [data-theme="dark"] .menu-pop .xbtn:hover{ background:#1f2937 }
  .menu-pop label{display:flex;align-items:center;gap:6px}
  .menu-pop input[type="text"], .menu-pop input[type="number"], .menu-pop input[type="range"]{ width:100%; max-width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:8px }
  .menu-pop button{ padding:6px 10px; border:1px solid #cdd0d4; border-radius:8px; background:#fff; cursor:pointer }
  .menu-pop button:hover{ background:#f3f4f6 }
  .menu-pop .segrow{display:flex;flex-wrap:wrap;gap:6px;align-items:center;width:100%}
  .menu-pop label.seg{display:inline-flex;align-items:center;gap:0}
  .menu-pop label.seg input{position:absolute;opacity:0;pointer-events:none}
  .menu-pop label.seg span{display:inline-block;padding:6px 10px;border:1px solid #cdd0d4;border-radius:999px;background:#fff;cursor:pointer;white-space:nowrap}
  .menu-pop label.seg span:hover{background:#f3f4f6}
  .menu-pop label.seg input:checked + span{background:#e5e7eb;border-color:#9ca3af;font-weight:700}
  [data-theme="dark"] .menu-pop{ background:#0f172a; border-color:#2b3447; color:#e5e7eb }
  [data-theme="dark"] .menu-pop input[type="text"], [data-theme="dark"] .menu-pop input[type="number"], [data-theme="dark"] .menu-pop input[type="range"]{ background:#0b1220; border-color:#2b3447; color:#e5e7eb }
  [data-theme="dark"] .menu-pop button{ border-color:#394357; color:#e5e7eb; background:#0f172a }
  [data-theme="dark"] .menu-pop button:hover{ background:#1f2937 }
  [data-theme="dark"] .menu-pop label.seg span{background:#0f172a;border-color:#334155;color:#e5e7eb}
  [data-theme="dark"] .menu-pop label.seg span:hover{background:#1f2937}
  [data-theme="dark"] .menu-pop label.seg input:checked + span{background:#1f2937;border-color:#475569}

  /* Fullscreen overlay */
  .pl-fs-overlay{position:fixed;inset:0;background:#fff;z-index:2147483647;overflow:auto;padding:0;box-sizing:border-box}
  [data-theme="dark"] .pl-fs-overlay{background:#0b1220}

  /* Report titlebar (consistent with LineTrend_v2) */
  #report-header{position:relative;top:auto;z-index:1}
  .oas-titlebar{display:flex;align-items:flex-start;justify-content:space-between;gap:10px;padding:10px 6px 8px 6px}
  .oas-titlebar .txt{min-width:0}
  .oas-titlebar .ttl{font:700 18px/1.2 system-ui}
  .oas-titlebar .sub{margin-top:2px;font:12px/1.3 system-ui;opacity:.8}
  .oas-titlebar .acts{display:flex;flex-wrap:wrap;gap:6px;justify-content:flex-end}
  .oas-titlebar button{padding:6px 10px;border:1px solid #cdd0d4;border-radius:10px;background:rgba(255,255,255,.9);cursor:pointer;font:12px/1 system-ui;white-space:nowrap;color:#111827;display:inline-flex;align-items:center;gap:6px}
  .oas-titlebar button:hover{background:#f3f4f6}
  [data-theme="dark"] .oas-titlebar button{border-color:#334155;color:#e5e7eb;background:rgba(15,23,42,.9)}
  [data-theme="dark"] .oas-titlebar button:hover{background:#111827}
  .oas-titlebar .icoBtn{width:32px;height:32px;padding:0;display:inline-flex;align-items:center;justify-content:center}
  .oas-titlebar .icoBtn svg{width:17px;height:17px;display:block}
  .oas-titlebar .icoBtn svg path{fill:none;stroke:currentColor;stroke-width:80;stroke-linecap:round;stroke-linejoin:round}
  .oas-title-sep{height:1px;margin:0 0 10px 0;opacity:1}

  @media (max-width: 1024px){
    #chart-grid.cols2,
    #chart-grid.cols3{ grid-template-columns:repeat(1,minmax(0,1fr)); }
  }
</style>

<div id="report-header" style="display:none"></div>
<div id="chart-grid" class="grid cols1"></div>

<script src="/analyticsRes/custom/plotly.min.js"></script>
<script src="/analyticsRes/vendor/export/jspdf.umd.min.js"></script>
<script src="/analyticsRes/vendor/export/html2canvas.min.js"></script>
<script>
(function(){
  try{
    const grid = document.getElementById('chart-grid');
    const host = document.getElementById('box-data');
    const p = document.getElementById('oas-params') || { dataset: {} };
    const hdr = document.getElementById('report-header');

    if(!grid || !host) return;
    if(typeof Plotly === 'undefined'){
      grid.innerHTML = '<div class="sec" style="color:#b91c1c;font-weight:600">plotly.min.js not found</div>';
      return;
    }

    const THEMES = {
      light:{BG:'#ffffff',PBG:'#ffffff',TXT:'#111827',GRID:'#e5e7eb',AX:'#6b7280',BORDER:'#cbd5e1'},
      paper:{BG:'#f8fafc',PBG:'#ffffff',TXT:'#111827',GRID:'#e5e7eb',AX:'#64748b',BORDER:'#cbd5e1'},
      dark :{BG:'#0b1220',PBG:'#0f172a',TXT:'#e5e7eb',GRID:'#293244',AX:'#9aa4b2',BORDER:'#334155'}
    };

    function normTheme(v){
      v=String(v||'').trim().toLowerCase();
      if(v==='dark') return 'dark';
      if(v==='paper') return 'paper';
      return 'light';
    }

    let CUR_THEME=normTheme(p.dataset.themeDefault || 'light');
    const THEME_ORDER=['light','paper','dark'];
    function setThemeAttr(){
      document.documentElement.setAttribute('data-theme', CUR_THEME);
    }
    setThemeAttr();

    const normalizeCssSize = (val, fallback) => {
      let s = String(val ?? '').trim();
      if(!s) return fallback;
      const pv = s.match(/^@\{[^}]*\}\{([^}]*)\}$/);
      if(pv) s = String(pv[1] ?? '').trim();
      if(!s) return fallback;
      if(/^-?\d+(?:\.\d+)?$/.test(s)) return s + 'px';
      return s;
    };
    const parsePx = (val, fallbackPx) => {
      const s = normalizeCssSize(val, '').trim();
      const m = s.match(/^(-?\d+(?:\.\d+)?)px$/i);
      if(m) return Math.round(+m[1]);
      if(/^-?\d+(?:\.\d+)?$/.test(s)) return Math.round(+s);
      return fallbackPx;
    };

    const HEIGHT = parsePx(p.dataset.chartHeight, 320);
    const USER_SIZE = {
      scale: 1,
      heightPx: null
    };

    const clampNum=(v,min,max)=>Math.max(min,Math.min(max,v));
    function chartHeightPx(){
      const base = (USER_SIZE.heightPx!=null && Number.isFinite(USER_SIZE.heightPx)) ? +USER_SIZE.heightPx : HEIGHT;
      const scaled = Math.round(base * (USER_SIZE.scale || 1));
      return Math.max(180, Math.min(1400, scaled));
    }
    function applyChartSizeAll(){
      const h = chartHeightPx();
      document.querySelectorAll('#chart-grid .plot').forEach((gd)=>{
        if(gd && gd._fsOverlay) return;
        gd.style.height = h + 'px';
        if(gd.classList && gd.classList.contains('js-plotly-plot')){
          const sec = gd.closest ? gd.closest('.sec') : null;
          const w = sec ? Math.floor(sec.getBoundingClientRect().width) : Math.floor(gd.getBoundingClientRect().width);
          const width = Math.max(260, (Number.isFinite(w) ? w : 0));
          try{ Plotly.relayout(gd, {autosize:false, width, height:h}); }catch(_){ }
          try{ Plotly.Plots.resize(gd); }catch(_){ }
        }
      });
    }

    (function setupChartHeightObserver(){
      if(!('MutationObserver' in window)) return;
      if(!p || !p.dataset) return;
      let lastH = String(p.dataset.chartHeight||'');
      const mo = new MutationObserver(()=>{
        const curH = String(p.dataset.chartHeight||'');
        if(curH===lastH) return;
        lastH = curH;
        // Only adjust when user hasn't explicitly overridden height via Size menu.
        if(USER_SIZE && USER_SIZE.heightPx==null){
          try{ applyChartSizeAll(); }catch(_){ }
          try{ document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ Plotly.Plots.resize(el); }catch(_){ } }); }catch(_){ }
        }
      });
      try{ mo.observe(p, {attributes:true, attributeFilter:['data-chart-height']}); }catch(_){ }
    })();
    const EXTREME_K = 3.0;
    const MILD_K = 1.5;

    const MAX_POINTS_PER_CHART = Math.max(2000, Math.min(150000, parseInt(p.dataset.maxPoints || '25000',10) || 25000));
    const DEFAULT_HIST_BINS = Math.max(5, Math.min(200, parseInt(p.dataset.histBinsDefault || '30', 10) || 30));
    const BORDER_OVERRIDE = (p.dataset.borderColor || '').trim();

    const GRID_GAP_DEFAULT = Math.max(0, Math.min(40, parseInt(p.dataset.gridGap || '8', 10) || 8));
    let GRID_GAP = GRID_GAP_DEFAULT;
    if(grid) grid.style.setProperty('--grid-gap', GRID_GAP + 'px');

    const LEGEND_FONT_SIZE = Math.max(8, Math.min(26, parseInt(p.dataset.legendFontSize || '11', 10) || 11));
    const AXIS_TITLE_SIZE = Math.max(9, Math.min(32, parseInt(p.dataset.axisTitleSize || '12', 10) || 12));
    const AXIS_TICK_SIZE = Math.max(8, Math.min(28, parseInt(p.dataset.axisTickSize || '12', 10) || 12));
    const CHART_TITLE_SIZE = Math.max(10, Math.min(30, parseInt(p.dataset.chartTitleSize || '14', 10) || 14));

    const DEFAULT_POINTS_MODE = String(p.dataset.pointsMode || 'auto').trim().toLowerCase();
    const DEFAULT_SHOW_CELL = String(p.dataset.showCell || '1') !== '0';

    function normChartType(v){
      v = String(v || '').trim().toLowerCase();
      const alias = {
        histogram: 'hist',
        'hist+kde': 'histkde',
        'hist-kde': 'histkde'
      };
      v = alias[v] || v;
      const ok = new Set(['box','violin','strip','swarm','raincloud','hist','histkde','kde','ecdf']);
      return ok.has(v) ? v : 'box';
    }
    const DEFAULT_CHART_TYPE = normChartType(p.dataset.chartType || 'box');

    const TARGETS_ENABLED_DEFAULT = String(p.dataset.targetsEnabled || '0') !== '0';
    const TARGETS_DEFAULT = String(p.dataset.targets || '').split(/[,;\s]+/).map(s=>s.trim()).filter(Boolean).map(Number).filter(n=>Number.isFinite(n));
    const TARGET_COLOR_DEFAULT = (p.dataset.targetColor || '#dc2626').trim() || '#dc2626';
    const TARGET_WIDTH_DEFAULT = Math.max(0.5, Math.min(6, parseFloat(String(p.dataset.targetWidth || '1.5')) || 1.5));
    const TARGET_DASH_DEFAULT = (p.dataset.targetDash || 'dash').trim() || 'dash';

    const DATE_TITLE = (p.dataset.dateTitle || 'Category').trim();
    const HOVER_CAT_TITLE = (p.dataset.hoverCategoryTitle || 'Category').trim();
    const LINE_TITLE = (p.dataset.lineTitle || 'Line').trim();
    const LEG_SHOW = String(p.dataset.legendShow || '1') !== '0';

    const GPR = Math.min(4, Math.max(1, parseInt(p.dataset.gpr || '1', 10) || 1));
    const MT = (p.dataset.mtitles || '').split('|').map(s=>s.trim()).filter(Boolean);

    function normLegendPos(v){
      v = String(v || 'top').toLowerCase().trim().replace(/\s+/g,'-');
      const alias = {
        'top-center':'top',
        'bottom-center':'bottom',
        top:'top',
        bottom:'bottom',
        left:'left',
        right:'right',
        auto:'auto'
      };
      return alias[v] || v;
    }

    function nextTheme(cur){
      return (cur==='light') ? 'paper' : (cur==='paper' ? 'dark' : 'light');
    }

    function isPointsModeKey(v){
      v=String(v||'').toLowerCase().trim();
      return (v==='auto' || v==='none' || v==='outliers' || v==='suspectedoutliers' || v==='all');
    }
    const LEG_POS = normLegendPos(p.dataset.legendPos || 'auto');

    const pvInt = (val, fallback) => {
      const s = String(val ?? '');
      const m = s.match(/-?\d+(?:\.\d+)?/g);
      if(!m || !m.length) return fallback;
      const n = parseFloat(m[m.length-1]);
      return Number.isFinite(n) ? Math.trunc(n) : fallback;
    };

    const SHOW_HEADER = (pvInt(p.dataset.showHeader, 1) !== 0);
    const REPORT_TITLE = (p.dataset.reportTitle || '').trim();
    const REPORT_SUBTITLE = (p.dataset.reportSubtitle || '').trim();
    const REPORT_TITLE_COLOR = (p.dataset.reportTitleColor || '').trim();
    const REPORT_SUBTITLE_COLOR = (p.dataset.reportSubtitleColor || '').trim();
    const REPORT_TITLE_SIZE = Math.max(10, Math.min(42, pvInt(p.dataset.reportTitleSize, 18)));
    const REPORT_SUBTITLE_SIZE = Math.max(9, Math.min(28, pvInt(p.dataset.reportSubtitleSize, 12)));
    const REPORT_SEP_COLOR = (p.dataset.reportSepColor || '').trim();

    const PALETTE=['#2E77D0','#E07A1F','#2FA24B','#C33C3C','#7C5AC9','#8C564B','#E377C2','#17BECF','#7f7f7f'];
    const LINE_COLORS = Object.create(null);
    function colorFor(line){
      if(LINE_COLORS[line]) return LINE_COLORS[line];
      const idx = Object.keys(LINE_COLORS).length % PALETTE.length;
      LINE_COLORS[line] = PALETTE[idx];
      return LINE_COLORS[line];
    }
    function rgba(hex,a){
      a = (a==null)?0.14:a;
      const b=String(hex||'#000').replace('#','');
      const n=parseInt(b,16);
      const r=(n>>16)&255, g=(n>>8)&255, bl=n&255;
      return `rgba(${r},${g},${bl},${a})`;
    }

    function svgIcon(icon){
      if(!icon || !icon.path) return '';
      return `<svg viewBox="0 0 1000 1000" aria-hidden="true" focusable="false"><path d="${icon.path}"></path></svg>`;
    }

    function toNum(s){
      if(s==null) return null;
      let t=(''+s).trim();
      if(!t) return null;
      t=t.replace(/[^\d.,\-]/g,'');
      const d=t.lastIndexOf('.'), c=t.lastIndexOf(',');
      if(d!==-1 && c!==-1){
        t=(c>d) ? t.replace(/\./g,'').replace(',', '.') : t.replace(/,/g,'');
      }else if(c!==-1){
        t=t.replace(',', '.');
      }else{
        t=t.replace(/,/g,'');
      }
      const v=parseFloat(t);
      return Number.isFinite(v)?v:null;
    }

    // OAS data: already a JSON array
    let raw=[];
    try{ raw = JSON.parse((host.textContent || '[]').trim()); }catch(_){ raw=[]; }
    if(!Array.isArray(raw) || !raw.length){
      grid.innerHTML = '<div class="sec" style="color:#374151">No data rows.</div>';
      return;
    }

    const KEYS={ dt:'dt', line:'line', cell:'cell' };

    // Determine measure keys (anything not dt/line/cell with at least one numeric)
    const numericSeen = Object.create(null);
    for(const r of raw){
      for(const k in r){
        if(k===KEYS.dt || k===KEYS.line || k===KEYS.cell) continue;
        const v = toNum(r[k]);
        if(v!=null) numericSeen[k]=true;
      }
    }
    const mKeys = Object.keys(numericSeen);
    if(!mKeys.length){
      grid.innerHTML = '<div class="sec" style="color:#374151">No numeric measures found.</div>';
      return;
    }

    const TIT = Object.create(null);
    for(let i=0;i<mKeys.length;i++) TIT[mKeys[i]] = MT[i] || mKeys[i];

    // Build rows (minimal copy) + preserve insertion order for dates/lines
    const dates=[]; const dateSet=new Set();
    const lines=[]; const lineSet=new Set();
    const rows=[];

    for(let rawIdx=0; rawIdx<raw.length; rawIdx++){
      const r=raw[rawIdx];
      const d = String(r[KEYS.dt] ?? '');
      const ln = String(r[KEYS.line] ?? '—');
      const cell = String(r[KEYS.cell] ?? '');
      if(!dateSet.has(d)){ dateSet.add(d); dates.push(d); }
      if(!lineSet.has(ln)){ lineSet.add(ln); lines.push(ln); }

      const o = { d, ln, cell, rawIdx, v: Object.create(null) };
      for(const mk of mKeys){
        const vv = toNum(r[mk]);
        if(vv!=null) o.v[mk]=vv;
      }
      rows.push(o);
    }
    lines.forEach(colorFor);

    const dateIndex = Object.create(null);
    for(let i=0;i<dates.length;i++) dateIndex[dates[i]] = i;

    function frameBorder(){
      return (BORDER_OVERRIDE || '#4b5563');
    }
    function applyFrameBorder(){
      document.documentElement.style.setProperty('--frame-bd', frameBorder());
    }
    applyFrameBorder();

    function quantilesFromSorted(sorted){
      const n = sorted.length;
      if(!n) return {q1:null, med:null, q3:null, iqr:null, min:null, max:null};
      const q=(p)=>{
        const i=(n-1)*p;
        const lo=Math.floor(i), hi=Math.ceil(i);
        if(lo===hi) return sorted[lo];
        return sorted[lo] + (sorted[hi]-sorted[lo])*(i-lo);
      };
      const q1=q(0.25), med=q(0.5), q3=q(0.75);
      return {q1, med, q3, iqr:(q3-q1), min:sorted[0], max:sorted[n-1]};
    }

    // Precompute store[measure][line] => arrays for inliers+mild (nm*) and extremes (ext*), plus per-date summary.
    const store = Object.create(null);
    for(const mk of mKeys){
      store[mk]=Object.create(null);
      for(const ln of lines){
        store[mk][ln] = {
          nmX:[], nmY:[], nmT:[], nmI:[],
          extX:[], extY:[], extT:[], extI:[],
          medX:[], medY:[],
          medTXT:Object.create(null),
          statsByDate:Object.create(null)
        };
      }
    }

    // group values by (mk,d,ln) without object allocations
    const groups = new Map();
    function gKey(mk,d,ln){ return mk + '\u0000' + d + '\u0000' + ln; }

    for(const r of rows){
      for(const mk of mKeys){
        const y = r.v[mk];
        if(!Number.isFinite(y)) continue;
        const key = gKey(mk, r.d, r.ln);
        let g = groups.get(key);
        if(!g){ g = { ys:[], cells:[], idx:[] }; groups.set(key,g); }
        g.ys.push(y);
        g.cells.push(r.cell);
        g.idx.push(r.rawIdx);
      }
    }

    function fmtN(v){
      if(v==null || !Number.isFinite(+v)) return '—';
      const s=(+v).toFixed(6);
      return s.replace(/\.?0+$/,'');
    }
    function fmtP(v){ return (v==null || !Number.isFinite(v)) ? '—' : (+v).toFixed(1) + '%'; }

    for(const [key,g] of groups){
      const [mk,d,ln] = key.split('\u0000');
      const S = store[mk]?.[ln];
      if(!S) continue;

      const ys = g.ys;
      if(!ys.length) continue;

      const sorted = ys.slice().sort((a,b)=>a-b);
      const st = quantilesFromSorted(sorted);
      const fmL = st.q1 - MILD_K*st.iqr;
      const fmH = st.q3 + MILD_K*st.iqr;
      const feL = st.q1 - EXTREME_K*st.iqr;
      const feH = st.q3 + EXTREME_K*st.iqr;

      let inCount=0, extCount=0;
      const inlierVals=[];

      for(let i=0;i<ys.length;i++){
        const y = ys[i];
        const cell = g.cells[i];
        const rawIdx = g.idx[i];
        if(y < feL || y > feH){
          S.extX.push(d); S.extY.push(y); S.extT.push(cell); S.extI.push(rawIdx);
          extCount++;
        }else{
          S.nmX.push(d); S.nmY.push(y); S.nmT.push(cell); S.nmI.push(rawIdx);
          inCount++;
          inlierVals.push(y);
        }
      }

      // Median/summary based on non-extremes (inliers + mild)
      const medSorted = inlierVals.length ? inlierVals.slice().sort((a,b)=>a-b) : sorted;
      const medS = quantilesFromSorted(medSorted);
      const medIqr = (medS.q3!=null && medS.q1!=null) ? (medS.q3 - medS.q1) : null;
      const lf = (medIqr!=null && medS.q1!=null) ? (medS.q1 - MILD_K*medIqr) : null;
      const uf = (medIqr!=null && medS.q3!=null) ? (medS.q3 + MILD_K*medIqr) : null;
      const txt =
        `<b>${LINE_TITLE}: ${ln}</b><br>`+
        `<b>${HOVER_CAT_TITLE}: ${d}</b><br>`+
        `Min ${fmtN(medS.min)}<br>Q1 ${fmtN(medS.q1)}<br>Median ${fmtN(medS.med)}<br>Q3 ${fmtN(medS.q3)}<br>Max ${fmtN(medS.max)}<br>`+
        `n ${ys.length} &nbsp;&nbsp; Inliers ${inCount} &nbsp;&nbsp; Extremes ${extCount}`;

      const medY = (medS.med!=null) ? medS.med : (ys[0] ?? null);
      S.medX.push(d);
      S.medY.push(medY);
      S.medTXT[d]=txt;

      S.statsByDate[d] = {
        n: ys.length,
        inliers: inCount,
        extremes: extCount,
        pin: ys.length ? (inCount*100/ys.length) : null,
        pext: ys.length ? (extCount*100/ys.length) : null,
        min: medS.min,
        q1: medS.q1,
        med: medS.med,
        q3: medS.q3,
        max: medS.max,
        lf,
        uf
      };
    }

    // UI/state per chart
    const state = Object.create(null);

    function applyCols(n){
      grid.classList.toggle('cols1', n===1);
      grid.classList.toggle('cols2', n===2);
      grid.classList.toggle('cols3', n===3);
      grid.classList.toggle('cols4', n===4);
    }
    applyCols(GPR);

    function legendSpec(pos, itemCount){
      const cnt = (itemCount==null ? lines.length : itemCount);
      // Auto: move to right when there are many legend items.
      const needRight = cnt > 7;
      if(pos==='auto'){
        return needRight ? {orientation:'v', x:1.02,xanchor:'left',  y:1,    yanchor:'top'} : {orientation:'h', x:0.5, xanchor:'center', y:1.04, yanchor:'bottom'};
      }
      switch(pos){
        case 'top':           return {orientation:'h', x:0.5, xanchor:'center', y:1.04, yanchor:'bottom'};
        case 'bottom':        return {orientation:'h', x:0.5, xanchor:'center', y:-0.24, yanchor:'top'};
        case 'left':          return {orientation:'v', x:-0.01,   xanchor:'right', y:1,    yanchor:'top'};
        case 'right':         return {orientation:'v', x:1.01,xanchor:'left',  y:1,    yanchor:'top'};
        default:              return needRight ? {orientation:'v', x:1.02,xanchor:'left',  y:1,    yanchor:'top'} : {orientation:'h', x:0.5, xanchor:'center', y:1.04, yanchor:'bottom'};
      }
    }

    function fitPlotToCard(gd){
      if(!gd || gd._fsOverlay) return;
      const sec = gd.closest ? gd.closest('.sec') : null;
      const w = sec ? Math.floor(sec.getBoundingClientRect().width) : Math.floor(gd.getBoundingClientRect().width);
      const width = Math.max(260, (Number.isFinite(w) ? w : 0));
      const height = parseInt(gd.style.height, 10) || chartHeightPx();
      if(!width || !height) return;
      try{ Plotly.relayout(gd, {autosize:false, width, height}); }catch(_){ }
      try{ Plotly.Plots.resize(gd); }catch(_){ }
    }
    
    function targetShapes(st){
      const sh=[];
      if(!st.showTargets) return sh;
      if(st.band && Number.isFinite(st.minT) && Number.isFinite(st.maxT)){
        sh.push({type:'rect', xref:'paper', x0:0, x1:1, y0:st.minT, y1:st.maxT,
                 fillcolor:'rgba(200,30,30,0.08)', line:{width:0}});
      }
      if(!st.band && Number.isFinite(st.minT)){
        sh.push({type:'line', xref:'paper', x0:0, x1:1, y0:st.minT, y1:st.minT,
                 line:{color:'rgba(200,30,30,0.7)', width:2, dash:'dash'}});
      }
      if(!st.band && Number.isFinite(st.maxT)){
        sh.push({type:'line', xref:'paper', x0:0, x1:1, y0:st.maxT, y1:st.maxT,
                 line:{color:'rgba(200,30,30,0.7)', width:2, dash:'dash'}});
      }
      return sh;
    }
    
    function marginsFor(pos){
      const rotate = dates.length > 12;
      const b = rotate ? 56 : 44;
      // Match LineTrend: keep a consistent top margin for the Plotly title.
      const t=56;
      if(pos==='bottom') return {l:52,r:10,t,b:rotate?72:56,pad:0};
      if(pos==='top') return {l:52,r:10,t,b,pad:0};
      if(pos==='left') return {l:124,r:10,t,b,pad:0};
      if(pos==='right') return {l:52,r:92,t,b,pad:0};
      return {l:52,r:10,t,b,pad:0};
    }

    function xAxisSpec(){
      const T=THEMES[CUR_THEME];
      const rotate = dates.length > 12;
      return {
        type:'category', categoryorder:'array', categoryarray:dates,
        tickmode:'auto', tickangle: rotate ? -90 : 0,
        tickfont:{ size: rotate ? Math.max(9, AXIS_TICK_SIZE-2) : AXIS_TICK_SIZE },
        automargin:true,
        title:{ text: DATE_TITLE, font:{size:AXIS_TITLE_SIZE} },
        gridcolor:T.GRID,
        zeroline:false
      };
    }

    function yAxisSpec(st, gd){
      const T=THEMES[CUR_THEME];
      const y={
        zeroline:false,
        gridcolor:T.GRID,
        tickfont:{ size: AXIS_TICK_SIZE },
        title:{ font:{ size: AXIS_TITLE_SIZE } }
      };

      const mode = (st && st.yScaleMode) ? st.yScaleMode : 'auto';
      if(mode === 'log'){
        y.type = 'log';
        y.rangemode = 'normal';
      }else{
        y.type = 'linear';
        y.rangemode = (mode === 'zero') ? 'tozero' : 'normal';
      }

      const min = (st && Number.isFinite(st.yMin)) ? +st.yMin : null;
      const max = (st && Number.isFinite(st.yMax)) ? +st.yMax : null;
      if(min!=null || max!=null){
        const cur = (gd && gd._fullLayout && gd._fullLayout.yaxis && gd._fullLayout.yaxis.range) ? gd._fullLayout.yaxis.range : null;
        const lo = (min!=null) ? min : (cur ? cur[0] : null);
        const hi = (max!=null) ? max : (cur ? cur[1] : null);
        if(lo!=null && hi!=null){
          y.autorange = false;
          y.range = [lo,hi];
        }else{
          y.autorange = true;
        }
      }else{
        y.autorange = true;
      }
      return y;
    }

    function filterIndicatorText(st){
      if(!st) return '';
      const parts=[];
      if(st.fmin!=null && st.fmax!=null) parts.push(`Range: ${st.fmin} to ${st.fmax}`);
      else if(st.fmin!=null) parts.push(`Min: ${st.fmin}`);
      else if(st.fmax!=null) parts.push(`Max: ${st.fmax}`);
      if(st.excludeExtremes) parts.push('Exclude extremes');
      else if(!st.includeExt) parts.push('Exclude outliers');
      return parts.length ? `Applied Filters: ${parts.join(', ')}` : '';
    }

    function applyGridGap(px){
      GRID_GAP = Math.max(0, Math.min(40, Math.round(px)));
      if(grid) grid.style.setProperty('--grid-gap', GRID_GAP + 'px');
    }

    function allY(mk, st){
      const vals=[];
      for(const ln of lines){
        const S=store[mk][ln];
        const ys = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
        for(const v of ys) if(Number.isFinite(v)) vals.push(v);
      }
      return vals;
    }

    const rmKey=(mk,ln,x,y,cell)=> `${mk}\u0000${ln}\u0000${x}\u0000${y}\u0000${cell||''}`;

    // Filtering/exclusion helpers
    function applyFilters(X,Y,T,I, mk, ln, st){
      const outX=[], outY=[], outT=[], outI=[];
      const fmin=st.fmin, fmax=st.fmax;
      for(let i=0;i<Y.length;i++){
        const y=Y[i];
        if(!Number.isFinite(y)) continue;
        if(fmin!=null && y<fmin) continue;
        if(fmax!=null && y>fmax) continue;
        if(st.exclude.has(rmKey(mk, ln, X[i], y, (T[i]||'')))) continue;
        const rawIdx = (I && I[i]!=null) ? I[i] : null;
        if(rawIdx!=null && st.removed && st.removed.has(rawIdx)) continue;
        outX.push(X[i]); outY.push(y); outT.push(T[i]);
        if(I) outI.push(rawIdx);
      }
      return {X:outX,Y:outY,T:outT,I: (I?outI:null)};
    }

    function tracesFor(mk, st, budget){
      const traces=[];
      const T=THEMES[CUR_THEME];
      const statsScope = (st.statsScope || 'group');
      const allScope = (statsScope === 'all');
      const chartType = st.chartType || 'box';

      function filterXY(X,Y){
        const outX=[], outY=[];
        const fmin=st.fmin, fmax=st.fmax;
        for(let i=0;i<Y.length;i++){
          const y=Y[i];
          if(!Number.isFinite(y)) continue;
          if(fmin!=null && y<fmin) continue;
          if(fmax!=null && y>fmax) continue;
          outX.push(X[i]); outY.push(y);
        }
        return {X:outX,Y:outY};
      }

      function linFit(idx, y){
        const n = idx.length;
        if(n<2) return null;
        let sx=0, sy=0, sxx=0, sxy=0;
        for(let i=0;i<n;i++){
          const x=idx[i];
          const yy=y[i];
          sx+=x; sy+=yy; sxx+=x*x; sxy+=x*yy;
        }
        const den = n*sxx - sx*sx;
        if(Math.abs(den) < 1e-12) return null;
        const m = (n*sxy - sx*sy) / den;
        const b = (sy - m*sx) / n;
        return {m,b};
      }

      function meanStd(vals){
        const n=vals.length;
        if(!n) return {n:0, mean:null, std:null};
        let s=0, ss=0;
        for(const v of vals){ s+=v; ss+=v*v; }
        const mean = s/n;
        const varp = Math.max(0, ss/n - mean*mean);
        const std = Math.sqrt(varp);
        return {n, mean, std};
      }

      function kde1d(vals, gridCount, minX, maxX){
        const n=vals.length;
        if(n<2) return null;
        const ms=meanStd(vals);
        let bw = 1.06 * (ms.std || 0) * Math.pow(n, -0.2);
        if(!Number.isFinite(bw) || bw<=0){
          bw = (maxX>minX) ? (0.02*(maxX-minX)) : 1;
        }
        const inv = 1/(bw*Math.sqrt(2*Math.PI));
        const step = (maxX-minX) / Math.max(1, (gridCount-1));
        const xs=new Array(gridCount);
        const ys=new Array(gridCount);
        for(let i=0;i<gridCount;i++){
          const x=minX + i*step;
          xs[i]=x;
          let acc=0;
          for(let j=0;j<n;j++){
            const z=(x-vals[j])/bw;
            acc += Math.exp(-0.5*z*z);
          }
          ys[i]=inv*(acc/n);
        }
        return {x:xs, y:ys, bw};
      }

      // Aggregate distribution chart types (ignore date categories)
      if(chartType==='hist' || chartType==='histkde' || chartType==='kde' || chartType==='ecdf'){
        const perLine=[];
        let globalMin=null, globalMax=null;
        for(const ln of lines){
          const S=store[mk][ln];
          if(!S) continue;
          const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
          const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
          const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
          const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;
          const f = applyFilters(bx,by,bt,bi,mk,ln,st);
          if(!f.Y.length) continue;
          let mn=f.Y[0], mx=f.Y[0];
          for(const v of f.Y){ if(v<mn) mn=v; if(v>mx) mx=v; }
          globalMin = (globalMin==null) ? mn : Math.min(globalMin, mn);
          globalMax = (globalMax==null) ? mx : Math.max(globalMax, mx);
          perLine.push({ln, ys:f.Y, col:colorFor(ln)});
        }

        if(!perLine.length) return traces;

        if(chartType==='hist' || chartType==='histkde'){
          const nb = (Number.isFinite(st.histBins) && +st.histBins>0) ? Math.floor(+st.histBins) : DEFAULT_HIST_BINS;
          for(const it of perLine){
            traces.push({
              type:'histogram',
              name:it.ln,
              legendgroup:it.ln,
              x:it.ys,
              nbinsx: nb,
              marker:{color:it.col},
              opacity:(st.histSeparateBars ? 1 : 0.55),
              texttemplate:(st.histShowCounts ? '%{y}' : undefined),
              textposition:(st.histShowCounts ? 'outside' : undefined),
              cliponaxis:(st.histShowCounts ? false : undefined),
              hovertemplate:`<b>${LINE_TITLE}: %{fullData.name}</b><br>Value %{x:.4f}<br>Count %{y}<extra></extra>`
            });

            if(chartType==='histkde' && it.ys.length>=3){
              const mn = globalMin, mx = globalMax;
              const gridCount = 120;
              const kde = kde1d(it.ys, gridCount, mn, mx);
              if(kde){
                traces.push({
                  type:'scatter',
                  mode:'lines',
                  name:`KDE – ${it.ln}`,
                  legendgroup:it.ln,
                  showlegend:false,
                  x:kde.x,
                  y:kde.y,
                  yaxis:'y2',
                  line:{width:2,color:it.col},
                  hovertemplate:`<b>${LINE_TITLE}: ${it.ln}</b><br>Value %{x:.4f}<br>Density %{y:.6f}<extra></extra>`
                });
              }
            }
          }
          return traces;
        }

        if(chartType==='kde'){
          const mn = globalMin, mx = globalMax;
          const gridCount = 140;
          for(const it of perLine){
            if(it.ys.length<3) continue;
            const kde = kde1d(it.ys, gridCount, mn, mx);
            if(!kde) continue;
            traces.push({
              type:'scatter',
              name:it.ln,
              legendgroup:it.ln,
              x:kde.x,
              y:kde.y,
              line:{width:2,color:it.col},
              hovertemplate:`<b>${LINE_TITLE}: %{fullData.name}</b><br>Value %{x:.4f}<br>Density %{y:.6g}<extra></extra>`
            });
          }
          return traces;
        }

        if(chartType==='ecdf'){
          for(const it of perLine){
            const sorted = it.ys.slice().sort((a,b)=>a-b);
            const n = sorted.length;
            const x=[], y=[];
            for(let i=0;i<n;i++){
              x.push(sorted[i]);
              y.push((i+1)/n);
            }
            traces.push({
              type:'scatter',
              mode:'lines',
              name:it.ln,
              legendgroup:it.ln,
              x, y,
              line:{width:2,color:it.col},
              hovertemplate:`<b>${LINE_TITLE}: %{fullData.name}</b><br>Value %{x:.4f}<br>F(x) %{y:.3f}<extra></extra>`
            });
          }
          return traces;
        }

      }

      // Dot + error bars (per date)
      if(chartType==='doterr'){
        const errMode = st.errMode || 'std';
        for(const ln of lines){
          const S=store[mk][ln];
          if(!S) continue;
          const baseCol = colorFor(ln);

          const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
          const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
          const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
          const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;
          const f = applyFilters(bx,by,bt,bi,mk,ln,st);
          if(!f.Y.length) continue;

          const agg = Object.create(null);
          for(let i=0;i<f.Y.length;i++){
            const d=String(f.X[i]);
            const y=f.Y[i];
            if(!agg[d]) agg[d]={n:0, s:0, ss:0, mn:y, mx:y};
            const a=agg[d];
            a.n++; a.s+=y; a.ss+=y*y;
            if(y<a.mn) a.mn=y;
            if(y>a.mx) a.mx=y;
          }

          const x=[], y=[], err=[], cd=[];
          for(const d of dates){
            const a=agg[String(d)];
            if(!a || !a.n) continue;
            const mean=a.s/a.n;
            const varp=Math.max(0, a.ss/a.n - mean*mean);
            const std=Math.sqrt(varp);
            const sem = a.n>0 ? (std/Math.sqrt(a.n)) : 0;
            const e = (errMode==='sem') ? sem : (errMode==='ci95' ? 1.96*sem : std);
            x.push(d);
            y.push(mean);
            err.push(e);
            cd.push(`n ${a.n}<br>Mean ${fmtN(mean)}<br>Std ${fmtN(std)}<br>Min ${fmtN(a.mn)}<br>Max ${fmtN(a.mx)}`);
          }

          if(!y.length) continue;
          traces.push({
            type:'scatter',
            mode:'markers+lines',
            name:ln,
            legendgroup:ln,
            x, y,
            customdata:cd,
            marker:{size:7,color:baseCol},
            line:{width:2,color:baseCol},
            error_y:{type:'data', array:err, visible:true, thickness:1.2, width:0, color:baseCol},
            hovertemplate:`<b>${LINE_TITLE}: %{fullData.name}</b><br><b>${HOVER_CAT_TITLE}: %{x}</b><br>%{customdata}<extra></extra>`
          });

          if(st.showReg && !allScope && y.length>=2){
            const idx=[];
            for(const d of x){ idx.push(dateIndex[String(d)]); }
            const fit = linFit(idx, y);
            if(fit){
              let mn=idx[0], mx=idx[0];
              for(const v of idx){ if(v<mn) mn=v; if(v>mx) mx=v; }
              const x0 = dates[Math.max(0, Math.min(dates.length-1, Math.floor(mn)))];
              const x1 = dates[Math.max(0, Math.min(dates.length-1, Math.ceil(mx)))];
              traces.push({
                type:'scatter',
                mode:'lines',
                name:`Regression – ${ln}`,
                legendgroup:ln,
                showlegend:false,
                hovertemplate:`<b>${LINE_TITLE}: ${ln}</b><br>Regression (means)<br>y = ${fit.m.toFixed(4)}·x + ${fit.b.toFixed(4)}<extra></extra>` ,
                x:[x0,x1],
                y:[fit.m*mn + fit.b, fit.m*mx + fit.b],
                line:{width:1.5,color:baseCol,dash:'dash'}
              });
            }
          }
        }
        return traces;
      }

      for(const ln of lines){
        const S=store[mk][ln];
        if(!S) continue;

        const baseCol = colorFor(ln);

        const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
        const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
        const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
        const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;

        const f = applyFilters(bx,by,bt,bi,mk,ln,st);

        // Points / labels
        const cellLine = st.showCell ? '<br>Cell %{text}' : '';
        const pmKey = isPointsModeKey(st.pointsMode) ? st.pointsMode : 'auto';
        // Auto: hide individual points if too many unless "Extremes" is enabled
        let pointsMode = false;
        if(pmKey==='auto'){
          pointsMode = (st.includeExt || f.Y.length <= 9000) ? (st.includeExt ? 'all' : 'suspectedoutliers') : false;
        }else if(pmKey==='none'){
          pointsMode = false;
        }else{
          pointsMode = pmKey;
        }

        const statsHoverCache = Object.create(null);
        const valsByDate = Object.create(null);
        for(let i=0;i<f.Y.length;i++){
          const d = String(f.X[i]);
          (valsByDate[d]||(valsByDate[d]=[])).push(f.Y[i]);
        }
        function baseHoverForDate(d){
          const key = String(d);
          if(statsHoverCache[key] != null) return statsHoverCache[key];
          const arr = valsByDate[key];
          if(arr && arr.length){
            const q = quantiles(arr);
            statsHoverCache[key] = (
              `<b>${HOVER_CAT_TITLE}: ${key}</b><br>`+
              `Min ${fmtN(q.min)}<br>Q1 ${fmtN(q.q1)}<br>Median ${fmtN(q.med)}<br>Q3 ${fmtN(q.q3)}<br>Max ${fmtN(q.max)}<br>`+
              `n ${arr.length}`
            );
          }else{
            statsHoverCache[key] = (`<b>${HOVER_CAT_TITLE}: ${key}</b>`);
          }
          return statsHoverCache[key];
        }

        const boxHover = f.X.map((d,i)=>{
          return baseHoverForDate(d) + `<br>Value ${fmtN(f.Y[i])}`;
        });

        const baseDist={
          name:ln,
          legendgroup:ln,
          offsetgroup:ln,
          x:f.X,
          y:f.Y,
          text:f.T,
          hovertext:boxHover,
          customdata:f.I,
          hovertemplate:`<b>${LINE_TITLE}: %{fullData.name}</b><br>%{hovertext}${cellLine}<extra></extra>`,
          showlegend:true
        };

        if(chartType==='violin' || chartType==='raincloud'){
          traces.push(Object.assign({
            type:'violin',
            points: pointsMode,
            jitter: st.includeExt ? 0.25 : 0,
            pointpos:0,
            scalemode:'width',
            side:(chartType==='raincloud') ? 'positive' : 'both',
            box:{visible:true, width:0.22},
            meanline:{visible:false},
            marker:{ size:7, color:baseCol, line:{color:'rgba(0,0,0,0)', width:0}, opacity:0.98 },
            line:{ width:1.2, color:baseCol },
            fillcolor:rgba(baseCol, 0.12)
          }, baseDist));
        }else if(chartType==='strip' || chartType==='swarm'){
          traces.push(Object.assign({
            type:'box',
            boxpoints:'all',
            hoveron:'points',
            jitter:(chartType==='swarm') ? 0.80 : 0.45,
            pointpos:0,
            marker:{ size:(chartType==='swarm') ? 6 : 7, color:baseCol, line:{color:'rgba(0,0,0,0)', width:0}, opacity:0.98 },
            line:{ width:0, color:'rgba(0,0,0,0)' },
            fillcolor:'rgba(0,0,0,0)',
            whiskerwidth:0
          }, baseDist));
        }else{
          traces.push(Object.assign({
            type:'box',
            boxpoints: pointsMode,
            hoveron:'boxes+points',
            jitter: st.includeExt ? 0.35 : 0,
            pointpos:0,
            marker:{ size:7, color:baseCol, line:{color:'rgba(0,0,0,0)', width:0}, opacity:0.98 },
            line:{ width:1.2, color:baseCol },
            fillcolor:rgba(baseCol, 0.12),
            whiskerwidth:0.5
          }, baseDist));
        }

        // Median-by-date line should reflect the currently displayed distribution
        // (filters + exclude list + removed points + includeExt).
        const medX=[];
        const medY=[];
        for(const d of dates){
          const arr = valsByDate[String(d)];
          if(arr && arr.length){
            const q = quantiles(arr);
            medX.push(d);
            medY.push(q.med);
          }
        }
        if(st.showMed && !allScope && medY.length){
          traces.push({
            type:'scatter',
            mode:'lines+markers',
            name:`Median – ${ln}`,
            legendgroup:ln,
            showlegend:false,
            hoverinfo:'skip',
            x:medX,
            y:medY,
            line:{width:2,color:baseCol},
            marker:{size:6,color:baseCol}
          });
        }

        if(st.showReg && !allScope){
          // Regression based on ALL inlier points (non-extremes), respecting filters + exclusions.
          const regF = applyFilters(S.nmX, S.nmY, S.nmT, S.nmI, mk, ln, st);
          if(regF.Y.length >= 2){
            const maxFitPts = 5000;
            const step = Math.max(1, Math.ceil(regF.Y.length / maxFitPts));
            const idx=[];
            const yy=[];
            for(let i=0;i<regF.Y.length;i+=step){
              const ii = dateIndex[String(regF.X[i])];
              if(!Number.isFinite(ii)) continue;
              idx.push(ii);
              yy.push(regF.Y[i]);
            }
            if(idx.length >= 2){
              const fit = linFit(idx, yy);
              if(fit){
                let mn=idx[0], mx=idx[0];
                for(const v of idx){ if(v<mn) mn=v; if(v>mx) mx=v; }
                const x0 = dates[Math.max(0, Math.min(dates.length-1, Math.floor(mn)))];
                const x1 = dates[Math.max(0, Math.min(dates.length-1, Math.ceil(mx)))];
                traces.push({
                  type:'scatter',
                  mode:'lines',
                  name:`Regression – ${ln}`,
                  legendgroup:ln,
                  showlegend:false,
                  hovertemplate:`<b>${LINE_TITLE}: ${ln}</b><br>Regression (inliers)<br>y = ${fit.m.toFixed(4)}·x + ${fit.b.toFixed(4)}<extra></extra>`,
                  x:[x0,x1],
                  y:[fit.m*mn + fit.b, fit.m*mx + fit.b],
                  line:{width:1.5,color:baseCol,dash:'dash'}
                });
              }
            }
          }
        }

        if(st.includeExt && budget>0 && S.extY.length){
          const extF = applyFilters(S.extX,S.extY,S.extT, S.extI, mk, ln, st);
          if(extF.Y.length){
            // Budget: downsample extremes if too many
            const take = Math.min(extF.Y.length, Math.max(200, budget));
            const step = Math.max(1, Math.ceil(extF.Y.length / take));
            const sx=[], sy=[], stt=[];
            for(let i=0;i<extF.Y.length;i+=step){ sx.push(extF.X[i]); sy.push(extF.Y[i]); stt.push(extF.T[i]); }
            traces.push({
              type:'scatter',
              mode:'markers',
              name:`Extremes – ${ln}`,
              legendgroup:ln,
              showlegend:false,
              x:sx,
              y:sy,
              text:stt,
              marker:{ size:8, color:baseCol, symbol:'x', line:{width:1,color:T.TXT} },
              hovertemplate:`<b>${LINE_TITLE}: ${ln}</b><br><b>${HOVER_CAT_TITLE}: %{x}</b><br>Value %{y:.4f}${cellLine}<extra></extra>`
            });
            budget -= sx.length;
          }
        }
      }

      if(st.showMed && allScope){
        const buckets = Object.create(null);
        for(const d of dates) buckets[d]=[];

        for(const ln of lines){
          const S=store[mk][ln];
          if(!S) continue;
          const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
          const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
          const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
          const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;
          const f = applyFilters(bx,by,bt,bi,mk,ln,st);
          for(let i=0;i<f.Y.length;i++){
            const d = String(f.X[i]);
            if(!buckets[d]) buckets[d]=[];
            buckets[d].push(f.Y[i]);
          }
        }

        const mx=[], my=[];
        for(const d of dates){
          const arr=buckets[d];
          if(!arr || !arr.length) continue;
          const q = quantiles(arr);
          if(q.med==null) continue;
          mx.push(d);
          my.push(q.med);
        }

        if(my.length){
          const allCol = (CUR_THEME==='dark') ? '#fbbf24' : '#b45309';
          traces.push({
            type:'scatter',
            mode:'lines+markers',
            name:'Median – All groups',
            legendgroup:'__all_stats__',
            showlegend:false,
            hoverinfo:'skip',
            x:mx,
            y:my,
            line:{width:2,color:allCol},
            marker:{size:6,color:allCol}
          });
        }
      }

      if(st.showReg && allScope){
        const idx=[];
        const yy=[];
        for(const ln of lines){
          const S=store[mk][ln];
          if(!S) continue;
          const regF = applyFilters(S.nmX, S.nmY, S.nmT, S.nmI, mk, ln, st);
          for(let i=0;i<regF.Y.length;i++){
            const ii = dateIndex[String(regF.X[i])];
            if(!Number.isFinite(ii)) continue;
            idx.push(ii);
            yy.push(regF.Y[i]);
          }
        }

        if(idx.length >= 2){
          const maxFitPts = 7000;
          let sIdx=idx, sY=yy;
          if(idx.length > maxFitPts){
            const step = Math.max(1, Math.ceil(idx.length / maxFitPts));
            const nIdx=[], nY=[];
            for(let i=0;i<idx.length;i+=step){ nIdx.push(idx[i]); nY.push(yy[i]); }
            sIdx=nIdx; sY=nY;
          }

          const fit = linFit(sIdx, sY);
          if(fit){
            let mn=sIdx[0], mx=sIdx[0];
            for(const v of sIdx){ if(v<mn) mn=v; if(v>mx) mx=v; }
            const x0 = dates[Math.max(0, Math.min(dates.length-1, Math.floor(mn)))];
            const x1 = dates[Math.max(0, Math.min(dates.length-1, Math.ceil(mx)))];
            const allCol = (CUR_THEME==='dark') ? '#fbbf24' : '#b45309';
            traces.push({
              type:'scatter',
              mode:'lines',
              name:'Regression – All groups',
              legendgroup:'__all_stats__',
              showlegend:false,
              hovertemplate:`Regression (inliers)<br>y = ${fit.m.toFixed(4)}·x + ${fit.b.toFixed(4)}<extra></extra>`,
              x:[x0,x1],
              y:[fit.m*mn + fit.b, fit.m*mx + fit.b],
              line:{width:1.5,color:allCol,dash:'dash'}
            });
          }
        }
      }

      return traces;
    }

    // Popover helpers
    function findModebarBtn(gd, re){
      const mb=gd.querySelector('.modebar');
      if(!mb) return null;
      return Array.from(mb.querySelectorAll('.modebar-btn')).find(b=>{
        const t=b.getAttribute('data-title') || b.getAttribute('title') || '';
        return re.test(t);
      }) || null;
    }

    function closePopover(fn){
      const el = fn._el;
      if(el && el.parentNode) el.parentNode.removeChild(el);
      if(fn._rePos){ removeEventListener('resize', fn._rePos); removeEventListener('scroll', fn._rePos); }
      fn._el=null; fn._rePos=null;
    }

    function openFilterPopover(gd, chartId){
      closePopover(openFilterPopover);
      const st=state[chartId];
      const mk=decodeURIComponent(gd.getAttribute('data-measure'));

      function autoMinMax(){
        let mn=null, mx=null;
        const tmpSt = Object.assign({}, st, { fmin:null, fmax:null });
        for(const ln of lines){
          const S = store[mk] && store[mk][ln];
          if(!S) continue;
          const bx = tmpSt.includeExt ? S.nmX.concat(S.extX) : S.nmX;
          const by = tmpSt.includeExt ? S.nmY.concat(S.extY) : S.nmY;
          const bt = tmpSt.includeExt ? S.nmT.concat(S.extT) : S.nmT;
          const bi = tmpSt.includeExt ? S.nmI.concat(S.extI) : S.nmI;
          const f = applyFilters(bx, by, bt, bi, mk, ln, tmpSt);
          for(const y of f.Y){
            if(!Number.isFinite(y)) continue;
            if(mn==null || y<mn) mn=y;
            if(mx==null || y>mx) mx=y;
          }
        }
        return {mn,mx};
      }

      const rng = autoMinMax();
      const fmtBox=(v)=> (v==null || !Number.isFinite(v)) ? '' : (Math.round((+v)*1000)/1000).toString();
      const defaultMin = (st.fmin!=null) ? st.fmin : rng.mn;
      const defaultMax = (st.fmax!=null) ? st.fmax : rng.mx;

      const pop=document.createElement('div');
      pop.className='menu-pop';
      const hint = filterIndicatorText(st);
      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Filter</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div class="group">
          <div style="padding:6px 8px;border:1px solid #e5e7eb;border-radius:10px;background:rgba(148,163,184,.10);font-size:12px">${hint ? hint : 'No filters applied.'}</div>
          <div style="font-weight:600">Keep only values:</div>
          <div class="row"><input id="fp-min" inputmode="decimal" placeholder="Min value" value="${fmtBox(defaultMin)}" style="width:140px"></div>
          <div class="row"><input id="fp-max" inputmode="decimal" placeholder="Max value" value="${fmtBox(defaultMax)}" style="width:140px"></div>
          <label class="row" style="cursor:pointer">
            <input id="fp-exo" type="checkbox" ${st.includeExt ? '' : 'checked'} style="width:auto">
            <span style="white-space:nowrap">Exclude outliers (IQR)</span>
          </label>
          <label class="row" style="cursor:pointer">
            <input id="fp-ext" type="checkbox" ${st.excludeExtremes ? 'checked' : ''} style="width:auto">
            <span style="white-space:nowrap">Exclude extremes</span>
          </label>
          <div class="row">
            <button id="fp-apply" style="flex:1">Apply</button>
            <button id="fp-clear" style="flex:1">Clear</button>
          </div>
        </div>
      `;
      (gd._fsOverlay || document.body).appendChild(pop);

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='close') closePopover(openFilterPopover);
      });

      function place(){
        const btn=findModebarBtn(gd,/Filter/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      let edited=false;
      pop.querySelector('#fp-min').addEventListener('input', ()=>{ edited=true; });
      pop.querySelector('#fp-max').addEventListener('input', ()=>{ edited=true; });

      pop.querySelector('#fp-apply').onclick=()=>{
        const v0=toNum(pop.querySelector('#fp-min').value);
        const v1=toNum(pop.querySelector('#fp-max').value);
        const exo = !!pop.querySelector('#fp-exo').checked;
        const ext = !!pop.querySelector('#fp-ext').checked;
        st.includeExt = !exo;
        st.excludeExtremes = ext;

        const hadOverride = (st.fmin!=null || st.fmax!=null);
        if(edited || hadOverride){
          st.fmin = v0;
          st.fmax = v1;
        }

        st.uirev++; draw(chartId);
        closePopover(openFilterPopover);
      };
      pop.querySelector('#fp-clear').onclick=()=>{
        st.fmin = st.fmax = null;
        st.includeExt = false;
        st.excludeExtremes = false;
        st.uirev++; draw(chartId);
        closePopover(openFilterPopover);
      };
      

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openFilterPopover); }, {capture:true, once:true}),0);

      openFilterPopover._el=pop;
      openFilterPopover._rePos=rePos;
    }

    // Zoom helpers (category-safe)
    const getRange=(gd,axis)=>{
      const ax=gd._fullLayout && gd._fullLayout[axis+'axis'];
      return (ax && ax.range) ? ax.range.slice() : null;
    };
    const setRange=(gd,axis,r)=>{
      const o={};
      o[axis+'axis.range']=r;
      return Plotly.relayout(gd,o);
    };
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    function asIndexRange(range){
      if(range==null) return null;
      let [a,b]=range;
      const toIdx=(v)=> (typeof v==='number') ? v : Math.max(0, dates.indexOf(String(v)));
      return [toIdx(a), toIdx(b)];
    }
    function zoomAxis(gd,axis,dir){
      const r=getRange(gd,axis);
      if(!r){
        const o={}; o[axis+'axis.autorange']=true;
        return Plotly.relayout(gd,o).then(()=>zoomAxis(gd,axis,dir));
      }
      let [a,b] = (axis==='x') ? asIndexRange(r) : r;
      const c=(a+b)/2;
      const half=(b-a)/2;
      const f = (dir==='in') ? 0.8 : 1.25;
      const nh = half * f;
      if(axis==='x'){
        const N=dates.length;
        const mn=-0.5, mx=N-0.5;
        a=clamp(c-nh,mn,mx);
        b=clamp(c+nh,mn,mx);
        if(b-a<1){ a=c-0.5; b=c+0.5; }
      }else{
        const eps=1e-9;
        a=c-nh; b=c+nh;
        if((b-a)<eps){ a=c-1; b=c+1; }
      }
      return setRange(gd,axis,[a,b]);
    }
    function resetAxis(gd,axis){
      const o={}; o[axis+'axis.autorange']=true;
      return Plotly.relayout(gd,o);
    }

    function openZoomMenu(gd, chartId){
      closePopover(openZoomMenu);
      const st=state[chartId];
      const pop=document.createElement('div');
      pop.className='menu-pop vlist';
      pop.style.borderColor = frameBorder();
      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Zoom</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <button data-act="xin">X+</button>
        <button data-act="xout">X−</button>
        <button data-act="xreset">X reset</button>
        <button data-act="yin">Y+</button>
        <button data-act="yout">Y−</button>
        <button data-act="yreset">Y reset</button>
        <button data-act="both">Reset both</button>
        <button data-act="pan">Pan (drag): ${st.dragPan ? 'On' : 'Off'}</button>
      `;
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Zoom menu/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(!act) return;
        if(act==='xin') zoomAxis(gd,'x','in');
        if(act==='xout') zoomAxis(gd,'x','out');
        if(act==='xreset') resetAxis(gd,'x');
        if(act==='yin') zoomAxis(gd,'y','in');
        if(act==='yout') zoomAxis(gd,'y','out');
        if(act==='yreset') resetAxis(gd,'y');
        if(act==='both'){ resetAxis(gd,'x'); resetAxis(gd,'y'); }
        if(act==='pan'){
          st.dragPan = !st.dragPan;
          Plotly.relayout(gd, { dragmode: st.dragPan ? 'pan' : false });
          closePopover(openZoomMenu);
          openZoomMenu(gd, chartId);
          return;
        }
        if(act==='close') closePopover(openZoomMenu);
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openZoomMenu); }, {capture:true, once:true}),0);

      openZoomMenu._el=pop;
      openZoomMenu._rePos=rePos;
    }

    function openDownloadsMenu(gd, chartId, title){
      closePopover(openDownloadsMenu);
      const pop=document.createElement('div');
      pop.className='menu-pop vlist';
      pop.style.borderColor = frameBorder();
      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Export</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div class="hdr" style="margin-top:6px">Chart</div>
        <button data-act="dl-img">PNG</button>
        <button data-act="dl-pdf">PDF</button>
        <div class="sep"></div>
        <div class="hdr" style="margin-top:6px">Stats Data</div>
        <button data-act="dl-status">CSV</button>
        <button data-act="dl-excel-status">Excel</button>
        <button data-act="dl-copy-status">Copy</button>
        <div class="sep"></div>
        <div class="hdr" style="margin-top:6px">Raw Data</div>
        <button data-act="dl-raw-csv">CSV</button>
        <button data-act="dl-raw-excel">Excel</button>
      `;
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Downloads/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(!act) return;
        if(act==='close'){ closePopover(openDownloadsMenu); return; }
        if(act==='dl-raw-csv'){ downloadRawDataCSV(); closePopover(openDownloadsMenu); return; }
        if(act==='dl-raw-excel'){ downloadRawDataExcel(); closePopover(openDownloadsMenu); return; }
        if(act==='dl-status'){ downloadStatusCSV(gd, chartId, title); closePopover(openDownloadsMenu); return; }
        if(act==='dl-excel-status'){ downloadStatusExcel(gd, chartId, title); closePopover(openDownloadsMenu); return; }
        if(act==='dl-copy-status'){ copyThisChartStatusCSV(gd, chartId, title); closePopover(openDownloadsMenu); return; }
        if(act==='dl-img'){
          const fn = (title || 'chart').replace(/<[^>]+>/g,'').trim().replace(/\s+/g,'_');
          Plotly.downloadImage(gd, {format:'png', scale:2, filename: fn});
          closePopover(openDownloadsMenu);
          return;
        }
        if(act==='dl-pdf'){
          downloadThisChartPDF(gd, chartId, title);
          closePopover(openDownloadsMenu);
          return;
        }
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openDownloadsMenu); }, {capture:true, once:true}),0);

      openDownloadsMenu._el=pop;
      openDownloadsMenu._rePos=rePos;
    }

    function openThemeMenu(anchorEl){
      closePopover(openThemeMenu);
      const pop=document.createElement('div');
      pop.className='menu-pop vlist';
      pop.style.borderColor = frameBorder();
      const items = THEME_ORDER.map(k=>{
        const cur = (k===CUR_THEME);
        const name = k.charAt(0).toUpperCase()+k.slice(1);
        return `<button data-theme="${k}">${cur?'✓ ':''}${name}</button>`;
      }).join('');
      pop.innerHTML=`
        <div class="hdr hdr-top"><span class="ttl">Theme</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        ${items}`;
      document.body.appendChild(pop);

      function place(){
        const r=anchorEl && anchorEl.getBoundingClientRect ? anchorEl.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='close'){ closePopover(openThemeMenu); return; }
        const thm = e.target && e.target.getAttribute && e.target.getAttribute('data-theme');
        if(thm){
          CUR_THEME = thm;
          setThemeAttr();
          applyFrameBorder();
          renderHeader();
          for(const id in state){
            state[id].uirev++;
            draw(id);
          }
          closePopover(openThemeMenu);
        }
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openThemeMenu); }, {capture:true, once:true}),0);
      openThemeMenu._el=pop;
      openThemeMenu._rePos=rePos;
    }

    function openHelpMenu(anchorEl){
      closePopover(openHelpMenu);
      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.borderColor = frameBorder();
      pop.innerHTML=`
        <div class="hdr hdr-top"><span class="ttl">Help</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div style="font:12px/1.45 system-ui; opacity:.9; max-width:320px">
          <div style="font-weight:700; margin:6px 0">Titlebar Controls</div>
          <div><b>Home</b>: reset all charts to defaults.</div>
          <div><b>Type</b>: chart type (box/violin/scatter) for all charts.</div>
          <div><b>Points</b>: marker visibility, labels, legend settings (all charts).</div>
          <div><b>Status</b>: show/hide data table below charts.</div>
          <div><b>Stats</b>: statistics overlay for all charts.</div>
          <div><b>Layout</b>: charts per row, grid spacing, graph size.</div>
          <div><b>Theme</b>: toggle light/paper/dark themes.</div>
          <div><b>Download</b>: export all charts as PDF/PNG/CSV/Excel.</div>
          <div><b>Help</b>: this help popup.</div>
          <div style="font-weight:700; margin-top:10px; margin-bottom:6px">Chart Modebar</div>
          <div><b>Reset</b>: restore defaults for this chart.</div>
          <div><b>View</b>: chart type (box/violin/scatter) for current chart.</div>
          <div><b>Points</b>: extremes/outliers/all markers, labels, legend.</div>
          <div><b>Filter</b>: min/max range filtering.</div>
          <div><b>Remove</b>: click mode to delete individual data points.</div>
          <div><b>Stats</b>: mean/median lines, quartiles.</div>
          <div><b>Y-axis</b>: scale mode (auto/0-based/log) + manual range.</div>
          <div><b>Targets</b>: add min/max target lines or bands (enter values and click Apply).</div>
          <div><b>Zoom</b>: X/Y zoom controls + pan drag mode.</div>
          <div><b>Theme</b>: select light/paper/dark theme.</div>
          <div><b>Download</b>: export this chart as PNG/PDF/CSV/Excel.</div>
          <div><b>Fullscreen</b>: toggle fullscreen mode for chart.</div>
        </div>
      `;
      document.body.appendChild(pop);
      function place(){
        const r=(anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});
      pop.querySelector('.xbtn').onclick=()=>closePopover(openHelpMenu);
      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openHelpMenu); }, {capture:true, once:true}),0);
      openHelpMenu._el=pop;
      openHelpMenu._rePos=rePos;
    }

    function openDownloadsMenuAll(anchorEl){
      closePopover(openDownloadsMenuAll);
      const pop=document.createElement('div');
      pop.className='menu-pop vlist';
      pop.style.borderColor = frameBorder();
      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Export</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div class="hdr" style="margin-top:6px">All graphs</div>
        <button data-act="dl-allpdf" ${pdfReady()?'':'disabled'}>PDF</button>
        <div class="hdr" style="margin-top:6px">All data</div>
        <button data-act="dl-allstatus">CSV</button>
        <button data-act="dl-allexcel-status">Excel</button>
      `;
      document.body.appendChild(pop);

      function place(){
        const r=(anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(!act) return;
        if(act==='close'){ closePopover(openDownloadsMenuAll); return; }
        if(act==='dl-allstatus'){ downloadAllStatusCSV(); closePopover(openDownloadsMenuAll); return; }
        if(act==='dl-allexcel-status'){ downloadAllStatusExcel(); closePopover(openDownloadsMenuAll); return; }
        if(act==='dl-allpdf'){ if(pdfReady()) downloadAllChartsPDF(); closePopover(openDownloadsMenuAll); return; }
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openDownloadsMenuAll); }, {capture:true, once:true}),0);
      openDownloadsMenuAll._el=pop;
      openDownloadsMenuAll._rePos=rePos;
    }

    function openLayoutMenu(gd, chartId){
      closePopover(openLayoutMenu);
      const st=state[chartId];
      const pop=document.createElement('div');
      pop.className='menu-pop vlist';
      pop.style.borderColor = frameBorder();
      pop.style.minWidth='240px';

      const curCols = grid.classList.contains('cols3') ? 3 : (grid.classList.contains('cols2') ? 2 : 1);
      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Layout</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div class="hdr" style="margin-top:6px">Multiples (charts per row)</div>
        <div class="row" style="gap:6px;flex-wrap:wrap">
          <label class="seg"><input type="radio" name="cols" value="1" ${curCols===1?'checked':''}><span>1</span></label>
          <label class="seg"><input type="radio" name="cols" value="2" ${curCols===2?'checked':''}><span>2</span></label>
          <label class="seg"><input type="radio" name="cols" value="3" ${curCols===3?'checked':''}><span>3</span></label>
        </div>
        <div class="hdr" style="margin-top:6px">Space (grid gap px)</div>
        <div class="row" style="align-items:center">
          <input id="gap" inputmode="numeric" placeholder="Gap" value="${GRID_GAP}" style="width:90px;flex:0 0 90px">
          <button id="gap-apply" style="width:auto;flex:1;text-align:center">Apply</button>
          <button id="gap-reset" style="width:auto;flex:1;text-align:center">Reset</button>
        </div>
      `;
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Layout|Multiples|Space/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='close'){ closePopover(openLayoutMenu); return; }
      });

      pop.addEventListener('change',(e)=>{
        const t = e && e.target;
        if(!t) return;
        if(t.name==='cols'){
          const n = parseInt(String(t.value||'1'), 10);
          applyCols(Math.min(3, Math.max(1, n||1)));
          closePopover(openLayoutMenu);
          openLayoutMenu(gd, chartId);
        }
      }, {passive:true});

      pop.querySelector('#gap-apply').onclick=()=>{
        const v = toNum(pop.querySelector('#gap').value);
        applyGridGap(v==null ? GRID_GAP_DEFAULT : v);
        closePopover(openLayoutMenu);
      };
      pop.querySelector('#gap-reset').onclick=()=>{
        applyGridGap(GRID_GAP_DEFAULT);
        closePopover(openLayoutMenu);
      };

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openLayoutMenu); }, {capture:true, once:true}),0);
      openLayoutMenu._el=pop;
      openLayoutMenu._rePos=rePos;
    }

    function openTargetsMenu(gd, chartId){
      closePopover(openTargetsMenu);
      const st=state[chartId];

      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.borderColor = frameBorder();
      pop.style.minWidth='180px';

      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Targets</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div class="hdr" style="margin-top:6px">Style</div>
        <div class="segrow">
          <label class="seg"><input type="radio" name="band" value="line" ${!st.band?'checked':''}><span>Line</span></label>
          <label class="seg"><input type="radio" name="band" value="area" ${st.band?'checked':''}><span>Band</span></label>
        </div>
        <div style="margin-top:6px"><input id="tg-min" type="number" placeholder="min" value="${Number.isFinite(st.minT)?st.minT:''}" style="width:140px"></div>
        <div style="margin-top:6px"><input id="tg-max" type="number" placeholder="max" value="${Number.isFinite(st.maxT)?st.maxT:''}" style="width:140px"></div>
        <div style="margin-top:6px; display:flex; gap:6px">
          <button data-act="apply">Apply</button>
          <button data-act="clear">Clear</button>
        </div>
      `;
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Targets/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('change',(e)=>{
        if(e.target.name==='band'){
          st.band = (e.target.value==='area');
          st.uirev++;
          draw(chartId);
        }
      });

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(!act) return;
        if(act==='close'){ closePopover(openTargetsMenu); return; }
        if(act==='apply'){
          const mi=parseFloat(pop.querySelector('#tg-min').value);
          const ma=parseFloat(pop.querySelector('#tg-max').value);
          st.minT = Number.isFinite(mi) ? mi : null;
          st.maxT = Number.isFinite(ma) ? ma : null;
          st.showTargets = true;
          st.uirev++; draw(chartId);
          closePopover(openTargetsMenu);
          return;
        }
        if(act==='clear'){
          st.minT = null;
          st.maxT = null;
          st.showTargets = false;
          st.uirev++; draw(chartId);
          closePopover(openTargetsMenu);
          return;
        }
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openTargetsMenu); }, {capture:true, once:true}),0);
      openTargetsMenu._el=pop;
      openTargetsMenu._rePos=rePos;
    }

    function openPointsMenu(gd, chartId){
      closePopover(openPointsMenu);
      const st=state[chartId];
      const chartType = st.chartType || 'box';
      const isHist = (chartType==='hist' || chartType==='histkde');
      const pointsRelevant = (chartType==='box' || chartType==='violin' || chartType==='strip' || chartType==='swarm' || chartType==='raincloud');
      const cellRelevant = pointsRelevant; // cell is only shown in point-level hover on these chart types

      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.borderColor = frameBorder();
      pop.style.minWidth='260px';

      const pm = isPointsModeKey(st.pointsMode) ? st.pointsMode : 'auto';
      const curLeg = normLegendPos((st.legendPos!=null && st.legendPos!=='') ? st.legendPos : (LEG_POS || 'auto'));
      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">${isHist ? 'Histogram options' : (pointsRelevant ? 'Points • Labels • Legend' : 'Legend')}</span><button class="xbtn" data-act="close" title="Close">×</button></div>

        ${isHist ? (`
          <div class="hdr" style="margin-top:6px">Labels</div>
          <div class="segrow">
            <label class="seg"><input type="radio" name="hcounts" value="0" ${st.histShowCounts ? '' : 'checked'}><span>Off</span></label>
            <label class="seg"><input type="radio" name="hcounts" value="1" ${st.histShowCounts ? 'checked' : ''}><span>On</span></label>
          </div>
          <div class="hdr" style="margin-top:6px">Bars</div>
          <div class="segrow">
            <label class="seg"><input type="radio" name="hsep" value="0" ${st.histSeparateBars ? '' : 'checked'}><span>Overlay</span></label>
            <label class="seg"><input type="radio" name="hsep" value="1" ${st.histSeparateBars ? 'checked' : ''}><span>Separate</span></label>
          </div>
        `) : (pointsRelevant ? (`
          <div class="hdr" style="margin-top:6px">Points</div>
          <div class="segrow">
            <label class="seg"><input type="radio" name="pm" value="auto" ${pm==='auto'?'checked':''}><span>Auto</span></label>
            <label class="seg"><input type="radio" name="pm" value="none" ${pm==='none'?'checked':''}><span>None</span></label>
            <label class="seg"><input type="radio" name="pm" value="all" ${pm==='all'?'checked':''}><span>All</span></label>
          </div>
          ${cellRelevant ? (`
            <div class="hdr" style="margin-top:6px">Cell label (hover)</div>
            <div class="segrow">
              <label class="seg"><input type="radio" name="cell" value="0" ${st.showCell ? '' : 'checked'}><span>Off</span></label>
              <label class="seg"><input type="radio" name="cell" value="1" ${st.showCell ? 'checked' : ''}><span>On</span></label>
            </div>
          `) : ''}
        `) : '')}

        <div class="hdr" style="margin-top:6px">Legend</div>
        <div class="segrow">
          <label class="seg"><input type="radio" name="legshow" value="1" ${st.showLegend?'checked':''}><span>Show</span></label>
          <label class="seg"><input type="radio" name="legshow" value="0" ${st.showLegend?'':'checked'}><span>Hide</span></label>
        </div>
        <div class="hdr" style="margin-top:6px">Legend position</div>
        <div class="segrow">
          ${LEG_OPTS.map((o)=>{
            const lbl = o.replace(/-/g,' ').replace(/\b\w/g,(m)=>m.toUpperCase());
            return `<label class="seg"><input type="radio" name="legpos" value="${o}" ${(curLeg===o)?'checked':''}><span>${lbl}</span></label>`;
          }).join('')}
        </div>
      `;
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Points|Labels|Legend/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.closest && e.target.closest('[data-act]') ? e.target.closest('[data-act]').getAttribute('data-act') : (e.target && e.target.getAttribute && e.target.getAttribute('data-act'));
        if(act==='close'){ closePopover(openPointsMenu); return; }
      });

      pop.addEventListener('change',(e)=>{
        const t=e.target;
        if(!t || !t.name) return;
        if(t.name==='cell'){ st.showCell=(String(t.value||'0')==='1'); st.uirev++; draw(chartId); closePopover(openPointsMenu); return; }
        if(t.name==='legshow'){ st.showLegend=(String(t.value||'1')==='1'); st.uirev++; draw(chartId); closePopover(openPointsMenu); return; }
        if(t.name==='pm'){ st.pointsMode=String(t.value||'auto'); st.uirev++; draw(chartId); closePopover(openPointsMenu); return; }
        if(t.name==='legpos'){
          const v=String(t.value||'');
          st.legendPos = v ? v : null;
          st.uirev++;
          draw(chartId);
          closePopover(openPointsMenu);
          return;
        }
        if(t.name==='hcounts'){ st.histShowCounts=(String(t.value||'0')==='1'); st.uirev++; draw(chartId); closePopover(openPointsMenu); return; }
        if(t.name==='hsep'){ st.histSeparateBars=(String(t.value||'0')==='1'); st.uirev++; draw(chartId); closePopover(openPointsMenu); return; }
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openPointsMenu); }, {capture:true, once:true}),0);
      openPointsMenu._el=pop;
      openPointsMenu._rePos=rePos;
    }

    function resetAllChartsToDefaults(){
      USER_SIZE.scale = 1;
      USER_SIZE.heightPx = null;
      applyChartSizeAll();
      for(const id in state){
        const st=state[id];
        if(!st) continue;
        st.fmin = st.fmax = null;
        if(st.exclude && typeof st.exclude.clear==='function') st.exclude.clear();
        if(st.removed && typeof st.removed.clear==='function') st.removed.clear();
        st.includeExt=false;
        st.showMed=false;
        st.showReg=false;
        st.statsScope='group';
        st.dragPan=false;
        st.showStatus=false;
        st.yScaleMode='auto';
        st.yMin=null;
        st.yMax=null;
        st.showLegend=LEG_SHOW;
        st.legendPos=null;
        st.chartType='box';
        st.chartTypeApply='this';
        st.histBins=DEFAULT_HIST_BINS;
        st.histShowCounts=false;
        st.histSeparateBars=false;
        st.errMode='std';
        st.trellisOn=false;
        st.xScroll=false;
        st.uirev = (st.uirev||1) + 1;
        try{ closePopover(openZoomMenu); closePopover(openDownloadsMenu); closePopover(openFilterPopover); closePopover(openLegendMenu); closePopover(openStatsMenu); closePopover(openYAxisMenu); closePopover(openSizeMenu); closePopover(openTypeMenu); }catch(_){ }
        try{ draw(id); }catch(_){ }
      }
      try{ document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ markActiveButtons(el, el.id); }catch(_){ } }); }catch(_){ }
      renderHeader();
    }

    function togglePageFullscreen(){
      const root=document.documentElement;
      try{
        if(document.fullscreenElement){ document.exitFullscreen(); return; }
        if(root && root.requestFullscreen) root.requestFullscreen();
      }catch(_){ }
    }

    function setAllCharts(fn){
      for(const id in state){
        try{ fn(state[id], id); }catch(_){ }
      }
    }

    function redrawAllCharts(){
      for(const id in state){
        try{ state[id].uirev++; draw(id); }catch(_){ }
      }
    }

    function openTypeMenuAll(anchorEl){
      closePopover(openTypeMenuAll);
      const anyId = Object.keys(state)[0];
      if(!anyId) return;
      const st0 = state[anyId];
      const cur = st0.chartType || 'box';
      const curBins = (Number.isFinite(st0.histBins) && +st0.histBins>0) ? Math.floor(+st0.histBins) : DEFAULT_HIST_BINS;
      const bins = String(curBins);
      const showBins = (cur==='hist' || cur==='histkde');
      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.minWidth='260px';
      pop.style.borderColor = frameBorder();
      const distBy = ['box','violin','strip','swarm','raincloud'];
      const allData = ['hist','histkde','kde','ecdf'];
      const mkRadio = (o)=>{
        const tip = TYPE_DESC[o.k] ? String(TYPE_DESC[o.k]).replace(/"/g,'&quot;') : '';
        return `<label title="${tip}"><input type="radio" name="ct" value="${o.k}" ${cur===o.k?'checked':''}> ${o.label}</label>`;
      };
      pop.innerHTML =
        `<div class="hdr hdr-top"><span class="ttl">Chart type (All charts)</span><button class="xbtn" data-act="close" title="Close">×</button></div>`+
        `<div class="group">`+
          `<div class="hdr" style="margin-top:6px">Distribution by</div>`+
          `<div class="row">${TYPE_OPTS.filter(o=>distBy.includes(o.k)).map(mkRadio).join('')}</div>`+
          `<div class="hdr" style="margin-top:6px">All data</div>`+
          `<div class="row">${TYPE_OPTS.filter(o=>allData.includes(o.k)).map(mkRadio).join('')}</div>`+
          (showBins
            ? (`<div class="hdr" style="margin-top:6px">Histogram bins</div>`+
               `<div style="font-size:12px; opacity:.9">Default: ${DEFAULT_HIST_BINS}. Change and click Apply.</div>`+
               `<div class="row" style="align-items:center">`+
                 `<input id="type-bins" type="number" min="1" step="1" value="${bins}" style="width:90px;flex:0 0 90px">`+
                 `<label style="display:flex;align-items:center;gap:6px;cursor:pointer">`+
                   `<input id="type-sep" type="checkbox" ${st0.histSeparateBars?'checked':''} style="width:auto">`+
                   `<span>Separate bars</span>`+
                 `</label>`+
               `</div>`+
               `<div class="row"><button data-act="bins">Apply bins</button></div>`)
            : '')+
        `</div>`;
      document.body.appendChild(pop);

      function place(){
        const r=(anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('change',(e)=>{
        if(e.target && e.target.name==='ct'){
          const typ = String(e.target.value||'box');
          setAllCharts((st)=>{ st.chartType=typ; });
          redrawAllCharts();
          closePopover(openTypeMenuAll);
          if(typ==='hist' || typ==='histkde') openTypeMenuAll(anchorEl);
        }
      }, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='bins'){
          const inp = pop.querySelector('#type-bins');
          if(!inp) return;
          const v = inp ? String(inp.value||'').trim() : '';
          const n = v==='' ? DEFAULT_HIST_BINS : (+v);
          const nextBins = (Number.isFinite(n) && n>0) ? Math.floor(n) : DEFAULT_HIST_BINS;
          setAllCharts((st)=>{ st.histBins=nextBins; });
          redrawAllCharts();
          closePopover(openTypeMenuAll);
          return;
        }
        if(act==='close') closePopover(openTypeMenuAll);
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openTypeMenuAll); }, {capture:true, once:true}),0);
      openTypeMenuAll._el=pop;
      openTypeMenuAll._rePos=rePos;
    }

    function openPointsMenuAll(anchorEl){
      closePopover(openPointsMenuAll);
      const anyId = Object.keys(state)[0];
      if(!anyId) return;
      const st0=state[anyId];
      const pm = isPointsModeKey(st0.pointsMode) ? st0.pointsMode : 'auto';
      const curLeg = normLegendPos((st0.legendPos!=null && st0.legendPos!=='') ? st0.legendPos : (LEG_POS || 'auto'));

      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.borderColor = frameBorder();
      pop.style.minWidth='280px';
      pop.innerHTML =
        `<div class="hdr hdr-top"><span class="ttl">Points • Labels • Legend (All charts)</span><button class="xbtn" data-act="close" title="Close">×</button></div>`+
        `<div class="hdr" style="margin-top:6px">Extremes</div>`+
        `<div class="segrow">`+
          `<label class="seg"><input type="radio" name="ext" value="0" ${st0.includeExt ? '' : 'checked'}><span>Exclude</span></label>`+
          `<label class="seg"><input type="radio" name="ext" value="1" ${st0.includeExt ? 'checked' : ''}><span>Include</span></label>`+
        `</div>`+
        `<div class="hdr" style="margin-top:6px">Points</div>`+
        `<div class="segrow">`+
          `<label class="seg"><input type="radio" name="pm" value="auto" ${pm==='auto'?'checked':''}><span>Auto</span></label>`+
          `<label class="seg"><input type="radio" name="pm" value="none" ${pm==='none'?'checked':''}><span>None</span></label>`+
          `<label class="seg"><input type="radio" name="pm" value="suspectedoutliers" ${pm==='suspectedoutliers'?'checked':''}><span>Suspected</span></label>`+
          `<label class="seg"><input type="radio" name="pm" value="outliers" ${pm==='outliers'?'checked':''}><span>Outliers</span></label>`+
          `<label class="seg"><input type="radio" name="pm" value="all" ${pm==='all'?'checked':''}><span>All</span></label>`+
        `</div>`+
        `<div class="hdr" style="margin-top:6px">Labels</div>`+
        `<div class="segrow">`+
          `<label class="seg"><input type="radio" name="cell" value="0" ${st0.showCell ? '' : 'checked'}><span>Cell: Off</span></label>`+
          `<label class="seg"><input type="radio" name="cell" value="1" ${st0.showCell ? 'checked' : ''}><span>Cell: On</span></label>`+
        `</div>`+
        `<div class="hdr" style="margin-top:6px">Legend</div>`+
        `<div class="segrow">`+
          `<label class="seg"><input type="radio" name="legshow" value="1" ${st0.showLegend?'checked':''}><span>Show</span></label>`+
          `<label class="seg"><input type="radio" name="legshow" value="0" ${st0.showLegend?'':'checked'}><span>Hide</span></label>`+
        `</div>`+
        `<div class="hdr" style="margin-top:6px">Legend position</div>`+
        `<div class="segrow">`+
        LEG_OPTS.map((o)=>{
          const lbl = o.replace(/-/g,' ').replace(/\b\w/g,(m)=>m.toUpperCase());
          return `<label class="seg"><input type="radio" name="legpos" value="${o}" ${(curLeg===o)?'checked':''}><span>${lbl}</span></label>`;
        }).join('')+
        `</div>`;
      document.body.appendChild(pop);

      function place(){
        const r=(anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.closest && e.target.closest('[data-act]') ? e.target.closest('[data-act]').getAttribute('data-act') : (e.target && e.target.getAttribute && e.target.getAttribute('data-act'));
        if(act==='close'){ closePopover(openPointsMenuAll); return; }
      });

      pop.addEventListener('change',(e)=>{
        const t=e.target;
        if(!t || !t.name) return;
        if(t.name==='ext'){
          setAllCharts((st)=>{ st.includeExt=(String(t.value||'0')==='1'); });
          redrawAllCharts();
          closePopover(openPointsMenuAll);
          return;
        }
        if(t.name==='cell'){
          setAllCharts((st)=>{ st.showCell=(String(t.value||'0')==='1'); });
          redrawAllCharts();
          closePopover(openPointsMenuAll);
          return;
        }
        if(t.name==='legshow'){
          setAllCharts((st)=>{ st.showLegend=(String(t.value||'1')==='1'); });
          redrawAllCharts();
          closePopover(openPointsMenuAll);
          return;
        }
        if(t.name==='pm'){
          const v=String(t.value||'auto');
          setAllCharts((st)=>{ st.pointsMode=v; });
          redrawAllCharts();
          closePopover(openPointsMenuAll);
          return;
        }
        if(t.name==='legpos'){
          const v=String(t.value||'auto');
          setAllCharts((st)=>{ st.legendPos=v; });
          redrawAllCharts();
          closePopover(openPointsMenuAll);
          return;
        }
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openPointsMenuAll); }, {capture:true, once:true}),0);
      openPointsMenuAll._el=pop;
      openPointsMenuAll._rePos=rePos;
    }

    function openStatsMenuAll(anchorEl){
      closePopover(openStatsMenuAll);
      if(!Object.keys(state).length) return;
      const anyId = Object.keys(state)[0];
      const st0 = state[anyId];
      const mode = st0.showReg ? 'reg' : (st0.showMed ? 'med' : 'none');
      const scope = st0.statsScope || 'group';
      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.borderColor = frameBorder();
      pop.style.minWidth='260px';
      pop.innerHTML =
        `<div class="hdr hdr-top"><span class="ttl">Stats (All charts)</span><button class="xbtn" data-act="close" title="Close">×</button></div>`+
        `<div class="group">`+
          `<div class="hdr">Mode</div>`+
          `<div class="row">`+
            `<label class="seg"><input type="radio" name="sm" value="none" ${mode==='none'?'checked':''}><span>None</span></label>`+
            `<label class="seg"><input type="radio" name="sm" value="med" ${mode==='med'?'checked':''}><span>Median</span></label>`+
            `<label class="seg"><input type="radio" name="sm" value="reg" ${mode==='reg'?'checked':''}><span>Regression</span></label>`+
          `</div>`+
          `<div class="hdr" style="margin-top:6px">Scope</div>`+
          `<div class="row">`+
            `<label class="seg"><input type="radio" name="scp" value="group" ${scope==='group'?'checked':''}><span>By group</span></label>`+
            `<label class="seg"><input type="radio" name="scp" value="all" ${scope==='all'?'checked':''}><span>All groups</span></label>`+
          `</div>`+
        `</div>`;
      document.body.appendChild(pop);

      function place(){
        const r=(anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='close'){ closePopover(openStatsMenuAll); return; }
      });

      pop.addEventListener('change',(e)=>{
        if(!e.target || !e.target.name) return;
        if(e.target.name==='sm'){
          const m = String(e.target.value||'none');
          setAllCharts((st)=>{
            if(m==='none'){ st.showMed=false; st.showReg=false; }
            else if(m==='med'){ st.showMed=true; st.showReg=false; }
            else if(m==='reg'){ st.showMed=false; st.showReg=true; }
            st.uirev++;
          });
          redrawAllCharts();
          closePopover(openStatsMenuAll);
          return;
        }
        if(e.target.name==='scp'){
          const sc = String(e.target.value||'group');
          setAllCharts((st)=>{ st.statsScope=sc; st.uirev++; });
          redrawAllCharts();
          closePopover(openStatsMenuAll);
          return;
        }
      }, {passive:true});

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openStatsMenuAll); }, {capture:true, once:true}),0);
      openStatsMenuAll._el=pop;
      openStatsMenuAll._rePos=rePos;
    }

    // Y-axis menu (per-chart)
    function openYAxisMenu(gd, chartId){
      closePopover(openYAxisMenu);
      const st = state[chartId];
      if(!st) return;

      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.borderColor = frameBorder();
      pop.style.minWidth='260px';

      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Y-axis</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div class="group">
          <div class="hdr">Mode</div>
          <div class="row">
            <label class="seg"><input type="radio" name="ym" value="auto" ${st.yScaleMode==='auto'?'checked':''}><span>Auto</span></label>
            <label class="seg"><input type="radio" name="ym" value="zero" ${st.yScaleMode==='zero'?'checked':''}><span>0-based</span></label>
            <label class="seg"><input type="radio" name="ym" value="log" ${st.yScaleMode==='log'?'checked':''}><span>Log</span></label>
          </div>
          <div class="row"><input id="ymin" type="number" placeholder="min" value="${st.yMin??''}"></div>
          <div class="row"><input id="ymax" type="number" placeholder="max" value="${st.yMax??''}"></div>
          <div class="row"><button id="apply">Apply</button><button id="clear">Clear</button></div>
        </div>
      `;
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Y axis/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='close'){ closePopover(openYAxisMenu); return; }
      });

      pop.addEventListener('change',(e)=>{
        if(e.target.name==='ym'){
          st.yScaleMode = e.target.value;
          if(st.yScaleMode!=='manual'){ st.yMin=null; st.yMax=null; }
          st.uirev++; draw(chartId);
        }
      });

      pop.querySelector('#apply').onclick=()=>{
        const mi=parseFloat(pop.querySelector('#ymin').value);
        const ma=parseFloat(pop.querySelector('#ymax').value);
        st.yMin=Number.isFinite(mi)?mi:null;
        st.yMax=Number.isFinite(ma)?ma:null;
        st.yScaleMode='manual';
        st.uirev++; draw(chartId);
        closePopover(openYAxisMenu);
      };
      pop.querySelector('#clear').onclick=()=>{
        st.yMin=null; st.yMax=null; st.yScaleMode='auto';
        st.uirev++; draw(chartId);
        closePopover(openYAxisMenu);
      };

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openYAxisMenu); }, {capture:true, once:true}),0);
      openYAxisMenu._el=pop;
      openYAxisMenu._rePos=rePos;
    }

    // Enhanced Zoom menu (per-chart)
    function openZoomMenu(gd, chartId){
      closePopover(openZoomMenu);
      const st = state[chartId];
      if(!st) return;

      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.borderColor = frameBorder();
      pop.style.minWidth='260px';

      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Zoom</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div class="hdr" style="margin-top:6px">X-axis</div>
        <div class="row" style="gap:6px">
          <button data-z="xin" style="width:auto">X +</button>
          <button data-z="xout" style="width:auto">X −</button>
          <button data-z="xreset" style="width:auto">Reset</button>
        </div>
        <div class="row" style="margin-top:4px">
          <button data-z="xscroll" style="width:auto">Range slider: ${st.xScroll?'On':'Off'}</button>
        </div>
        <div class="hdr" style="margin-top:8px">Y-axis</div>
        <div class="row" style="gap:6px">
          <button data-z="yin" style="width:auto">Y +</button>
          <button data-z="yout" style="width:auto">Y −</button>
          <button data-z="yreset" style="width:auto">Reset</button>
        </div>
        <div class="hdr" style="margin-top:8px">Both</div>
        <div class="row" style="gap:6px">
          <button data-z="reset" style="width:auto">Reset both</button>
          <button data-z="pan" style="width:auto">Pan (drag): ${st.dragPan?'On':'Off'}</button>
        </div>
      `;
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Zoom/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='close'){ closePopover(openZoomMenu); return; }
      });

      const setR=(ax,r)=>{ const o={}; o[ax+'axis.range']=r; return Plotly.relayout(gd,o); };
      function zoom(ax,dir){
        const la=gd._fullLayout?.[ax+'axis'];
        const r=la?.range?.slice()||null;
        if(!r){
          const o={}; o[ax+'axis.autorange']=true;
          Plotly.relayout(gd,o).then(()=>zoom(ax,dir));
          return;
        }
        const f=(dir==='in'?0.8:1.25);
        const a=+r[0], b=+r[1];
        const c=(a+b)/2, nh=(b-a)/2*f;
        setR(ax,[c-nh,c+nh]);
      }

      pop.querySelectorAll('button[data-z]').forEach(b=>b.onclick=()=>{
        const k=b.dataset.z;
        if(k==='xin') zoom('x','in');
        if(k==='xout') zoom('x','out');
        if(k==='xreset') Plotly.relayout(gd,{'xaxis.autorange':true});
        if(k==='xscroll'){
          st.xScroll = !st.xScroll;
          st.uirev++;
          draw(chartId);
          closePopover(openZoomMenu);
          setTimeout(()=>openZoomMenu(gd,chartId),50);
        }
        if(k==='yin') zoom('y','in');
        if(k==='yout') zoom('y','out');
        if(k==='yreset') Plotly.relayout(gd,{'yaxis.autorange':true});
        if(k==='reset') Plotly.relayout(gd,{'xaxis.autorange':true,'yaxis.autorange':true});
        if(k==='pan'){
          st.dragPan = !st.dragPan;
          st.uirev++;
          draw(chartId);
          closePopover(openZoomMenu);
          setTimeout(()=>openZoomMenu(gd,chartId),50);
        }
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openZoomMenu); }, {capture:true, once:true}),0);
      openZoomMenu._el=pop;
      openZoomMenu._rePos=rePos;
    }

    // Remove data point functionality
    function markPointRemoved(chartId, rawIdx){
      if(!chartId || rawIdx==null) return;
      const st=state[chartId];
      if(!st) return;
      if(!st.removed) st.removed = new Set();
      if(st.removed.has(rawIdx)) return;
      st.removed.add(rawIdx);
      st.uirev++;
      draw(chartId);
    }

    function handleRemoveButton(gd){
      if(!gd) return;
      gd.__lastPointContext=null;
      toggleRemoveMode(gd);
    }

    function setRemoveMode(gd,on){
      if(!gd) return;
      gd.__removeMode=on;
      updateRemoveButtonState(gd);
      if(on){
        showRemovalHint(gd, 'Removal mode is active. Click the data points to remove.');
      }
    }

    function showRemovalHint(gd, msg){
      try{
        const host = gd && gd._fsOverlay ? gd._fsOverlay : document.body;
        host.querySelectorAll('.oas-removal-hint').forEach(el=>{ try{ el.remove(); }catch(_){ } });
        const el=document.createElement('div');
        el.className='oas-removal-hint';
        el.textContent=String(msg||'');
        host.appendChild(el);

        // place near the chart top-right
        const r = (gd && gd.getBoundingClientRect) ? gd.getBoundingClientRect() : {top:8,right:innerWidth-8};
        const top = Math.max(8, Math.min((r.top + 8), innerHeight - 60));
        const left = Math.max(8, Math.min((r.right - 320), innerWidth - 320));
        el.style.top = top + 'px';
        el.style.left = left + 'px';

        requestAnimationFrame(()=>{ el.classList.add('show'); });
        setTimeout(()=>{ el.classList.add('fade'); }, 2000);
        setTimeout(()=>{ try{ el.remove(); }catch(_){ } }, 2400);
      }catch(_){ }
    }

    function toggleRemoveMode(gd){
      if(!gd) return;
      setRemoveMode(gd,!gd.__removeMode);
    }

    function updateRemoveButtonState(gd){
      if(!gd) return;
      const active=!!gd.__removeMode;
      const buttons=gd.querySelectorAll('.modebar-btn');
      buttons.forEach(btn=>{
        const title=btn.getAttribute('data-title') || btn.getAttribute('title') || '';
        if(!title) return;
        if(title.toLowerCase().includes('remove')){
          btn.setAttribute('data-on', active ? '1' : '0');
        }
      });
      gd.classList.toggle('remove-mode', active);
      if(active){
        gd.setAttribute('title','Removal mode active: click a data point to delete it. Click the Remove button again to exit.');
      }else{
        gd.removeAttribute('title');
      }
    }

    function openSizeMenuAll(anchorEl){
      closePopover(openSizeMenuAll);
      const pop=document.createElement('div');
      pop.className='menu-pop vlist';
      pop.style.borderColor = frameBorder();
      pop.style.minWidth='220px';
      const fmtH=(v)=> (v==null || !Number.isFinite(v)) ? '' : String(Math.round(+v));
      const curScale = Math.round((USER_SIZE.scale||1) * 100);
      let edited=false;
      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Graph size (All charts)</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div style="font-weight:600">Scale: ${curScale}%</div>
        <button data-act="minus">Scale −</button>
        <button data-act="plus">Scale +</button>
        <div class="hdr" style="margin-top:6px">Height override (px)</div>
        <div class="row" style="align-items:center">
          <input id="sz-h" inputmode="numeric" placeholder="(default)" value="${fmtH(USER_SIZE.heightPx)}" style="width:90px;flex:0 0 90px">
          <button id="sz-apply" style="width:auto;flex:1;text-align:center">Apply</button>
          <button id="sz-clear" style="width:auto;flex:1;text-align:center">Clear</button>
        </div>
      `;
      document.body.appendChild(pop);

      function place(){
        const r=(anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.querySelector('#sz-h').addEventListener('input', ()=>{ edited=true; });

      function refresh(){
        closePopover(openSizeMenuAll);
        openSizeMenuAll(anchorEl);
      }

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='close'){ closePopover(openSizeMenuAll); return; }
        if(act==='minus'){
          USER_SIZE.scale = clampNum((USER_SIZE.scale||1) - 0.1, 0.5, 2.0);
          applyChartSizeAll();
          document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ markActiveButtons(el, el.id); }catch(_){ } });
          refresh();
        }
        if(act==='plus'){
          USER_SIZE.scale = clampNum((USER_SIZE.scale||1) + 0.1, 0.5, 2.0);
          applyChartSizeAll();
          document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ markActiveButtons(el, el.id); }catch(_){ } });
          refresh();
        }
      });
      pop.querySelector('#sz-apply').onclick=()=>{
        const v = toNum(pop.querySelector('#sz-h').value);
        const hadOverride = (USER_SIZE.heightPx!=null);
        if(edited || hadOverride){
          USER_SIZE.heightPx = (v==null) ? null : clampNum(Math.round(v), 180, 1400);
        }
        applyChartSizeAll();
        document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ markActiveButtons(el, el.id); }catch(_){ } });
        closePopover(openSizeMenuAll);
      };
      pop.querySelector('#sz-clear').onclick=()=>{
        USER_SIZE.scale = 1;
        USER_SIZE.heightPx = null;
        applyChartSizeAll();
        document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ markActiveButtons(el, el.id); }catch(_){ } });
        closePopover(openSizeMenuAll);
      };

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openSizeMenuAll); }, {capture:true, once:true}),0);
      openSizeMenuAll._el=pop;
      openSizeMenuAll._rePos=rePos;
    }

    function openLayoutMenu(anchorEl){
      closePopover(openLayoutMenu);
      const anyId = Object.keys(state)[0];
      if(!anyId) return;
      const st0=state[anyId];
      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.borderColor = frameBorder();
      pop.style.minWidth='260px';

      const curCols = grid.classList.contains('cols4') ? 4 : (grid.classList.contains('cols3') ? 3 : (grid.classList.contains('cols2') ? 2 : 1));
      const curScale = Math.round((USER_SIZE.scale||1) * 100);
      const fmtH=(v)=> (v==null || !Number.isFinite(v)) ? '' : String(Math.round(+v));
      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Layout & Size (All charts)</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div class="hdr" style="margin-top:6px">Charts per row</div>
        <div class="row" style="gap:6px;flex-wrap:wrap">
          <label class="seg"><input type="radio" name="cols" value="1" ${curCols===1?'checked':''}><span>1</span></label>
          <label class="seg"><input type="radio" name="cols" value="2" ${curCols===2?'checked':''}><span>2</span></label>
          <label class="seg"><input type="radio" name="cols" value="3" ${curCols===3?'checked':''}><span>3</span></label>
          <label class="seg"><input type="radio" name="cols" value="4" ${curCols===4?'checked':''}><span>4</span></label>
        </div>
        <div class="hdr" style="margin-top:6px">Space (grid gap px)</div>
        <div class="row" style="align-items:center">
          <input id="gap" inputmode="numeric" placeholder="Gap" value="${GRID_GAP}" style="width:90px;flex:0 0 90px">
          <button id="gap-apply" style="flex:1">Apply</button>
          <button id="gap-reset" style="flex:1">Reset</button>
        </div>
        <div class="hdr" style="margin-top:6px">Graph size</div>
        <div style="font-weight:600">Scale: ${curScale}%</div>
        <button data-act="sz-minus">Scale −</button>
        <button data-act="sz-plus">Scale +</button>
        <div class="hdr" style="margin-top:6px">Height override (px)</div>
        <div class="row" style="align-items:center">
          <input id="sz-h" inputmode="numeric" placeholder="(default)" value="${fmtH(USER_SIZE.heightPx)}" style="width:90px;flex:0 0 90px">
          <button data-act="sz-apply" style="flex:1">Apply</button>
          <button data-act="sz-reset" style="flex:1">Reset</button>
        </div>
        <div class="hdr" style="margin-top:6px">Small multiples</div>
        <label title="Split groups into small subplots"><input type="checkbox" id="tr-all" ${st0.trellisOn ? 'checked' : ''}> Trellis (small multiples)</label>
        <div class="hdr" style="margin-top:6px">X scrollbar</div>
        <label title="Adds an X-axis range slider for scrolling after zoom"><input type="checkbox" id="xs-all" ${st0.xScroll ? 'checked' : ''}> Range slider</label>
      `;
      document.body.appendChild(pop);

      function place(){
        const r=(anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('change',(e)=>{
        const t=e && e.target;
        if(!t) return;
        if(t.name==='cols'){
          const n = parseInt(t.value, 10);
          applyCols(Math.min(4, Math.max(1, n||1)));
          closePopover(openLayoutMenu);
          openLayoutMenu(anchorEl);
        }
        if(t.id==='tr-all'){
          const next = !!t.checked;
          setAllCharts((st)=>{ st.trellisOn=next; st.uirev++; });
          redrawAllCharts();
          closePopover(openLayoutMenu);
          return;
        }
        if(t.id==='xs-all'){
          const next = !!t.checked;
          setAllCharts((st)=>{ st.xScroll=next; st.uirev++; });
          redrawAllCharts();
          closePopover(openLayoutMenu);
          return;
        }
      });

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='close'){ closePopover(openLayoutMenu); return; }
        if(act==='sz-minus'){
          USER_SIZE.scale = clampNum((USER_SIZE.scale||1) - 0.1, 0.5, 2.0);
          applyChartSizeAll();
          closePopover(openLayoutMenu);
          openLayoutMenu(anchorEl);
          return;
        }
        if(act==='sz-plus'){
          USER_SIZE.scale = clampNum((USER_SIZE.scale||1) + 0.1, 0.5, 2.0);
          applyChartSizeAll();
          closePopover(openLayoutMenu);
          openLayoutMenu(anchorEl);
          return;
        }
        if(act==='sz-apply'){
          const v = toNum(pop.querySelector('#sz-h').value);
          USER_SIZE.heightPx = (v==null) ? null : clampNum(Math.round(v), 180, 1400);
          applyChartSizeAll();
          closePopover(openLayoutMenu);
          openLayoutMenu(anchorEl);
          return;
        }
        if(act==='sz-reset'){
          USER_SIZE.scale = 1;
          USER_SIZE.heightPx = null;
          applyChartSizeAll();
          closePopover(openLayoutMenu);
          openLayoutMenu(anchorEl);
          return;
        }
      });

      pop.querySelector('#gap-apply').onclick=()=>{
        const v = toNum(pop.querySelector('#gap').value);
        applyGridGap(v==null ? GRID_GAP_DEFAULT : v);
        closePopover(openLayoutMenu);
      };
      pop.querySelector('#gap-reset').onclick=()=>{
        applyGridGap(GRID_GAP_DEFAULT);
        closePopover(openLayoutMenu);
      };

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openLayoutMenu); }, {capture:true, once:true}),0);
      openLayoutMenu._el=pop;
      openLayoutMenu._rePos=rePos;
    }

    function renderHeader(){
      if(!hdr) return;
      const show = SHOW_HEADER && (REPORT_TITLE || REPORT_SUBTITLE);
      hdr.style.display = show ? '' : 'none';
      if(!show) return;

      const T = THEMES[CUR_THEME] || THEMES.light;
      const headerBg = (CUR_THEME==='dark') ? 'rgba(15,23,42,.92)' : 'rgba(255,255,255,.92)';
      const sepCol = REPORT_SEP_COLOR || ((CUR_THEME==='dark') ? '#1f2937' : '#e5e7eb');

      hdr.innerHTML = `
        <div class="oas-titlebar" style="background:${headerBg};backdrop-filter:saturate(140%) blur(6px)">
          <div class="txt">
            <div class="ttl" style="font-size:${REPORT_TITLE_SIZE}px;color:${REPORT_TITLE_COLOR || T.TXT}">${escapeHtml(REPORT_TITLE || 'Box Plot')}</div>
            ${REPORT_SUBTITLE ? `<div class="sub" style="font-size:${REPORT_SUBTITLE_SIZE}px;color:${REPORT_SUBTITLE_COLOR || T.AX}">${escapeHtml(REPORT_SUBTITLE)}</div>` : ''}
          </div>
          <div class="acts">
            <button class="icoBtn" data-act="tb-home" title="Reset all charts" aria-label="Reset all charts">${svgIcon(homeI)}</button>
            <button class="icoBtn" data-act="tb-type" title="Chart type (all charts)" aria-label="Chart type (all charts)">${svgIcon(typeI)}</button>
            <button class="icoBtn" data-act="tb-pts" title="Points • Labels • Legend (all charts)" aria-label="Points • Labels • Legend (all charts)">${svgIcon(dotsI)}</button>
            <button class="icoBtn" data-act="tb-status" title="Status table (all charts)" aria-label="Status table (all charts)">${svgIcon(tableI)}</button>
            <button class="icoBtn" data-act="tb-stats" title="Stats (all charts)" aria-label="Stats (all charts)">${svgIcon(linesI)}</button>
            <button class="icoBtn" data-act="tb-layout" title="Layout & size" aria-label="Layout & size">${svgIcon(gridI)}</button>
            <button class="icoBtn" data-act="tb-theme" title="Theme" aria-label="Theme">${svgIcon(themeI)}</button>
            <button class="icoBtn" data-act="tb-dl" title="Downloads" aria-label="Downloads">${svgIcon(downI)}</button>
            <button class="icoBtn" data-act="tb-help" title="Help" aria-label="Help">${svgIcon(helpI)}</button>
            <button class="icoBtn" data-act="tb-fs" title="Fullscreen" aria-label="Fullscreen">${svgIcon(fullI)}</button>
          </div>
        </div>
        <div class="oas-title-sep" style="background:${sepCol}"></div>
      `;

      hdr.onclick = (e)=>{
        const btn = e.target && e.target.closest ? e.target.closest('button[data-act]') : null;
        const act = btn ? btn.getAttribute('data-act') : null;
        if(!act) return;
        if(act==='tb-home') return resetAllChartsToDefaults();
        if(act==='tb-type') return openTypeMenuAll(btn);
        if(act==='tb-pts') return openPointsMenuAll(btn);
        if(act==='tb-status'){
          const anyId = Object.keys(state)[0];
          if(!anyId) return;
          const next = !state[anyId].showStatus;
          setAllCharts((st, id)=>{ st.showStatus=next; renderStatusTable(id); });
          try{ document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ markActiveButtons(el, el.id); }catch(_){ } }); }catch(_){ }
          return;
        }
        if(act==='tb-stats') return openStatsMenuAll(btn);
        if(act==='tb-layout') return openLayoutMenu(btn);
        if(act==='tb-theme'){
          openThemeMenu(btn);
          return;
        }
        if(act==='tb-dl') return openDownloadsMenuAll(btn);
        if(act==='tb-help') return openHelpMenu(btn);
        if(act==='tb-fs') return togglePageFullscreen();
      };
    }

    function escapeHtml(s){
      return String(s==null?'':s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }

    // Legend hover highlight (similar to LineTrend_v2, but supports multi-trace legendgroups)
    function legendHoverPack(gd){
      const d = (gd && Array.isArray(gd.data)) ? gd.data : [];
      if(!d.length) return null;
      const eligibleType=(tr)=>{
        const t=String((tr && tr.type) || 'scatter');
        return (t==='box' || t==='violin' || t==='bar' || t==='scatter' || t==='scattergl' || t==='histogram');
      };

      const legendIdxs=[];
      const dimIdxs=[];
      for(let i=0;i<d.length;i++){
        const tr=d[i];
        if(!tr) continue;
        if(!eligibleType(tr)) continue;
        if(tr.visible===false) continue;
        dimIdxs.push(i);
        const show = (tr.showlegend!==false) && (tr.name!=null && String(tr.name)!=='');
        if(show) legendIdxs.push(i);
      }
      if(legendIdxs.length<2 || legendIdxs.length>60) return null;
      if(dimIdxs.length<2 || dimIdxs.length>160) return null;
      return {legendIdxs, dimIdxs};
    }

    function snapshotLegendHoverStyles(gd, idxs){
      const d = (gd && Array.isArray(gd.data)) ? gd.data : [];
      const snap={ idxs: idxs.slice(), opacity: [], lineWidth: [], markerSize: [], markerLineWidth: [], markerLineColor: [] };
      const scalarNumOrNull=v=> (typeof v==='number' && Number.isFinite(v)) ? v : null;
      for(let k=0;k<idxs.length;k++){
        const i=idxs[k];
        const tr=d[i]||{};
        snap.opacity.push((typeof tr.opacity==='number' && Number.isFinite(tr.opacity)) ? tr.opacity : 1);
        snap.lineWidth.push(scalarNumOrNull(tr?.line?.width));

        const ms = tr?.marker?.size;
        snap.markerSize.push(Array.isArray(ms) ? null : scalarNumOrNull(ms));

        const mlw = tr?.marker?.line?.width;
        snap.markerLineWidth.push(Array.isArray(mlw) ? null : scalarNumOrNull(mlw));
        const mlc = tr?.marker?.line?.color;
        snap.markerLineColor.push((mlc==null) ? null : String(mlc));
      }
      return snap;
    }

    function legendTraceHighlight(gd, curveNumber){
      try{
        const pack = legendHoverPack(gd);
        if(!pack) return;
        const idxs = pack.dimIdxs;
        const idx = Number.isFinite(curveNumber) ? curveNumber : null;
        if(idx==null || !gd.data || !gd.data[idx]) return;
        if(pack.legendIdxs.indexOf(idx)===-1) return;

        const now=Date.now();
        if(gd.__legendHoverLastIdx===idx && gd.__legendHoverLastTs && (now-gd.__legendHoverLastTs)<40) return;
        gd.__legendHoverLastIdx=idx;
        gd.__legendHoverLastTs=now;

        if(gd.__legendDimActive) legendTraceReset(gd);

        const hi = (CUR_THEME==='dark') ? '#fbbf24' : '#f59e0b';
        const snap = snapshotLegendHoverStyles(gd, idxs);
        gd.__legendDimActive=true;
        gd.__legendDimSnapshot=snap;
        Plotly.restyle(gd, {opacity:0.22}, idxs);

        const tr = gd.data[idx] || {};
        const grp = (tr.legendgroup!=null && String(tr.legendgroup)!=='') ? String(tr.legendgroup) : String(tr.name||'');
        const groupIdxs=[];
        for(const i of idxs){
          const t2 = gd.data[i] || {};
          const g2 = (t2.legendgroup!=null && String(t2.legendgroup)!=='') ? String(t2.legendgroup) : String(t2.name||'');
          if(g2===grp) groupIdxs.push(i);
        }
        if(groupIdxs.length) Plotly.restyle(gd, {opacity:1}, groupIdxs);

        const t=String(tr.type||'scatter');
        const pos = snap.idxs.indexOf(idx);
        const upd={opacity:1};
        if(t==='bar' || t==='histogram'){
          upd['marker.line.width']=2.5;
          upd['marker.line.color']=hi;
        }else{
          const mode=String(tr.mode||'');
          const wantsLine = (!mode) || mode.includes('lines');
          const wantsMarkers = mode.includes('markers');
          if(wantsLine){
            const base = (pos>=0 && typeof snap.lineWidth[pos]==='number') ? snap.lineWidth[pos] : (typeof tr?.line?.width==='number' ? tr.line.width : 2);
            upd['line.width']=Math.min(10, Math.max(2.8, (base||2)+1.6));
          }
          if(wantsMarkers){
            const baseS = (pos>=0 && typeof snap.markerSize[pos]==='number') ? snap.markerSize[pos] : null;
            if(baseS!=null) upd['marker.size']=Math.min(22, Math.max(7, baseS+2));
            const baseLW = (pos>=0 && typeof snap.markerLineWidth[pos]==='number') ? snap.markerLineWidth[pos] : (typeof tr?.marker?.line?.width==='number' ? tr.marker.line.width : null);
            if(baseLW!=null) upd['marker.line.width']=Math.min(6, Math.max(2.2, baseLW+0.8));
            if(tr?.marker?.line) upd['marker.line.color']=hi;
          }
        }
        Plotly.restyle(gd, upd, [idx]);
      }catch(_){ }
    }

    function legendTraceReset(gd){
      try{
        const snap = gd && gd.__legendDimSnapshot;
        if(!gd || !gd.__legendDimActive || !snap || !Array.isArray(snap.idxs)) return;
        Plotly.restyle(gd, {
          opacity: snap.opacity,
          'line.width': snap.lineWidth,
          'marker.size': snap.markerSize,
          'marker.line.width': snap.markerLineWidth,
          'marker.line.color': snap.markerLineColor
        }, snap.idxs);
        gd.__legendDimActive=false;
        gd.__legendDimSnapshot=null;
      }catch(_){ }
    }

    function bindLegendHover(gd){
      if(!gd) return;
      
      const pack = legendHoverPack(gd);
      if(!pack) return;

      // Plotly legend items are rebuilt on redraw, so (re)bind each draw.
      const nodes = gd.querySelectorAll('.infolayer .legend .traces, .legend .traces');
      if(!nodes || !nodes.length) return;

      const d = gd.data || [];
      const legendTraceIdx = pack.legendIdxs;

      nodes.forEach((node, i)=>{
        try{
          const traceIdx = (i<legendTraceIdx.length) ? legendTraceIdx[i] : null;
          if(traceIdx==null || !d[traceIdx]){
            node.onmouseenter = null;
            node.onmouseleave = null;
            return;
          }
          node.onmouseenter = ()=>legendTraceHighlight(gd, traceIdx);
          node.onmouseleave = ()=>legendTraceReset(gd);
        }catch(e){ /* ignore */ }
      });
    }

    function safeFilename(s){
      return String(s || 'chart').replace(/<[^>]+>/g,'').trim().replace(/\s+/g,'_').replace(/[^a-zA-Z0-9._-]/g,'_');
    }

    function pdfReady(){
      return (typeof window.jspdf!=='undefined' && window.jspdf && window.jspdf.jsPDF && typeof window.html2canvas!=='undefined');
    }

    async function chartToPNGDataUrl(gd){
      // NOTE: Name kept for compatibility; used by PDF export.
      try{
        const src = await Plotly.toImage(gd, {format:'png', scale:1.2});
        return src;
      }catch(_){
        return null;
      }
    }

    function mkStatusTableDOM(gd, chartId){
      const wrap=document.createElement('div');
      wrap.style.padding='8px';
      wrap.style.background = (CUR_THEME==='dark') ? '#0b1220' : '#ffffff';
      wrap.style.color = (CUR_THEME==='dark') ? '#e5e7eb' : '#111827';
      wrap.style.width='1100px';
      const pack = getStatusRows(gd, chartId);
      const kind = pack.kind;
      const rows = pack.rows;

      if(kind==='histbins'){
        wrap.innerHTML =
          `<table class="status-table" style="min-width:0;width:100%">
            <thead>
              <tr>
                <th>${LINE_TITLE}</th>
                <th>n</th>
                <th>Bin</th>
                <th>From</th>
                <th>To</th>
                <th>Count</th>
                <th>%</th>
              </tr>
            </thead>
            <tbody>
              ${rows.map((r)=>{
                return `<tr>
                  <td>${r.ln}</td>
                  <td>${r.nAll}</td>
                  <td>${r.bin}</td>
                  <td class="kstat">${fmtN(r.lo)}</td>
                  <td class="kstat">${fmtN(r.hi)}</td>
                  <td>${r.count}</td>
                  <td>${fmtP(r.pct)}</td>
                </tr>`;
              }).join('')}
            </tbody>
          </table>`;
      }else if(kind==='agg'){
        wrap.innerHTML =
          `<table class="status-table" style="min-width:0;width:100%">
            <thead>
              <tr>
                <th>${LINE_TITLE}</th>
                <th>n</th>
                <th class="col-in">Inliers</th>
                <th class="col-in">%In</th>
                <th class="col-ext">Extremes</th>
                <th class="col-ext">%Ext</th>
                <th>Mean</th>
                <th>Std</th>
                <th>Min</th>
                <th>Q1</th>
                <th>Median</th>
                <th>Q3</th>
                <th>Max</th>
                <th>Lower fence</th>
                <th>Upper fence</th>
              </tr>
            </thead>
            <tbody>
              ${rows.map((r)=>{
                return `<tr>
                  <td>${r.ln}</td>
                  <td>${r.nAll}</td>
                  <td class="col-in">${r.nIn}</td>
                  <td class="col-in">${fmtP(r.pctIn)}</td>
                  <td class="col-ext">${r.nExt}</td>
                  <td class="col-ext">${fmtP(r.pctExt)}</td>
                  <td class="kstat">${fmtN(r.mean)}</td>
                  <td class="kstat">${fmtN(r.std)}</td>
                  <td class="kstat">${fmtN(r.min)}</td>
                  <td class="kstat">${fmtN(r.q1)}</td>
                  <td class="kstat med">${fmtN(r.med)}</td>
                  <td class="kstat">${fmtN(r.q3)}</td>
                  <td class="kstat">${fmtN(r.max)}</td>
                  <td>${fmtN(r.lf)}</td>
                  <td>${fmtN(r.uf)}</td>
                </tr>`;
              }).join('')}
            </tbody>
          </table>`;
      }else if(kind==='doterr'){
        const st=state[chartId];
        const em = st.errMode || 'std';
        const errLbl = (em==='sem') ? 'SEM' : (em==='ci95' ? '95% CI' : 'Std dev');
        wrap.innerHTML =
          `<table class="status-table" style="min-width:0;width:100%">
            <thead>
              <tr>
                <th>${DATE_TITLE}</th>
                <th>${LINE_TITLE}</th>
                <th>n</th>
                <th>Mean</th>
                <th>Std</th>
                <th>${errLbl}</th>
                <th>Min</th>
                <th>Max</th>
              </tr>
            </thead>
            <tbody>
              ${rows.map((r)=>{
                return `<tr>
                  <td>${r.d}</td>
                  <td>${r.ln}</td>
                  <td>${r.nAll}</td>
                  <td class="kstat">${fmtN(r.mean)}</td>
                  <td class="kstat">${fmtN(r.std)}</td>
                  <td class="kstat">${fmtN(r.err)}</td>
                  <td class="kstat">${fmtN(r.min)}</td>
                  <td class="kstat">${fmtN(r.max)}</td>
                </tr>`;
              }).join('')}
            </tbody>
          </table>`;
      }else{
        wrap.innerHTML =
          `<table class="status-table" style="min-width:0;width:100%">
            <thead>
              <tr>
                <th>${DATE_TITLE}</th>
                <th>${LINE_TITLE}</th>
                <th>n</th>
                <th class="col-in">Inliers</th>
                <th class="col-in">%In</th>
                <th class="col-ext">Extremes</th>
                <th class="col-ext">%Ext</th>
                <th>Min</th>
                <th>Q1</th>
                <th>Median</th>
                <th>Q3</th>
                <th>Max</th>
                <th>Lower fence</th>
                <th>Upper fence</th>
              </tr>
            </thead>
            <tbody>
              ${rows.map((r)=>{
                return `<tr>
                  <td>${r.d}</td>
                  <td>${r.ln}</td>
                  <td>${r.nAll}</td>
                  <td class="col-in">${r.nIn}</td>
                  <td class="col-in">${fmtP(r.pctIn)}</td>
                  <td class="col-ext">${r.nExt}</td>
                  <td class="col-ext">${fmtP(r.pctExt)}</td>
                  <td class="kstat">${fmtN(r.min)}</td>
                  <td class="kstat">${fmtN(r.q1)}</td>
                  <td class="kstat med">${fmtN(r.med)}</td>
                  <td class="kstat">${fmtN(r.q3)}</td>
                  <td class="kstat">${fmtN(r.max)}</td>
                  <td>${fmtN(r.lf)}</td>
                  <td>${fmtN(r.uf)}</td>
                </tr>`;
              }).join('')}
            </tbody>
          </table>`;
      }
      return wrap;
    }

    function mkDataTableDOM(gd, chartId){
      const st=state[chartId];
      const mk=decodeURIComponent(gd.getAttribute('data-measure'));
      const title = TIT[mk] || mk;

      const wrap=document.createElement('div');
      wrap.style.padding='8px';
      wrap.style.background = (CUR_THEME==='dark') ? '#0b1220' : '#ffffff';
      wrap.style.color = (CUR_THEME==='dark') ? '#e5e7eb' : '#111827';
      wrap.style.width='1100px';

      const rows=[];
      const MAX_ROWS=1500;
      for(const ln of lines){
        const S=store[mk][ln];
        if(!S) continue;
        const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
        const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
        const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
        const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;
        const f=applyFilters(bx,by,bt,bi,mk,ln,st);
        for(let i=0;i<f.Y.length;i++){
          rows.push({d:f.X[i], ln, cell:(f.T[i]||''), y:f.Y[i]});
          if(rows.length>=MAX_ROWS) break;
        }
        if(rows.length>=MAX_ROWS) break;
      }

      wrap.innerHTML = `
        <div style="font-weight:700;margin-bottom:6px">Data (first ${rows.length} rows) — ${title}</div>
        <table class="status-table" style="min-width:0;width:100%">
          <thead>
            <tr>
              <th style="text-align:left">${DATE_TITLE}</th>
              <th style="text-align:left">${LINE_TITLE}</th>
              <th style="text-align:left">Cell</th>
              <th>${title}</th>
            </tr>
          </thead>
          <tbody>
            ${rows.map((r)=>{
              return `<tr>
                <td style="text-align:left">${r.d}</td>
                <td style="text-align:left">${r.ln}</td>
                <td style="text-align:left">${String(r.cell).replace(/</g,'&lt;')}</td>
                <td>${fmtN(r.y)}</td>
              </tr>`;
            }).join('')}
          </tbody>
        </table>`;

      return wrap;
    }

    async function captureDOMToPNGDataUrl(el){
      try{
        const bg = (CUR_THEME==='dark') ? '#0b1220' : '#ffffff';
        const canvas = await window.html2canvas(el, {scale:1.5, backgroundColor:bg, useCORS:true, logging:false});
        // jsPDF PNG parser is fragile; JPEG is much more reliable.
        return canvas.toDataURL('image/jpeg', 0.88);
      }catch(_){
        return null;
      }
    }

    async function loadImageFromDataUrl(dataUrl){
      return await new Promise((resolve, reject)=>{
        try{
          const img = new Image();
          img.onload = ()=>resolve(img);
          img.onerror = ()=>reject(new Error('Image decode failed'));
          img.src = dataUrl;
        }catch(e){ reject(e); }
      });
    }

    async function toJPEGDataUrl(dataUrl, quality){
      const img = await loadImageFromDataUrl(dataUrl);
      let w = img.naturalWidth || img.width || 0;
      let h = img.naturalHeight || img.height || 0;
      if(!w || !h) throw new Error('Invalid image dimensions');

      // Downscale to keep data URLs small (prevents truncation/corruption).
      const maxSide = 1800;
      const scale = Math.min(1, maxSide / Math.max(w, h));
      const tw = Math.max(1, Math.round(w * scale));
      const th = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement('canvas');
      canvas.width = tw;
      canvas.height = th;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, tw, th);
      return { dataUrl: canvas.toDataURL('image/jpeg', quality==null ? 0.88 : quality), w:tw, h:th };
    }

    async function addImagePage(pdf, title, dataUrl){
      const margin=26;
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();

      if(title){
        pdf.setFontSize(12);
        pdf.text(String(title), margin, margin + 14);
      }
      const y0 = margin + (title ? 26 : 0);
      const maxW = pageW - margin*2;
      const maxH = pageH - y0 - margin;

      // Convert to JPEG to avoid jsPDF PNG parser issues.
      const info = await toJPEGDataUrl(dataUrl, 0.9);
      const s = Math.min(maxW / info.w, maxH / info.h);
      const w = info.w * s;
      const h = info.h * s;
      const x = margin + (maxW - w)/2;
      const y = y0 + (maxH - h)/2;
      pdf.addImage(info.dataUrl, 'JPEG', x, y, w, h, undefined, 'FAST');
    }

    async function downloadThisChartPDF(gd, chartId, title){
      if(!pdfReady()){
        alert('PDF export libraries not available. Expected: /analyticsRes/vendor/export/jspdf.umd.min.js and html2canvas.min.js');
        return;
      }
      const img = await chartToPNGDataUrl(gd);
      if(!img){ alert('Chart capture failed. Please try PNG export instead.'); return; }
      const pdf = new window.jspdf.jsPDF('p','pt','a4');
      await addImagePage(pdf, (title||'Chart'), img);
      pdf.save(safeFilename(title||'chart') + '.pdf');
    }

    async function downloadAllChartsPDF(){
      if(!pdfReady()){
        alert('PDF export libraries not available. Expected: /analyticsRes/vendor/export/jspdf.umd.min.js and html2canvas.min.js');
        return;
      }
      const els=[...document.querySelectorAll('#chart-grid .js-plotly-plot')];
      if(!els.length) return;
      const pdf = new window.jspdf.jsPDF('p','pt','a4');
      for(let i=0;i<els.length;i++){
        const gd=els[i];
        const mk=decodeURIComponent(gd.getAttribute('data-measure'));
        const title=TIT[mk] || mk;
        const img = await chartToPNGDataUrl(gd);
        if(!img) continue;
        if(i>0) pdf.addPage();
        await addImagePage(pdf, title, img);
      }
      pdf.save('all_charts_' + Date.now() + '.pdf');
    }

    async function downloadThisChartDataStatsPDF(gd, chartId, title){
      try{
        if(!pdfReady()){
          alert('PDF export libraries not available. Expected: /analyticsRes/vendor/export/jspdf.umd.min.js and html2canvas.min.js');
          return;
        }

        const pdf = new window.jspdf.jsPDF('p','pt','a4');
        const chartImg = await chartToPNGDataUrl(gd);
        if(!chartImg){ alert('Chart capture failed. Please try PNG export instead.'); return; }
        try{
          await addImagePage(pdf, (title||'Chart'), chartImg);
        }catch(e){
          throw new Error('Chart page failed: ' + (e && e.message ? e.message : e));
        }

        async function captureTemp(dom){
          dom.style.position='fixed';
          dom.style.left='8px';
          dom.style.top='8px';
          dom.style.zIndex='-1';
          dom.style.pointerEvents='none';
          document.body.appendChild(dom);
          await new Promise((r)=>setTimeout(r, 40));
          const img = await captureDOMToPNGDataUrl(dom);
          if(dom.parentNode) dom.parentNode.removeChild(dom);
          return img;
        }

        const stImg = await captureTemp(mkStatusTableDOM(gd, chartId));
        if(stImg){
          pdf.addPage();
          try{
            await addImagePage(pdf, 'Status table', stImg);
          }catch(e){
            throw new Error('Status table page failed: ' + (e && e.message ? e.message : e));
          }
        }

        pdf.save(safeFilename(title||'chart') + '_data_stats.pdf');
      }catch(err){
        console.error(err);
        alert('PDF export failed: ' + (err && err.message ? err.message : err));
      }
    }

    function buildDataCSVText(gd, chartId, title){
      const st=state[chartId];
      const mk=decodeURIComponent(gd.getAttribute('data-measure'));
      const cols = [DATE_TITLE, LINE_TITLE, 'Cell', TIT[mk] || mk];
      const out=[cols.map(c=>'"'+String(c).replace(/"/g,'""')+'"').join(',')];
      for(const ln of lines){
        const S=store[mk][ln];
        if(!S) continue;
        const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
        const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
        const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
        const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;
        const f=applyFilters(bx,by,bt,bi,mk,ln,st);
        for(let i=0;i<f.Y.length;i++){
          const row=[f.X[i], ln, f.T[i]||'', String(f.Y[i])];
          out.push(row.map(v=>'"'+String(v).replace(/"/g,'""')+'"').join(','));
        }
      }
      return out.join('\n');
    }

    function downloadDataCSV(gd, chartId, title){
      const csvText = buildDataCSVText(gd, chartId, title);
      const mk=decodeURIComponent(gd.getAttribute('data-measure'));
      const blob=new Blob([csvText],{type:'text/csv;charset=utf-8;'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download = safeFilename(title || (TIT[mk] || mk)) + '.csv';
      a.click();
    }

    function downloadDataExcel(gd, chartId, title){
      const st=state[chartId];
      const mk=decodeURIComponent(gd.getAttribute('data-measure'));
      const cols = [DATE_TITLE, LINE_TITLE, 'Cell', TIT[mk] || mk];
      const rows=[];
      for(const ln of lines){
        const S=store[mk][ln];
        if(!S) continue;
        const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
        const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
        const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
        const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;
        const f=applyFilters(bx,by,bt,bi,mk,ln,st);
        for(let i=0;i<f.Y.length;i++){
          rows.push([f.X[i], ln, f.T[i]||'', f.Y[i]]);
        }
      }

      const esc = (v)=> String(v ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
      let html = '<html><head><meta charset="utf-8"></head><body><table border="1"><tr>';
      html += cols.map(c=>`<th>${esc(c)}</th>`).join('');
      html += '</tr>';
      for(const r of rows){
        html += '<tr>' + r.map(v=>`<td>${esc(v)}</td>`).join('') + '</tr>';
      }
      html += '</table></body></html>';

      const blob = new Blob([html], {type:'application/vnd.ms-excel;charset=utf-8;'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download = safeFilename(title || (TIT[mk] || mk)) + '.xls';
      a.click();
    }

    async function copyTextToClipboard(text){
      const t = String(text || '');
      try{
        if(navigator.clipboard && navigator.clipboard.writeText){
          await navigator.clipboard.writeText(t);
          return true;
        }
      }catch(_){ }
      try{
        const ta=document.createElement('textarea');
        ta.value=t;
        ta.setAttribute('readonly','');
        ta.style.position='fixed';
        ta.style.left='-9999px';
        ta.style.top='0';
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand && document.execCommand('copy');
        document.body.removeChild(ta);
        return !!ok;
      }catch(_){
        return false;
      }
    }

    function buildHistBinRows(mk, ln, st, lo, hi, isLast){
      const S = store[mk] && store[mk][ln];
      if(!S) return [];
      const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
      const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
      const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
      const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;
      const f = applyFilters(bx,by,bt,bi,mk,ln,st);
      const out=[];
      const eps = 1e-12;
      for(let i=0;i<f.Y.length;i++){
        const y = f.Y[i];
        if(!Number.isFinite(y)) continue;
        const inBin = (y >= lo - eps) && (isLast ? (y <= hi + eps) : (y < hi - eps));
        if(!inBin) continue;
        out.push({d:f.X[i], cell:(f.T[i]||''), y});
      }
      out.sort((a,b)=> (a.y-b.y) || String(a.d).localeCompare(String(b.d)));
      return out;
    }

    function buildHistBinCSVText(mk, ln, st, bin, lo, hi, isLast){
      const rows = buildHistBinRows(mk, ln, st, lo, hi, isLast);
      const cols = [LINE_TITLE, 'Bin', 'From', 'To', DATE_TITLE, 'Cell', (TIT[mk] || mk)];
      const out=[cols.map(c=>"\""+String(c).replace(/\"/g,'\"\"')+"\"").join(',')];
      for(const r of rows){
        const row=[ln, String(bin||''), String(lo), String(hi), r.d, r.cell, String(r.y)];
        out.push(row.map(v=>"\""+String(v).replace(/\"/g,'\"\"')+"\"").join(','));
      }
      return out.join('\n');
    }

    function downloadTextAsCSV(filenameBase, csvText){
      const blob=new Blob([String(csvText||'')],{type:'text/csv;charset=utf-8;'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download = safeFilename(filenameBase || 'bin-values') + '.csv';
      a.click();
    }

    function openHistBinPopover(anchorEl, gd, chartId, ln, bin, lo, hi, count, nAll){
      closePopover(openHistBinPopover);
      if(!gd) return;
      const st = state[chartId];
      const mk = decodeURIComponent(gd.getAttribute('data-measure'));
      const bins = (Number.isFinite(+st.histBins) && +st.histBins>0) ? Math.floor(+st.histBins) : DEFAULT_HIST_BINS;
      const isLast = (+bin === +bins);

      const rows = buildHistBinRows(mk, ln, st, +lo, +hi, isLast);
      const maxShow = 250;

      let sortKey = 'y';
      let sortDir = 1;
      function cmp(a,b){
        if(sortKey === 'd') return String(a.d||'').localeCompare(String(b.d||'')) * sortDir;
        if(sortKey === 'cell') return String(a.cell||'').localeCompare(String(b.cell||'')) * sortDir;
        return ((+a.y) - (+b.y)) * sortDir;
      }

      function sortedRows(){
        const copy = rows.slice();
        copy.sort((a,b)=>{
          const v = cmp(a,b);
          if(v) return v;
          // deterministic tie-breakers
          const t1 = String(a.d||'').localeCompare(String(b.d||''));
          if(t1) return t1;
          const t2 = String(a.cell||'').localeCompare(String(b.cell||''));
          if(t2) return t2;
          return ((+a.y) - (+b.y));
        });
        return copy;
      }

      function sortArrow(key){
        if(key !== sortKey) return '';
        return sortDir > 0 ? '▲' : '▼';
      }

      function renderTbody(){
        const sr = sortedRows();
        const shown = sr.slice(0, maxShow);
        const more = Math.max(0, sr.length - shown.length);
        const tbody = pop.querySelector('tbody');
        if(tbody){
          tbody.innerHTML = shown.map(r=>`<tr><td>${escapeHtml(String(r.d||''))}</td><td>${escapeHtml(String(r.cell||''))}</td><td style="text-align:right">${escapeHtml(fmtN(r.y))}</td></tr>`).join('');
        }
        const moreEl = pop.querySelector('[data-bin-more]');
        if(moreEl){
          moreEl.style.display = more ? '' : 'none';
          moreEl.textContent = more ? `Showing first ${shown.length} of ${sr.length}. Use Download CSV for all.` : '';
        }
        // update arrows
        pop.querySelectorAll('th.sortable').forEach((th)=>{
          const k = th.getAttribute('data-sort');
          const arr = th.querySelector('.arr');
          if(arr) arr.textContent = sortArrow(k);
        });
      }

      const pop=document.createElement('div');
      pop.className='menu-pop bin-pop';
      const initialSorted = sortedRows();
      const shown0 = initialSorted.slice(0, maxShow);
      const more0 = Math.max(0, initialSorted.length - shown0.length);
      pop.innerHTML =
        `<div class="hdr hdr-top"><span class="ttl">Bin raw values</span><button class="xbtn" data-act="close" title="Close">×</button></div>`+
        `<div class="meta"><b>${escapeHtml(LINE_TITLE)}:</b> ${escapeHtml(String(ln||''))} &nbsp; <b>Bin:</b> ${escapeHtml(String(bin||''))} &nbsp; <b>Range:</b> ${escapeHtml(fmtN(+lo))} to ${escapeHtml(fmtN(+hi))} &nbsp; <b>Count:</b> ${escapeHtml(String(count||0))} / ${escapeHtml(String(nAll||0))}</div>`+
        `<div class="actions">`+
          `<button data-act="copy">Copy CSV</button>`+
          `<button data-act="dl">Download CSV</button>`+
        `</div>`+
        `<div style="max-height:360px; overflow:auto; border:1px solid #cdd0d4; border-radius:10px">`+
          `<table class="mini">`+
            `<thead><tr>`+
              `<th class="sortable" data-sort="d" title="Sort by ${escapeHtml(DATE_TITLE)}">${escapeHtml(DATE_TITLE)} <span class="arr">${sortArrow('d')}</span></th>`+
              `<th class="sortable" data-sort="cell" title="Sort by Cell">Cell <span class="arr">${sortArrow('cell')}</span></th>`+
              `<th class="sortable" data-sort="y" title="Sort by Value" style="text-align:right">${escapeHtml(TIT[mk] || mk)} <span class="arr">${sortArrow('y')}</span></th>`+
            `</tr></thead>`+
            `<tbody>`+
              `${shown0.map(r=>`<tr><td>${escapeHtml(String(r.d||''))}</td><td>${escapeHtml(String(r.cell||''))}</td><td style="text-align:right">${escapeHtml(fmtN(r.y))}</td></tr>`).join('')}`+
            `</tbody>`+
          `</table>`+
        `</div>`+
        `<div class="meta" data-bin-more style="margin-top:8px; display:${more0 ? 'block':'none'}">${more0 ? `Showing first ${shown0.length} of ${initialSorted.length}. Use Download CSV for all.` : ''}</div>`;

      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const r = (anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+8, left=Math.min(r.left, r.right - pw);
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.closest && e.target.closest('[data-act]') ? e.target.closest('[data-act]').getAttribute('data-act') : (e.target && e.target.getAttribute && e.target.getAttribute('data-act'));
        if(act==='close'){ closePopover(openHistBinPopover); return; }
        if(act==='copy'){
          const csvText = buildHistBinCSVText(mk, ln, st, bin, lo, hi, isLast);
          copyTextToClipboard(csvText);
          closePopover(openHistBinPopover);
          return;
        }
        if(act==='dl'){
          const csvText = buildHistBinCSVText(mk, ln, st, bin, lo, hi, isLast);
          const fname = `${TIT[mk] || mk} - ${ln} - bin ${bin}`;
          downloadTextAsCSV(fname, csvText);
          closePopover(openHistBinPopover);
          return;
        }

        // header sorting
        const th = e.target && e.target.closest ? e.target.closest('th.sortable') : null;
        if(th){
          const k = th.getAttribute('data-sort') || 'y';
          if(k === sortKey) sortDir = -sortDir;
          else { sortKey = k; sortDir = (k === 'y') ? 1 : 1; }
          renderTbody();
          return;
        }
      });

      // allow keyboard-ish sorting via Enter on headers
      try{
        pop.querySelectorAll('th.sortable').forEach((th)=>{ th.setAttribute('tabindex','0'); });
        pop.addEventListener('keydown',(e)=>{
          if(!e || (e.key!=='Enter' && e.key!==' ')) return;
          const th = e.target && e.target.closest ? e.target.closest('th.sortable') : null;
          if(!th) return;
          e.preventDefault();
          const k = th.getAttribute('data-sort') || 'y';
          if(k === sortKey) sortDir = -sortDir;
          else { sortKey = k; sortDir = 1; }
          renderTbody();
        });
      }catch(_){ }

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openHistBinPopover); }, {capture:true, once:true}),0);
      openHistBinPopover._el=pop;
      openHistBinPopover._rePos=rePos;
    }

    async function copyThisChartDataCSV(gd, chartId, title){
      const csvText = buildDataCSVText(gd, chartId, title);
      const ok = await copyTextToClipboard(csvText);
      if(!ok) alert('Copy to clipboard failed (browser blocked).');
    }

    function csvQuote(v){
      return '"' + String(v ?? '').replace(/"/g,'""') + '"';
    }

    function matrixToCsvText(cols, rows){
      const out=[cols.map(csvQuote).join(',')];
      for(const r of rows){
        out.push(r.map(csvQuote).join(','));
      }
      return out.join('\n');
    }

    function buildStatusTable(gd, chartId, title){
      const mk=decodeURIComponent(gd.getAttribute('data-measure'));
      const pack=getStatusRows(gd, chartId);
      const kind=pack.kind;
      const rows=pack.rows;
      const t = String(title || (TIT[mk] || mk));

      let cols;
      if(kind==='histbins') cols = ['Measure', LINE_TITLE, 'n', 'Bin', 'From', 'To', 'Count', '%'];
      else if(kind==='agg') cols = ['Measure', LINE_TITLE, 'n', 'Inliers', '%In', 'Extremes', '%Ext', 'Mean', 'Std', 'Min', 'Q1', 'Median', 'Q3', 'Max', 'Lower fence', 'Upper fence'];
      else if(kind==='doterr') cols = ['Measure', DATE_TITLE, LINE_TITLE, 'n', 'Mean', 'Std', 'Error', 'Min', 'Max'];
      else cols = ['Measure', DATE_TITLE, LINE_TITLE, 'n', 'Inliers', '%In', 'Extremes', '%Ext', 'Min', 'Q1', 'Median', 'Q3', 'Max', 'Lower fence', 'Upper fence'];

      const outRows=[];
      for(const r of rows){
        if(kind==='histbins') outRows.push([t, r.ln, r.nAll, r.bin, r.lo, r.hi, r.count, ((r.pct||0).toFixed(1) + '%')]);
        else if(kind==='agg') outRows.push([t, r.ln, r.nAll, r.nIn, ((r.pctIn||0).toFixed(1) + '%'), r.nExt, ((r.pctExt||0).toFixed(1) + '%'), r.mean, r.std, r.min, r.q1, r.med, r.q3, r.max, r.lf, r.uf]);
        else if(kind==='doterr') outRows.push([t, r.d, r.ln, r.nAll, r.mean, r.std, r.err, r.min, r.max]);
        else outRows.push([t, r.d, r.ln, r.nAll, r.nIn, ((r.pctIn||0).toFixed(1) + '%'), r.nExt, ((r.pctExt||0).toFixed(1) + '%'), r.min, r.q1, r.med, r.q3, r.max, r.lf, r.uf]);
      }
      return {kind, cols, rows: outRows, title: t};
    }

    function buildStatusCSVText(gd, chartId, title){
      const t=buildStatusTable(gd, chartId, title);
      return matrixToCsvText(t.cols, t.rows);
    }

    function downloadStatusExcel(gd, chartId, title){
      const t=buildStatusTable(gd, chartId, title);
      const esc = (v)=> String(v ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
      let html = '<html><head><meta charset="utf-8"></head><body><table border="1"><tr>';
      html += t.cols.map(c=>`<th>${esc(c)}</th>`).join('');
      html += '</tr>';
      for(const r of t.rows){
        html += '<tr>' + r.map(v=>`<td>${esc(v)}</td>`).join('') + '</tr>';
      }
      html += '</table></body></html>';
      const blob = new Blob([html], {type:'application/vnd.ms-excel;charset=utf-8;'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download = safeFilename(t.title) + '_status.xls';
      a.click();
    }

    async function copyThisChartStatusCSV(gd, chartId, title){
      const csvText = buildStatusCSVText(gd, chartId, title);
      const ok = await copyTextToClipboard(csvText);
      if(!ok) alert('Copy to clipboard failed (browser blocked).');
    }

    function downloadStatusCSV(gd, chartId, title){
      const csvText = buildStatusCSVText(gd, chartId, title);
      const t = buildStatusTable(gd, chartId, title).title;
      const blob=new Blob([csvText],{type:'text/csv;charset=utf-8;'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download = safeFilename(t) + '_status.csv';
      a.click();
    }

    function buildAllStatusTable(){
      const cols=['Schema','Measure',DATE_TITLE,LINE_TITLE,'n','Inliers','%In','Extremes','%Ext','Mean','Std','Min','Q1','Median','Q3','Max','Lower fence','Upper fence','Bin','From','To','Count','%Bin'];
      const rows=[];
      document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((gd)=>{
        const id=gd.id;
        if(!id || !state[id]) return;
        const mk=decodeURIComponent(gd.getAttribute('data-measure'));
        const title = TIT[mk] || mk;
        const pack=getStatusRows(gd, id);
        const kind=pack.kind;
        const items=pack.rows;
        for(const r of items){
          if(kind==='histbins') rows.push(['histbins', title, '', r.ln, r.nAll, '', '', '', '', '', '', '', '', '', '', '', '', '', r.bin, r.lo, r.hi, r.count, ((r.pct||0).toFixed(1)+'%')]);
          else if(kind==='agg') rows.push(['agg', title, '', r.ln, r.nAll, r.nIn, ((r.pctIn||0).toFixed(1)+'%'), r.nExt, ((r.pctExt||0).toFixed(1)+'%'), r.mean, r.std, r.min, r.q1, r.med, r.q3, r.max, r.lf, r.uf, '', '', '', '', '' ]);
          else if(kind==='doterr') rows.push(['doterr', title, r.d, r.ln, r.nAll, '', '', '', '', r.mean, r.std, r.min, '', '', '', r.max, '', '', '', '', '', '', '' ]);
          else rows.push(['box', title, r.d, r.ln, r.nAll, r.nIn, ((r.pctIn||0).toFixed(1)+'%'), r.nExt, ((r.pctExt||0).toFixed(1)+'%'), '', '', r.min, r.q1, r.med, r.q3, r.max, r.lf, r.uf, '', '', '', '', '' ]);
        }
      });
      return {cols, rows};
    }

    function buildAllStatusCSVText(){
      const t=buildAllStatusTable();
      return matrixToCsvText(t.cols, t.rows);
    }

    function downloadAllStatusExcel(){
      const t=buildAllStatusTable();
      const esc = (v)=> String(v ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
      let html = '<html><head><meta charset="utf-8"></head><body><table border="1"><tr>';
      html += t.cols.map(c=>`<th>${esc(c)}</th>`).join('');
      html += '</tr>';
      for(const r of t.rows){
        html += '<tr>' + r.map(v=>`<td>${esc(v)}</td>`).join('') + '</tr>';
      }
      html += '</table></body></html>';
      const blob = new Blob([html], {type:'application/vnd.ms-excel;charset=utf-8;'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='all_charts_status.xls';
      a.click();
    }

    async function copyAllStatusCSV(){
      const csvText = buildAllStatusCSVText();
      const ok = await copyTextToClipboard(csvText);
      if(!ok) alert('Copy to clipboard failed (browser blocked).');
    }

    function downloadAllStatusCSV(){
      const csvText = buildAllStatusCSVText();
      const blob=new Blob([csvText],{type:'text/csv;charset=utf-8;'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='all_charts_status.csv';
      a.click();
    }

    async function downloadAllPNG(){
      const els=[...document.querySelectorAll('#chart-grid .js-plotly-plot')];
      if(!els.length) return;
      const shots=await Promise.all(els.map(el=>Plotly.toImage(el,{format:'png', scale:2}).catch(()=>null)));
      const imgs=await Promise.all(shots.filter(Boolean).map(src=>new Promise((res)=>{ const im=new Image(); im.onload=()=>res(im); im.src=src; })));
      if(!imgs.length) return;

      const cols=Math.max(1, Math.min(GPR, 4));
      const cellW=900, cellH=chartHeightPx()*2;
      const rows=Math.ceil(imgs.length/cols);
      const maxPageRows=10;
      const pages=Math.ceil(rows/maxPageRows);

      for(let pgi=0;pgi<pages;pgi++){
        const startRow=pgi*maxPageRows;
        const endRow=Math.min(rows,(pgi+1)*maxPageRows);
        const rowsOnPage=endRow-startRow;
        const canvas=document.createElement('canvas');
        canvas.width=cellW*cols;
        canvas.height=cellH*rowsOnPage;
        const ctx=canvas.getContext('2d');
        ctx.fillStyle='#fff';
        ctx.fillRect(0,0,canvas.width,canvas.height);

        for(let r=0;r<rowsOnPage;r++){
          for(let c=0;c<cols;c++){
            const idx=(startRow+r)*cols+c;
            const im=imgs[idx];
            if(!im) continue;
            ctx.drawImage(im, c*cellW, r*cellH, cellW, cellH);
          }
        }
        const a=document.createElement('a');
        a.href=canvas.toDataURL('image/png');
        a.download=`all_charts_page_${pgi+1}.png`;
        a.click();
      }
    }

    // Fullscreen (ported from BoxPlot.js behavior)
    function toggleFS(gd){
      try{ closePopover(openZoomMenu); closePopover(openDownloadsMenu); closePopover(openFilterPopover); closePopover(openLegendMenu); closePopover(openStatsMenu); closePopover(openYAxisMenu); closePopover(openSizeMenu); closePopover(openTypeMenu); }catch(_){ }

      if(gd._fsOverlay){
        const parent = gd._origParent || null;
        const ph = gd._ph || null;
        if(ph && ph.parentNode){
          ph.parentNode.replaceChild(gd, ph);
          gd._ph = null;
        }else if(parent){
          parent.appendChild(gd);
        }

        const stWrap = document.getElementById('st_' + gd.id);
        if(stWrap && gd.parentNode){
          gd.parentNode.insertBefore(stWrap, gd.nextSibling);
          const sc = stWrap.querySelector('.status-scroller');
          if(sc){ sc.style.maxHeight = ''; }
        }

        gd.style.width = '100%';
        gd.style.height = chartHeightPx() + 'px';

        gd._fsOverlay.remove();
        gd._fsOverlay = null;
        if(gd._fsResize) removeEventListener('resize', gd._fsResize);

        requestAnimationFrame(()=>{
          try{ Plotly.relayout(gd, {autosize:true, width:null, height:null}); Plotly.Plots.resize(gd); }catch(_){ }
          setTimeout(()=>{ try{ Plotly.relayout(gd, {autosize:true, width:null, height:null}); Plotly.Plots.resize(gd); }catch(_){ } }, 0);
        });
        return;
      }

      gd._origParent = gd.parentNode;
      const ph = document.createElement('div');
      ph.className = 'pl-fs-ph';
      ph.style.display = 'none';
      gd._origParent.insertBefore(ph, gd);
      gd._ph = ph;

      const ov = document.createElement('div');
      ov.className = 'pl-fs-overlay';
      document.body.appendChild(ov);

      ov.appendChild(gd);
      gd._fsOverlay = ov;
      gd._prevH = (parseInt(gd.style.height, 10) || HEIGHT);

      const stWrap = document.getElementById('st_' + gd.id);
      if(stWrap){
        ov.appendChild(stWrap);
        const sc = stWrap.querySelector('.status-scroller');
        if(sc){ sc.style.maxHeight = '30vh'; }
      }

      gd._fsResize = ()=>fitFS(gd);
      addEventListener('resize', gd._fsResize);
      fitFS(gd);

      addEventListener('keydown', function esc(e){
        if(e.key === 'Escape' && gd._fsOverlay){
          toggleFS(gd);
          removeEventListener('keydown', esc);
        }
      });
    }

    function fitFS(gd){
      gd.style.width = innerWidth + 'px';
      gd.style.height = innerHeight + 'px';
      try{
        Plotly.relayout(gd, {width: innerWidth, height: innerHeight, autosize:false});
        Plotly.Plots.resize(gd);
      }catch(_){ }
    }

    function markActiveButtons(gd, chartId){
      const st=state[chartId];
      const mb=gd.querySelector('.modebar');
      if(!mb) return;
      const pmKey = isPointsModeKey(st.pointsMode) ? st.pointsMode : 'auto';
      const curCols = grid.classList.contains('cols3') ? 3 : (grid.classList.contains('cols2') ? 2 : 1);
      const filterApplied = !!filterIndicatorText(st);
      const removedApplied = !!(st.removed && st.removed.size);
      mb.querySelectorAll('.modebar-btn').forEach((b)=>{
        const t=b.getAttribute('data-title') || b.getAttribute('title') || '';
        if(/Filter/i.test(t)){
          b.setAttribute('data-kind','filter');
          b.setAttribute('data-applied', filterApplied ? '1' : '0');
        }
        if(/Remove data point/i.test(t)){
          b.setAttribute('data-kind','remove');
          b.setAttribute('data-applied', removedApplied ? '1' : '0');
        }
        if(/Stats menu/i.test(t)) b.setAttribute('data-on', (st.showMed || st.showReg) ? '1':'0');
        if(/Status/i.test(t)) b.setAttribute('data-on', st.showStatus ? '1':'0');
        if(/Pan/i.test(t)) b.setAttribute('data-on', st.dragPan ? '1':'0');
        if(/Y-axis scale/i.test(t)) b.setAttribute('data-on', (st.yScaleMode && st.yScaleMode!=='auto') ? '1':'0');
        if(/Graph size/i.test(t)) b.setAttribute('data-on', (USER_SIZE.scale!==1 || USER_SIZE.heightPx!=null) ? '1':'0');
        if(/Chart type/i.test(t)) b.setAttribute('data-on', (st.chartType && st.chartType!=='box') ? '1':'0');
        if(/Targets/i.test(t)) b.setAttribute('data-on', st.targetsOn ? '1':'0');
        if(/Points\s*.*Legend/i.test(t)){
          const on = (pmKey!=='auto' || !st.showCell || !st.showLegend || (st.legendPos && st.legendPos!=='auto')) ? '1' : '0';
          b.setAttribute('data-on', on);
        }else{
          if(/Legend/i.test(t)) b.setAttribute('data-on', (!st.showLegend || (st.legendPos && st.legendPos!=='auto')) ? '1':'0');
          if(/Points/i.test(t)) b.setAttribute('data-on', (pmKey!=='auto' || !st.showCell) ? '1':'0');
        }
        if(/Layout/i.test(t)) b.setAttribute('data-on', (GRID_GAP!==GRID_GAP_DEFAULT || curCols!==GPR || !!st.trellisOn || !!st.xScroll) ? '1':'0');
      });
    }

    // Modebar icons
    const I=(path)=>({width:1000,height:1000,path});
    const homeI=I('M500 150 L900 450 V850 H650 V600 H350 V850 H100 V450 Z');
    const themeI=I('M700 500 A200 200 0 1 1 300 500 A200 200 0 1 0 700 500 Z M500 100 A400 400 0 1 0 900 500 A250 250 0 0 1 500 100 Z');
    const linesI=I('M180 720 L420 520 L620 600 L820 300 M220 740 A30 30 0 1 0 221 740 M420 520 A30 30 0 1 0 421 520 M620 600 A30 30 0 1 0 621 600');
    const extI=I('M500 120 L860 880 H140 Z');
    const filtI=I('M200 200 H800 L600 520 V800 H400 V520 Z');
    const downI=I('M500 180 V720 M500 720 L420 640 M500 720 L580 640');
    const fullI=I('M140 180 L140 140 L380 140 L380 180 L180 180 L180 380 L140 380 Z M620 140 L860 140 L860 380 L820 380 L820 180 L620 180 Z M140 620 L180 620 L180 820 L380 820 L380 860 L140 860 Z M820 620 L860 620 L860 860 L620 860 L620 820 L820 820 Z');
    const helpI=I('M500 180 A320 320 0 1 0 500 820 A320 320 0 1 0 500 180 Z M500 460 V680 M500 340 V360');
    const zoomI=I('M420 200 A220 220 0 1 0 420 640 A220 220 0 1 0 420 200 Z M580 580 L820 820');
    const posI=I('M200 200 H800 V300 H200 Z M200 450 H350 V650 H200 Z M450 450 H800 V650 H450 Z');
    const tableI=I('M160 200 H840 V800 H160 Z M160 320 H840 M160 480 H840 M160 640 H840 M360 200 V800 M560 200 V800');
    const yScaleI=I('M220 800 H860 M220 800 V200 M220 200 L160 260 M220 200 L280 260 M420 800 V360 M420 360 L360 420 M420 360 L480 420 M620 800 V520 M620 520 L560 580 M620 520 L680 580');
    const yI=yScaleI;  // Alias for consistency with LineTrend
    const sizeI=I('M220 220 H480 V300 H300 V480 H220 Z M520 300 H700 V220 H780 V480 H700 V520 H520 Z M300 700 H220 V780 H480 V700 H300 Z M700 520 H780 V780 H520 V700 H700 Z');
    const typeI=I('M160 820 H860 V860 H160 Z M220 820 V520 H300 V820 Z M360 820 V420 H440 V820 Z M500 820 V600 H580 V820 Z M210 520 L400 380 L540 560 L760 260');
    const gridI=I('M160 160 H460 V460 H160 Z M540 160 H840 V460 H540 Z M160 540 H460 V840 H160 Z M540 540 H840 V840 H540 Z');
    const targetI=I('M200 720 H800 M200 280 H800 M180 720 L220 720 M180 280 L220 280');
    const removeI=I('M260 260 L740 740 M740 260 L260 740');
    const dotsI=I('M260 520 A60 60 0 1 0 261 520 M500 520 A60 60 0 1 0 501 520 M740 520 A60 60 0 1 0 741 520');

    // Initial report header render (icons ready here)
    renderHeader();

    const LEG_OPTS=['auto','top','bottom','left','right'];
    function openLegendMenu(gd, chartId){
      closePopover(openLegendMenu);
      const st=state[chartId];
      const curLeg = normLegendPos((st.legendPos!=null && st.legendPos!=='') ? st.legendPos : (LEG_POS || 'auto'));
      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.minWidth='220px';
      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Legend</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div class="hdr" style="margin-top:6px">Show</div>
        <div class="segrow">
          <label class="seg"><input type="radio" name="legshow" value="1" ${st.showLegend?'checked':''}><span>Yes</span></label>
          <label class="seg"><input type="radio" name="legshow" value="0" ${st.showLegend?'':'checked'}><span>No</span></label>
        </div>
        <div class="hdr" style="margin-top:6px">Position</div>
        <div class="segrow">
          <label class="seg"><input type="radio" name="legpos" value="auto" ${curLeg==='auto'?'checked':''}><span>Auto</span></label>
          <label class="seg"><input type="radio" name="legpos" value="top" ${curLeg==='top'?'checked':''}><span>Top</span></label>
          <label class="seg"><input type="radio" name="legpos" value="bottom" ${curLeg==='bottom'?'checked':''}><span>Bottom</span></label>
        </div>
        <div class="segrow">
          <label class="seg"><input type="radio" name="legpos" value="left" ${curLeg==='left'?'checked':''}><span>Left</span></label>
          <label class="seg"><input type="radio" name="legpos" value="right" ${curLeg==='right'?'checked':''}><span>Right</span></label>
        </div>
      `;
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Legend/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.closest && e.target.closest('[data-act]') ? e.target.closest('[data-act]').getAttribute('data-act') : (e.target && e.target.getAttribute && e.target.getAttribute('data-act'));
        if(act==='close'){ closePopover(openLegendMenu); return; }
      });

      pop.addEventListener('change',(e)=>{
        const t=e.target;
        if(!t || !t.name) return;
        if(t.name==='legshow'){ st.showLegend=(String(t.value||'1')==='1'); st.uirev++; draw(chartId); closePopover(openLegendMenu); return; }
        if(t.name==='legpos'){
          const v=String(t.value||'');
          st.legendPos = v ? v : null;
          st.uirev++;
          draw(chartId);
          closePopover(openLegendMenu);
          return;
        }
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openLegendMenu); }, {capture:true, once:true}),0);

      openLegendMenu._el=pop;
      openLegendMenu._rePos=rePos;
    }

    const TYPE_OPTS=[
      {k:'box', label:'Box plot'},
      {k:'violin', label:'Violin'},
      {k:'strip', label:'Strip (jitter)'},
      {k:'swarm', label:'Swarm (approx)'},
      {k:'raincloud', label:'Raincloud'},
      {k:'hist', label:'Histogram'},
      {k:'histkde', label:'Histogram + KDE Overlay (Combined)'},
      {k:'kde', label:'KDE Density (Smooth)'},
      {k:'ecdf', label:'ECDF'}
    ];

    const TYPE_DESC={
      box:`Box plot (distribution by).\nShows median, quartiles, and outliers per ${DATE_TITLE} and per ${LINE_TITLE}.`,
      violin:`Violin (distribution by).\nShows distribution shape per ${DATE_TITLE} and per ${LINE_TITLE}.`,
      strip:`Strip (jitter) (distribution by).\nShows all points per ${DATE_TITLE} with jitter to reduce overlap.`,
      swarm:`Swarm (approx) (distribution by).\nLike strip, with stronger jitter to reduce overlap.`,
      raincloud:`Raincloud (distribution by).\nViolin (distribution) plus points, per ${DATE_TITLE} and per ${LINE_TITLE}.`,
      hist:`Histogram (all data).\nCounts of values per line (ignores date categories).`,
      histkde:`Histogram + KDE (all data).\nHistogram counts (left axis) with KDE density overlay (right axis).`,
      kde:`KDE density (all data).\nSmooth distribution curve per line (ignores date categories).`,
      ecdf:`ECDF (all data).\nCumulative distribution F(x) per line (ignores date categories).`
    };
    function openTypeMenu(gd, chartId){
      closePopover(openTypeMenu);
      const st=state[chartId];
      const cur = st.chartType || 'box';
      st.chartTypeApply = 'this';
      const curBins = (Number.isFinite(st.histBins) && +st.histBins>0) ? Math.floor(+st.histBins) : DEFAULT_HIST_BINS;
      const bins = String(curBins);
      const showBins = (cur==='hist' || cur==='histkde');
      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.minWidth='260px';
      const distBy = ['box','violin','strip','swarm','raincloud'];
      const allData = ['hist','histkde','kde','ecdf'];
      const mkRadio = (o)=>{
        const tip = TYPE_DESC[o.k] ? String(TYPE_DESC[o.k]).replace(/"/g,'&quot;') : '';
        return `<label title="${tip}"><input type="radio" name="ct" value="${o.k}" ${cur===o.k?'checked':''}> ${o.label}</label>`;
      };
      pop.innerHTML =
        `<div class="hdr hdr-top"><span class="ttl">Chart type</span><button class="xbtn" data-act="close" title="Close">×</button></div>`+
        `<div class="group">`+
          `<div class="hdr" style="margin-top:6px">Distribution by</div>`+
          `<div class="row">${TYPE_OPTS.filter(o=>distBy.includes(o.k)).map(mkRadio).join('')}</div>`+
          `<div class="hdr" style="margin-top:6px">All data</div>`+
          `<div class="row">${TYPE_OPTS.filter(o=>allData.includes(o.k)).map(mkRadio).join('')}</div>`+
          (showBins
            ? (`<div class="hdr" style="margin-top:6px">Histogram bins</div>`+
               `<div style="font-size:12px; opacity:.9">Default: ${DEFAULT_HIST_BINS}. Change and click Apply.</div>`+
               `<div class="row"><input id="type-bins" type="number" min="1" step="1" value="${bins}"></div>`+
               `<div class="row"><button data-act="bins">Apply bins</button></div>`)
            : '')+
        `</div>`;
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Chart type/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('change',(e)=>{
        if(e.target && e.target.name==='ct'){
          const typ = String(e.target.value||'box');
          st.chartType = typ;
          st.uirev++;
          draw(chartId);
          closePopover(openTypeMenu);
          if(typ==='hist' || typ==='histkde') openTypeMenu(gd, chartId);
        }
      }, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='bins'){
          const inp = pop.querySelector('#type-bins');
          if(!inp) return;
          const v = inp ? String(inp.value||'').trim() : '';
          const n = v==='' ? DEFAULT_HIST_BINS : (+v);
          const nextBins = (Number.isFinite(n) && n>0) ? Math.floor(n) : DEFAULT_HIST_BINS;
          st.histBins = nextBins;
          const sep = pop.querySelector('#type-sep');
          if(sep) st.histSeparateBars = !!sep.checked;
          st.uirev++;
          draw(chartId);
          closePopover(openTypeMenu);
          return;
        }

        if(act==='close') closePopover(openTypeMenu);
      });

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openTypeMenu); }, {capture:true, once:true}),0);

      openTypeMenu._el=pop;
      openTypeMenu._rePos=rePos;
    }

    function quantiles(vals){
      const sorted = vals.slice().sort((a,b)=>a-b);
      return quantilesFromSorted(sorted);
    }

    function getStatusRows(gd, chartId){
      const st = state[chartId];
      const mk = decodeURIComponent(gd.getAttribute('data-measure'));
      const out=[];
      const chartType = st.chartType || 'box';
      const isAgg = (chartType==='kde' || chartType==='ecdf');

      if(chartType==='hist' || chartType==='histkde'){
        const bins = (Number.isFinite(+st.histBins) && +st.histBins>0) ? Math.floor(+st.histBins) : DEFAULT_HIST_BINS;
        const perLine = new Map();
        let gmin = Infinity;
        let gmax = -Infinity;

        for(const ln of lines){
          const S = store[mk] && store[mk][ln];
          if(!S) continue;
          const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
          const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
          const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
          const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;
          const f = applyFilters(bx,by,bt,bi,mk,ln,st);
          const vals = f.Y || [];
          perLine.set(ln, vals);
          for(const y of vals){
            if(y < gmin) gmin = y;
            if(y > gmax) gmax = y;
          }
        }

        if(!Number.isFinite(gmin) || !Number.isFinite(gmax) || !perLine.size){
          return {kind:'histbins', rows: [], bins, min:null, max:null};
        }

        let min = gmin;
        let max = gmax;
        if(min===max){
          const pad = (min===0) ? 1 : Math.abs(min)*0.02;
          min = min - pad;
          max = max + pad;
        }
        const width = (max - min) / bins;

        for(const ln of lines){
          const vals = perLine.get(ln) || [];
          const nAll = vals.length;
          const counts = new Array(bins).fill(0);
          if(nAll && width>0){
            for(const y of vals){
              let idx = Math.floor((y - min) / width);
              if(idx < 0) idx = 0;
              if(idx >= bins) idx = bins - 1;
              counts[idx]++;
            }
          }
          for(let i=0;i<bins;i++){
            const lo = min + i*width;
            const hi = (i===bins-1) ? max : (min + (i+1)*width);
            const c = counts[i] || 0;
            out.push({ln, nAll, bin:(i+1), lo, hi, count:c, pct: nAll ? (c*100/nAll) : 0});
          }
        }

        return {kind:'histbins', rows: out, bins, min, max};
      }

      if(isAgg){
        for(const ln of lines){
          const S = store[mk] && store[mk][ln];
          if(!S) continue;
          const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
          const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
          const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
          const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;
          const f = applyFilters(bx,by,bt,bi,mk,ln,st);
          const filtered = f.Y;

          if(!filtered.length){
            out.push({ln, nAll:0, nIn:0, pctIn:0, nExt:0, pctExt:0, mean:null, std:null, min:null, q1:null, med:null, q3:null, max:null, lf:null, uf:null});
            continue;
          }

          let s=0, ss=0;
          for(const y of filtered){ s+=y; ss+=y*y; }
          const mean = s/filtered.length;
          const varp = Math.max(0, ss/filtered.length - mean*mean);
          const std = Math.sqrt(varp);

          const statsAll = quantiles(filtered);
          const feL = statsAll.q1 - EXTREME_K * statsAll.iqr;
          const feH = statsAll.q3 + EXTREME_K * statsAll.iqr;
          const lf = (statsAll.q1!=null && statsAll.iqr!=null) ? (statsAll.q1 - MILD_K * statsAll.iqr) : null;
          const uf = (statsAll.q3!=null && statsAll.iqr!=null) ? (statsAll.q3 + MILD_K * statsAll.iqr) : null;
          let nExt=0;
          for(const y of filtered){ if(y < feL || y > feH) nExt++; }
          const nAll = filtered.length;
          const nIn = nAll - nExt;
          out.push({
            ln,
            nAll,
            nIn,
            pctIn: nAll ? (nIn*100/nAll) : 0,
            nExt,
            pctExt: nAll ? (nExt*100/nAll) : 0,
            mean,
            std,
            min: statsAll.min, q1: statsAll.q1, med: statsAll.med, q3: statsAll.q3, max: statsAll.max,
            lf, uf
          });
        }

        return {kind:'agg', rows: out};
      }

      if(chartType==='doterr'){
        const errMode = st.errMode || 'std';
        for(const d of dates){
          for(const ln of lines){
            const g = groups.get(gKey(mk, d, ln));
            if(!g || !g.ys || !g.ys.length) continue;

            const filtered=[];
            for(let i=0;i<g.ys.length;i++){
              const y=g.ys[i];
              const cell=g.cells[i] || '';
              const rawIdx = g.idx ? g.idx[i] : null;
              if(!Number.isFinite(y)) continue;
              if(st.fmin!=null && y < st.fmin) continue;
              if(st.fmax!=null && y > st.fmax) continue;
              if(st.exclude.has(rmKey(mk, ln, d, y, cell))) continue;
              if(rawIdx!=null && st.removed && st.removed.has(rawIdx)) continue;
              filtered.push(y);
            }

            if(!filtered.length){
              out.push({d, ln, nAll:0, mean:null, std:null, err:null, min:null, max:null});
              continue;
            }

            let s=0, ss=0, mn=filtered[0], mx=filtered[0];
            for(const y of filtered){ s+=y; ss+=y*y; if(y<mn) mn=y; if(y>mx) mx=y; }
            const nAll = filtered.length;
            const mean = s/nAll;
            const varp = Math.max(0, ss/nAll - mean*mean);
            const std = Math.sqrt(varp);
            const sem = std/Math.sqrt(nAll);
            const err = (errMode==='sem') ? sem : (errMode==='ci95' ? 1.96*sem : std);
            out.push({d, ln, nAll, mean, std, err, min:mn, max:mx});
          }
        }

        return {kind:'doterr', rows: out};
      }

      // Default: box-like per-date stats
      
      

      for(const d of dates){
        for(const ln of lines){
          const g = groups.get(gKey(mk, d, ln));
          if(!g || !g.ys || !g.ys.length) continue;

          const filtered=[];
          for(let i=0;i<g.ys.length;i++){
            const y=g.ys[i];
            const cell=g.cells[i] || '';
            const rawIdx = g.idx ? g.idx[i] : null;
            if(!Number.isFinite(y)) continue;
            if(st.fmin!=null && y < st.fmin) continue;
            if(st.fmax!=null && y > st.fmax) continue;
            if(st.exclude.has(rmKey(mk, ln, d, y, cell))) continue;
            if(rawIdx!=null && st.removed && st.removed.has(rawIdx)) continue;
            filtered.push(y);
          }

          if(!filtered.length){
            out.push({d, ln, nAll:0, nIn:0, pctIn:0, nExt:0, pctExt:0, min:null, q1:null, med:null, q3:null, max:null, lf:null, uf:null});
            continue;
          }

          const statsAll = quantiles(filtered);
          const feL = statsAll.q1 - EXTREME_K * statsAll.iqr;
          const feH = statsAll.q3 + EXTREME_K * statsAll.iqr;

          const nm=[];
          const ext=[];
          for(const y of filtered){
            if(y < feL || y > feH) ext.push(y);
            else nm.push(y);
          }

          const yForBox = st.includeExt ? nm.concat(ext) : nm;
          const stq = yForBox.length ? quantiles(yForBox) : quantiles(filtered);
          const lf = (stq.q1!=null && stq.iqr!=null) ? (stq.q1 - MILD_K * stq.iqr) : null;
          const uf = (stq.q3!=null && stq.iqr!=null) ? (stq.q3 + MILD_K * stq.iqr) : null;

          const nAll = nm.length + ext.length;
          const nExt = ext.length;
          const nIn = nm.length;
          out.push({
            d, ln,
            nAll,
            nIn,
            pctIn: nAll ? (nIn*100/nAll) : 0,
            nExt,
            pctExt: nAll ? (nExt*100/nAll) : 0,
            min: stq.min, q1: stq.q1, med: stq.med, q3: stq.q3, max: stq.max,
            lf, uf
          });
        }
      }
      return {kind:'box', rows: out};
    }

    function renderStatusTable(chartId){
      const gd=document.getElementById(chartId);
      if(!gd) return;
      const wrap=document.getElementById('st_'+chartId);
      if(!wrap) return;

      const mk0 = decodeURIComponent(gd.getAttribute('data-measure')||'');
      const chartTitle = (TIT && mk0 && TIT[mk0]) ? TIT[mk0] : (mk0||'');
      const ctxParts=[];
      if(REPORT_TITLE) ctxParts.push(`Card: ${REPORT_TITLE}`);
      if(chartTitle) ctxParts.push(`Chart: ${chartTitle}`);
      const ctxHtml = ctxParts.length ? `<div class="status-ctx">${escapeHtml(ctxParts.join(' · '))}</div>` : '';

      const st=state[chartId];
      if(!st.showStatus){
        wrap.style.display='none';
        wrap.innerHTML='';
        try{ Plotly.Plots.resize(gd); }catch(_){ }
        return;
      }

      const pack = getStatusRows(gd, chartId);
      const kind = pack.kind;
      const rows = pack.rows;

      wrap.style.display='block';

      function statusTopHtml(hint){
        const h = hint ? String(hint) : '';
        return (
          `<div class="status-top">`+
            `<div class="status-hint">${h ? escapeHtml(h) : ''}</div>`+
            `<button class="status-btn" data-act="st-fs" title="Fullscreen table">Fullscreen</button>`+
          `</div>`
        ) + ctxHtml;
      }

      function toggleStatusTableFS(){
        try{ closePopover(openHistBinPopover); }catch(_){ }
        if(wrap._fsOverlay){
          const ph = wrap._fsPH;
          if(ph && ph.parentNode){
            ph.parentNode.replaceChild(wrap, ph);
          }
          try{ wrap.classList.remove('fs'); }catch(_){ }
          const sc = wrap.querySelector('.status-scroller');
          if(sc) sc.style.maxHeight = '';
          const ov = wrap._fsOverlay;
          wrap._fsOverlay = null;
          wrap._fsPH = null;
          if(ov && ov.remove) ov.remove();
          return;
        }

        const parent = wrap.parentNode;
        if(!parent) return;
        const ph = document.createElement('div');
        ph.style.display='none';
        parent.insertBefore(ph, wrap);
        wrap._fsPH = ph;

        const ov = document.createElement('div');
        ov.className='pl-fs-overlay';
        ov.style.padding='0';

        const head = document.createElement('div');
        head.style.position='sticky';
        head.style.top='0';
        head.style.zIndex='10';
        head.style.display='flex';
        head.style.alignItems='center';
        head.style.justifyContent='space-between';
        head.style.gap='10px';
        head.style.padding='10px 10px';
        head.style.background='inherit';
        head.style.borderBottom='1px solid rgba(148,163,184,.35)';
        head.innerHTML = `<div><div style="font-weight:800">Status table</div>${ctxParts.length ? `<div style="opacity:.75;font-size:12px;margin-top:2px">${escapeHtml(ctxParts.join(' · '))}</div>` : ''}</div><button class="status-btn" data-act="close" title="Exit fullscreen">×</button>`;

        const body = document.createElement('div');
        body.style.padding='10px 10px 16px';

        ov.appendChild(head);
        ov.appendChild(body);
        document.body.appendChild(ov);

        body.appendChild(wrap);
        wrap._fsOverlay = ov;
        try{ wrap.classList.add('fs'); }catch(_){ }
        const sc = wrap.querySelector('.status-scroller');
        if(sc) sc.style.maxHeight = 'calc(100vh - 128px)';

        head.querySelector('button[data-act="close"]').onclick=()=>toggleStatusTableFS();
        addEventListener('keydown', function esc(e){
          if(e.key==='Escape' && wrap._fsOverlay){
            toggleStatusTableFS();
            removeEventListener('keydown', esc);
          }
        });
      }

      if(kind==='agg'){
        wrap.innerHTML =
          statusTopHtml('') +
          `<div class="status-scroller"><table class="status-table">
            <thead>
              <tr>
                <th>${LINE_TITLE}</th>
                <th>n</th>
                <th class="col-in">Inliers</th>
                <th class="col-in">%In</th>
                <th class="col-ext">Extremes</th>
                <th class="col-ext">%Ext</th>
                <th>Mean</th>
                <th>Std</th>
                <th>Min</th>
                <th>Q1</th>
                <th>Median</th>
                <th>Q3</th>
                <th>Max</th>
                <th>Lower fence</th>
                <th>Upper fence</th>
              </tr>
            </thead>
            <tbody>
              ${rows.map((r)=>{
                return `<tr>
                  <td>${r.ln}</td>
                  <td>${r.nAll}</td>
                  <td class="col-in">${r.nIn}</td>
                  <td class="col-in">${fmtP(r.pctIn)}</td>
                  <td class="col-ext">${r.nExt}</td>
                  <td class="col-ext">${fmtP(r.pctExt)}</td>
                  <td class="kstat">${fmtN(r.mean)}</td>
                  <td class="kstat">${fmtN(r.std)}</td>
                  <td class="kstat">${fmtN(r.min)}</td>
                  <td class="kstat">${fmtN(r.q1)}</td>
                  <td class="kstat med">${fmtN(r.med)}</td>
                  <td class="kstat">${fmtN(r.q3)}</td>
                  <td class="kstat">${fmtN(r.max)}</td>
                  <td>${fmtN(r.lf)}</td>
                  <td>${fmtN(r.uf)}</td>
                </tr>`;
              }).join('')}
            </tbody>
          </table></div>`;
      }else if(kind==='histbins'){
        const bins = pack.bins;
        wrap.innerHTML =
          statusTopHtml('Click a bin row to view raw values.')+
          `<div class="status-scroller"><table class="status-table">
            <thead>
              <tr>
                <th>${LINE_TITLE}</th>
                <th>n</th>
                <th>Bin</th>
                <th>From</th>
                <th>To</th>
                <th>Count</th>
                <th>%</th>
              </tr>
            </thead>
            <tbody>
              ${rows.map((r)=>{
                return `<tr class="bin-row" title="View raw values in this bin" data-ln="${escapeHtml(String(r.ln||''))}" data-bin="${escapeHtml(String(r.bin||''))}" data-lo="${escapeHtml(String(r.lo))}" data-hi="${escapeHtml(String(r.hi))}" data-count="${escapeHtml(String(r.count||0))}" data-nall="${escapeHtml(String(r.nAll||0))}" data-bins="${escapeHtml(String(bins||''))}">
                  <td>${r.ln}</td>
                  <td>${r.nAll}</td>
                  <td>${r.bin}</td>
                  <td class="kstat">${fmtN(r.lo)}</td>
                  <td class="kstat">${fmtN(r.hi)}</td>
                  <td>${r.count}</td>
                  <td>${fmtP(r.pct)}</td>
                </tr>`;
              }).join('')}
            </tbody>
          </table></div>`;

        // Click handlers: fullscreen + bin drilldown
        wrap.onclick = function(e){
          const actEl = e && e.target && e.target.closest ? e.target.closest('[data-act]') : null;
          const act = actEl ? actEl.getAttribute('data-act') : null;
          if(act==='st-fs'){ toggleStatusTableFS(); return; }
          const tr = e && e.target && e.target.closest ? e.target.closest('tr.bin-row') : null;
          if(!tr) return;
          const ln = tr.getAttribute('data-ln') || '';
          const bin = parseInt(tr.getAttribute('data-bin') || '', 10);
          const lo = parseFloat(tr.getAttribute('data-lo') || '');
          const hi = parseFloat(tr.getAttribute('data-hi') || '');
          const count = parseInt(tr.getAttribute('data-count') || '0', 10) || 0;
          const nAll = parseInt(tr.getAttribute('data-nall') || '0', 10) || 0;
          openHistBinPopover(tr, gd, chartId, ln, bin, lo, hi, count, nAll);
        };
      }else if(kind==='doterr'){
        const st=state[chartId];
        const em = st.errMode || 'std';
        const errLbl = (em==='sem') ? 'SEM' : (em==='ci95' ? '95% CI' : 'Std dev');
        wrap.innerHTML =
          statusTopHtml('') +
          `<div class="status-scroller"><table class="status-table">
            <thead>
              <tr>
                <th>${DATE_TITLE}</th>
                <th>${LINE_TITLE}</th>
                <th>n</th>
                <th>Mean</th>
                <th>Std</th>
                <th>${errLbl}</th>
                <th>Min</th>
                <th>Max</th>
              </tr>
            </thead>
            <tbody>
              ${rows.map((r)=>{
                return `<tr>
                  <td>${r.d}</td>
                  <td>${r.ln}</td>
                  <td>${r.nAll}</td>
                  <td class="kstat">${fmtN(r.mean)}</td>
                  <td class="kstat">${fmtN(r.std)}</td>
                  <td class="kstat">${fmtN(r.err)}</td>
                  <td class="kstat">${fmtN(r.min)}</td>
                  <td class="kstat">${fmtN(r.max)}</td>
                </tr>`;
              }).join('')}
            </tbody>
          </table></div>`;
      }else{
        wrap.innerHTML =
          statusTopHtml('') +
          `<div class="status-scroller"><table class="status-table">
            <thead>
              <tr>
                <th>${DATE_TITLE}</th>
                <th>${LINE_TITLE}</th>
                <th>n</th>
                <th class="col-in">Inliers</th>
                <th class="col-in">%In</th>
                <th class="col-ext">Extremes</th>
                <th class="col-ext">%Ext</th>
                <th>Min</th>
                <th>Q1</th>
                <th>Median</th>
                <th>Q3</th>
                <th>Max</th>
                <th>Lower fence</th>
                <th>Upper fence</th>
              </tr>
            </thead>
            <tbody>
              ${rows.map((r)=>{
                return `<tr>
                  <td>${r.d}</td>
                  <td>${r.ln}</td>
                  <td>${r.nAll}</td>
                  <td class="col-in">${r.nIn}</td>
                  <td class="col-in">${fmtP(r.pctIn)}</td>
                  <td class="col-ext">${r.nExt}</td>
                  <td class="col-ext">${fmtP(r.pctExt)}</td>
                  <td class="kstat">${fmtN(r.min)}</td>
                  <td class="kstat">${fmtN(r.q1)}</td>
                  <td class="kstat med">${fmtN(r.med)}</td>
                  <td class="kstat">${fmtN(r.q3)}</td>
                  <td class="kstat">${fmtN(r.max)}</td>
                  <td>${fmtN(r.lf)}</td>
                  <td>${fmtN(r.uf)}</td>
                </tr>`;
              }).join('')}
            </tbody>
          </table></div>`;
      }

      // Fullscreen button (all kinds)
      if(kind!=='histbins'){
        wrap.onclick = function(e){
          const actEl = e && e.target && e.target.closest ? e.target.closest('[data-act]') : null;
          const act = actEl ? actEl.getAttribute('data-act') : null;
          if(act==='st-fs'){ toggleStatusTableFS(); return; }
        };
      }

      try{ Plotly.Plots.resize(gd); }catch(_){ }
      if(gd._fsOverlay){ setTimeout(()=>{ try{ wrap.scrollIntoView({block:'nearest'}); }catch(_){ } }, 50); }
    }

    function cfgFor(gd, chartId, title){
      const st0 = state[chartId];
      const chartType0 = (st0 && st0.chartType) ? st0.chartType : 'box';
      const isAgg0 = (chartType0==='hist' || chartType0==='histkde' || chartType0==='kde' || chartType0==='ecdf');

      const resetBtn={
        name:'Home',
        title:'Reset to default',
        icon:homeI,
        click:(gd2)=>{
          const cid = gd2 && gd2.id ? gd2.id : chartId;
          const st=state[cid];
          st.fmin = st.fmax = null;
          st.exclude.clear();
          if(st.removed && typeof st.removed.clear==='function') st.removed.clear();
          st.includeExt=false;
          st.showMed=false;
          st.showReg=false;
          st.statsScope='group';
          st.dragPan=false;
          st.showStatus=false;
          st.yScaleMode='auto';
          st.yMin=null;
          st.yMax=null;
          st.showLegend=LEG_SHOW;
          st.legendPos=null;
          st.chartType='box';
          st.chartTypeApply='this';
          st.histBins=DEFAULT_HIST_BINS;
          st.histShowCounts=false;
          st.histSeparateBars=false;
          st.errMode='std';
          st.pointsMode = DEFAULT_POINTS_MODE;
          st.showCell = DEFAULT_SHOW_CELL;
          st.targetsOn = TARGETS_ENABLED_DEFAULT;
          st.targets = TARGETS_DEFAULT.slice();
          st.trellisOn=false;
          st.xScroll=false;
          try{ closePopover(openZoomMenu); closePopover(openDownloadsMenu); closePopover(openFilterPopover); closePopover(openLegendMenu); closePopover(openStatsMenu); closePopover(openYAxisMenu); closePopover(openSizeMenu); closePopover(openTypeMenu); }catch(_){ }
          renderStatusTable(cid);
          Plotly.relayout(gd2, {'xaxis.autorange':true,'yaxis.autorange':true,'dragmode':false});
          st.uirev++;
          draw(cid);
        }
      };
      const typeBtn={name:'Type', title:'Chart type', icon:typeI, click:(gd2)=>{ const cid = gd2 && gd2.id ? gd2.id : chartId; openTypeMenu(gd2, cid); }};
      const statusBtn={name:'Status', title:'Status table', icon:tableI, click:(gd2)=>{ const cid = gd2 && gd2.id ? gd2.id : chartId; const st=state[cid]; st.showStatus=!st.showStatus; renderStatusTable(cid); markActiveButtons(gd2, cid); }};
      const statsBtn={name:'Stats', title:'Stats menu', icon:linesI, click:(gd2)=>{ const cid = gd2 && gd2.id ? gd2.id : chartId; openStatsMenu(gd2, cid); }};
      const targetsBtn={name:'Targets', title:'Targets', icon:targetI, click:(gd2)=>{ const cid = gd2 && gd2.id ? gd2.id : chartId; openTargetsMenu(gd2, cid); }};
      const filterBtn={name:'Filter', title:'Filter', icon:filtI, click:(gd2)=>{ const cid = gd2 && gd2.id ? gd2.id : chartId; openFilterPopover(gd2, cid); }};
      const pointsBtn={name:'Points', title:'Points • Labels • Legend', icon:dotsI, click:(gd2)=>{ const cid = gd2 && gd2.id ? gd2.id : chartId; openPointsMenu(gd2, cid); }};
      const yScaleBtn={name:'YScale', title:'Y-axis scale', icon:yScaleI, click:(gd2)=>{ const cid = gd2 && gd2.id ? gd2.id : chartId; openYAxisMenu(gd2, cid); }};
      const zoomMenuBtn={name:'Zoom', title:'Zoom menu', icon:zoomI, click:(gd2)=>{ const cid = gd2 && gd2.id ? gd2.id : chartId; openZoomMenu(gd2, cid); }};
      const themeBtn={
        name:'Theme',
        title:'Theme',
        icon:themeI,
        click:(gd2)=>{ const btn = findModebarBtn(gd2, /Theme/i); openThemeMenu(btn); }
      };
      const yAxisBtn={name:'Y axis', title:'Y axis (Auto/0-based/Log/Manual)', icon:yI, click:(gd2)=>openYAxisMenu(gd2, gd2.id)};
      const zoomBtn={name:'Zoom', title:'Zoom X/Y + resets', icon:zoomI, click:(gd2)=>openZoomMenu(gd2, gd2.id)};
      const removeBtn={name:'Remove', title:'Remove data point', icon:removeI, click:(gd2)=>handleRemoveButton(gd2)};
      const dlBtn={name:'Downloads', title:'Downloads', icon:downI, click:(gd2)=>{ const cid = gd2 && gd2.id ? gd2.id : chartId; const mk=decodeURIComponent(gd2.getAttribute('data-measure')); const titleText = TIT[mk] || mk; openDownloadsMenu(gd2, cid, titleText); }};
      const fsBtn={name:'Fullscreen', title:'Fullscreen', icon:fullI, click:(gd2)=>toggleFS(gd2)};

      return {
        displayModeBar:true,
        displaylogo:false,
        responsive:true,
        scrollZoom:false,
        modeBarButtonsToRemove:[
          'zoom2d','zoomIn2d','zoomOut2d','pan2d','select2d','lasso2d','autoScale2d','resetScale2d',
          'hoverClosestCartesian','hoverCompareCartesian','toggleSpikelines','toImage'
        ],
        modeBarButtonsToAdd:[
          resetBtn,
          typeBtn,
          statusBtn,
          pointsBtn,
          filterBtn,
          removeBtn,
          statsBtn,
          yScaleBtn,
          targetsBtn,
          zoomBtn,
          themeBtn,
          dlBtn,
          fsBtn
        ]
      };
    }

    function openStatsMenu(gd, chartId){
      closePopover(openStatsMenu);
      const st=state[chartId];
      const chartType = st.chartType || 'box';
      const isAgg = (chartType==='hist' || chartType==='histkde' || chartType==='kde' || chartType==='ecdf');
      const pop=document.createElement('div');
      pop.className='menu-pop';
      pop.style.minWidth='260px';
      pop.style.borderColor = frameBorder();

      if(chartType==='doterr'){
        const em = st.errMode || 'std';
        pop.innerHTML =
          `<div class="hdr hdr-top"><span class="ttl">Stats</span><button class="xbtn" data-act="close" title="Close">×</button></div>`+
          `<div class="group">`+
            `<div class="hdr">Error bars</div>`+
            `<div class="row">`+
              `<label class="seg"><input type="radio" name="err" value="std" ${em==='std'?'checked':''}><span>Std dev</span></label>`+
              `<label class="seg"><input type="radio" name="err" value="sem" ${em==='sem'?'checked':''}><span>SEM</span></label>`+
              `<label class="seg"><input type="radio" name="err" value="ci95" ${em==='ci95'?'checked':''}><span>95% CI</span></label>`+
            `</div>`+
            `<div class="hdr" style="margin-top:6px">Regression</div>`+
            `<div class="row"><label><input type="checkbox" name="reg" ${st.showReg?'checked':''}> Regression on means</label></div>`+
          `</div>`;
      }else if(isAgg){
        pop.innerHTML =
          `<div class="hdr hdr-top"><span class="ttl">Stats</span><button class="xbtn" data-act="close" title="Close">×</button></div>`+
          `<div class="group">`+
            `<div class="row"><label><input type="checkbox" name="med" ${st.showMed?'checked':''}> Median line</label></div>`+
            `<div class="row"><label><input type="checkbox" name="mean" ${st.showReg?'checked':''}> Mean line</label></div>`+
          `</div>`;
      }else{
        const mode = st.showReg ? 'reg' : (st.showMed ? 'med' : 'none');
        const scope = st.statsScope || 'group';
        pop.innerHTML =
          `<div class="hdr hdr-top"><span class="ttl">Stats</span><button class="xbtn" data-act="close" title="Close">×</button></div>`+
          `<div class="group">`+
            `<div class="hdr">Mode</div>`+
            `<div class="row">`+
              `<label class="seg"><input type="radio" name="sm" value="none" ${mode==='none'?'checked':''}><span>None</span></label>`+
              `<label class="seg"><input type="radio" name="sm" value="med" ${mode==='med'?'checked':''}><span>Median</span></label>`+
              `<label class="seg"><input type="radio" name="sm" value="reg" ${mode==='reg'?'checked':''}><span>Regression</span></label>`+
            `</div>`+
            `<div class="hdr" style="margin-top:6px">Scope</div>`+
            `<div class="row">`+
              `<label class="seg"><input type="radio" name="scp" value="group" ${scope==='group'?'checked':''}><span>By group</span></label>`+
              `<label class="seg"><input type="radio" name="scp" value="all" ${scope==='all'?'checked':''}><span>All groups</span></label>`+
            `</div>`+
          `</div>`;
      }
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Stats menu/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='close'){ closePopover(openStatsMenu); return; }
      });

      pop.addEventListener('change',(e)=>{
        if(!e.target) return;

        if(chartType==='doterr'){
          if(e.target.name==='err'){
            st.errMode = String(e.target.value||'std');
            st.uirev++; draw(chartId);
            closePopover(openStatsMenu);
          }
          if(e.target.name==='reg'){
            st.showReg = !!e.target.checked;
            st.uirev++; draw(chartId);
            closePopover(openStatsMenu);
          }
          return;
        }

        if(isAgg){
          if(e.target.name==='med'){
            st.showMed = !!e.target.checked;
            st.uirev++; draw(chartId);
            closePopover(openStatsMenu);
          }
          if(e.target.name==='mean'){
            st.showReg = !!e.target.checked;
            st.uirev++; draw(chartId);
            closePopover(openStatsMenu);
          }
          return;
        }

        if(e.target.name==='sm'){
          const m = String(e.target.value||'none');
          st.showMed = (m==='med');
          st.showReg = (m==='reg');
          st.uirev++; draw(chartId);
          closePopover(openStatsMenu);
          return;
        }
        if(e.target.name==='scp'){
          st.statsScope = String(e.target.value||'group');
          st.uirev++; draw(chartId);
          closePopover(openStatsMenu);
          return;
        }
      }, {passive:true});

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openStatsMenu); }, {capture:true, once:true}),0);

      openStatsMenu._el=pop;
      openStatsMenu._rePos=rePos;
    }

    // NOTE: duplicate openYAxisMenu removed; use the earlier definition.

    function openSizeMenu(gd, chartId){
      closePopover(openSizeMenu);
      const pop=document.createElement('div');
      pop.className='menu-pop vlist';
      pop.style.borderColor = frameBorder();
      pop.style.minWidth='220px';

      const fmtH=(v)=> (v==null || !Number.isFinite(v)) ? '' : String(Math.round(+v));
      const curScale = Math.round((USER_SIZE.scale||1) * 100);
      const hadOverride = (USER_SIZE.heightPx!=null);

      pop.innerHTML = `
        <div class="hdr hdr-top"><span class="ttl">Graph size</span><button class="xbtn" data-act="close" title="Close">×</button></div>
        <div style="font-weight:600">Scale: ${curScale}%</div>
        <button data-act="minus">Scale −</button>
        <button data-act="plus">Scale +</button>
        <div class="hdr" style="margin-top:6px">Height override (px)</div>
        <input id="sz-h" inputmode="numeric" placeholder="(default)" value="${fmtH(USER_SIZE.heightPx)}">
        <button id="sz-apply">Apply</button>
        <button id="sz-clear">Clear</button>
      `;
      (gd._fsOverlay || document.body).appendChild(pop);

      function place(){
        const btn=findModebarBtn(gd,/Graph size/i) || gd.querySelector('.modebar');
        const r=btn ? btn.getBoundingClientRect() : {right:innerWidth-14,bottom:54};
        const pw=pop.offsetWidth, ph=pop.offsetHeight;
        let top=r.bottom+6, left=r.right - pw;
        top=Math.max(6, Math.min(top, innerHeight-ph-6));
        left=Math.max(6, Math.min(left, innerWidth - pw - 6));
        pop.style.top=top+'px';
        pop.style.left=left+'px';
      }
      place();
      const rePos=()=>place();
      addEventListener('resize', rePos);
      addEventListener('scroll', rePos, {passive:true});

      let edited=false;
      pop.querySelector('#sz-h').addEventListener('input', ()=>{ edited=true; });

      function refresh(){
        closePopover(openSizeMenu);
        openSizeMenu(gd, chartId);
      }

      pop.addEventListener('click',(e)=>{
        const act = e.target && e.target.getAttribute && e.target.getAttribute('data-act');
        if(act==='close'){ closePopover(openSizeMenu); return; }
        if(act==='minus'){
          USER_SIZE.scale = clampNum((USER_SIZE.scale||1) - 0.1, 0.5, 2.0);
          applyChartSizeAll();
          document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ markActiveButtons(el, el.id); }catch(_){ } });
          refresh();
        }
        if(act==='plus'){
          USER_SIZE.scale = clampNum((USER_SIZE.scale||1) + 0.1, 0.5, 2.0);
          applyChartSizeAll();
          document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ markActiveButtons(el, el.id); }catch(_){ } });
          refresh();
        }
      });

      pop.querySelector('#sz-apply').onclick=()=>{
        const v = toNum(pop.querySelector('#sz-h').value);
        if(edited || hadOverride){
          USER_SIZE.heightPx = (v==null) ? null : clampNum(Math.round(v), 180, 1400);
        }
        applyChartSizeAll();
        document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ markActiveButtons(el, el.id); }catch(_){ } });
        closePopover(openSizeMenu);
      };
      pop.querySelector('#sz-clear').onclick=()=>{
        USER_SIZE.scale = 1;
        USER_SIZE.heightPx = null;
        applyChartSizeAll();
        document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{ try{ markActiveButtons(el, el.id); }catch(_){ } });
        closePopover(openSizeMenu);
      };

      setTimeout(()=>document.addEventListener('mousedown', (e)=>{ if(!pop.contains(e.target)) closePopover(openSizeMenu); }, {capture:true, once:true}),0);

      openSizeMenu._el=pop;
      openSizeMenu._rePos=rePos;
    }

    // Exclude point with shift/ctrl click (stores by measure,line,x,y,cell)
    function attachExclude(gd, chartId){
      if(gd._wired) return;
      const escRE=(s)=>String(s||'').replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
      const linePrefixRe = new RegExp('^' + escRE(LINE_TITLE) + '\\s*:\\s*', 'i');
      
      gd.on('plotly_hover', (ev)=>{
        if(!ev || !ev.points || !ev.points.length) return;
        const pt=ev.points[0];
        const rawIdx = (pt && pt.customdata!=null) ? pt.customdata : pt.pointIndex;
        if(typeof rawIdx === 'number'){
          const mk=decodeURIComponent(gd.getAttribute('data-measure'));
          gd.__lastPointContext = {rawIdx, measure:mk};
        }
      });
      
      gd.on('plotly_unhover', ()=>{
        gd.__lastPointContext=null;
      });
      
      gd.on('plotly_click', (ev)=>{
        if(!ev || !ev.points || !ev.points.length) return;
        
        const pt=ev.points[0];
        const rawIdx0 = (pt && pt.customdata!=null) ? pt.customdata : pt.pointIndex;
        if(typeof rawIdx0==='number'){
          const rawIdx = rawIdx0;
          gd.__lastPointContext = {rawIdx};
        }
        
        // Remove mode: handle point removal immediately
        if(gd.__removeMode && gd.__lastPointContext){
          const chartId=gd.id;
          markPointRemoved(chartId, gd.__lastPointContext.rawIdx);
          gd.__lastPointContext=null;
          setRemoveMode(gd,false);
          return;
        }

        // Shift/Ctrl/Cmd click: exclude point
        const mod = ev.event && (ev.event.shiftKey || ev.event.ctrlKey || ev.event.metaKey);
        if(!mod) return;
        const p2=ev.points[0];
        if(typeof p2.x==='undefined' || typeof p2.y!=='number') return;
        const mk=decodeURIComponent(gd.getAttribute('data-measure'));
        const ln=String(p2.data && p2.data.name || '')
          .replace(/^Extremes\s*–\s*/,'')
          .replace(/^Median\s*–\s*/,'')
          .replace(/^Regression\s*–\s*/,'');
        const lnKey = ln.replace(linePrefixRe,'');
        const cell = p2.text || '';
        state[chartId].exclude.add(rmKey(mk, lnKey, String(p2.x), +p2.y, String(cell)));
        state[chartId].uirev++;
        draw(chartId);
      });
      gd._wired=true;
    }

    async function draw(chartId){
      const st=state[chartId];
      const gd=document.getElementById(chartId);
      const mk=decodeURIComponent(gd.getAttribute('data-measure'));
      const titleText = TIT[mk] || mk;
      const title = `<b>${titleText}</b>`;

      const chartType = st.chartType || 'box';
      const isAgg = (chartType==='hist' || chartType==='histkde' || chartType==='kde' || chartType==='ecdf');

      const chosenPos = normLegendPos(st.legendPos || LEG_POS || 'auto');
      const margin = marginsFor(chosenPos);
      const T=THEMES[CUR_THEME];

      const plotTitle = {
        text:title,
        x:0.01,
        y:0.98,
        xanchor:'left',
        yanchor:'top',
        font:{size:CHART_TITLE_SIZE, color:T.TXT}
      };

      const xaxis = isAgg ? {
        type:'linear',
        title:{text: titleText, font:{size:AXIS_TITLE_SIZE}},
        tickfont:{size:AXIS_TICK_SIZE},
        gridcolor:T.GRID,
        zeroline:false,
        automargin:true
      } : xAxisSpec();

      if(st.xScroll){
        try{ xaxis.rangeslider = {visible:true, thickness:0.08}; }catch(_){ }
      }

      const yaxis = (chartType==='ecdf') ? Object.assign({}, yAxisSpec(st, gd), {title:{text:'F(x)'}, range:[0,1]})
        : (chartType==='kde') ? Object.assign({}, yAxisSpec(st, gd), {title:{text:'Density'}})
        : (chartType==='hist' || chartType==='histkde') ? Object.assign({}, yAxisSpec(st, gd), {title:{text:'Count'}})
        : yAxisSpec(st, gd);

      const layout={
        margin,
        showlegend: st.showLegend,
        legend: Object.assign({groupclick:'togglegroup', bgcolor:'rgba(0,0,0,0)', title:{text: LINE_TITLE}, font:{size:LEGEND_FONT_SIZE}, tracegroupgap:0}, legendSpec(chosenPos)),
        boxmode:'group',
        boxgroupgap:0.30,
        boxgap:0.14,
        violinmode:'group',
        violingroupgap:0.30,
        violingap:0.14,
        barmode: (chartType==='hist' || chartType==='histkde') ? (st.histSeparateBars ? 'group' : 'overlay') : undefined,
        xaxis,
        yaxis,
        title: plotTitle,
        paper_bgcolor:T.BG,
        plot_bgcolor:T.PBG,
        font:{color:T.TXT},
        hovermode:'closest',
        hoverdistance:12,
        dragmode: st.dragPan ? 'pan' : false,
        uirevision: st.uirev,
        shapes:targetShapes(st),
        annotations:[]
      };

      // Trellis (small multiples): split by line into stacked subplots
      if(st.trellisOn && lines && lines.length>1){
        const N=lines.length;
        const gap=0.045;
        const h=(1 - gap*(N-1)) / N;
        layout.showlegend = false;
        layout.annotations = Array.isArray(layout.annotations) ? layout.annotations : [];

        for(let i=1;i<=N;i++){
          const y1 = 1 - (i-1)*(h+gap);
          const y0 = y1 - h;
          const yk = (i===1) ? 'yaxis' : ('yaxis'+i);
          const xk = (i===1) ? 'xaxis' : ('xaxis'+i);
          const xa = Object.assign({}, xaxis, {domain:[0,1], anchor:(i===1?'y':'y'+i)});
          const ya = Object.assign({}, yaxis, {domain:[y0,y1], anchor:(i===1?'x':'x'+i)});

          if(i!==N){
            xa.showticklabels=false;
            if(xa.title) xa.title = Object.assign({}, xa.title, {text:''});
          }

          layout[xk]=xa;
          layout[yk]=ya;

          layout.annotations.push({
            xref:'paper', yref:'paper', x:0.01, y:(y0+y1)/2,
            text: escapeHtml(lines[i-1]), showarrow:false,
            xanchor:'left', yanchor:'middle', align:'left',
            font:{size:12, color:T.AX}
          });
        }
      }

      // Targets
      if(st.targetsOn && Array.isArray(st.targets) && st.targets.length){
        const lineStyle = {color:TARGET_COLOR_DEFAULT, width:TARGET_WIDTH_DEFAULT, dash:TARGET_DASH_DEFAULT};
        const trellis = !!st.trellisOn && lines && lines.length>1;

        if(isAgg){
          for(const v of st.targets){
            if(!Number.isFinite(v)) continue;
            if(trellis){
              const N=lines.length;
              const gap=0.045;
              const h=(1 - gap*(N-1)) / N;
              for(let i=1;i<=N;i++){
                const y1 = 1 - (i-1)*(h+gap);
                const y0 = y1 - h;
                layout.shapes.push({type:'line', xref:(i===1?'x':'x'+i), yref:'paper', x0:v, x1:v, y0, y1, line:lineStyle});
              }
            }else{
              layout.shapes.push({type:'line', xref:'x', yref:'paper', x0:v, x1:v, y0:0, y1:1, line:lineStyle});
            }
          }
        }else{
          const x0 = dates && dates.length ? dates[0] : 0;
          const x1 = dates && dates.length ? dates[dates.length-1] : 1;
          for(const v of st.targets){
            if(!Number.isFinite(v)) continue;
            if(trellis){
              for(let i=1;i<=lines.length;i++){
                layout.shapes.push({type:'line', xref:(i===1?'x':'x'+i), yref:(i===1?'y':'y'+i), x0, x1, y0:v, y1:v, line:lineStyle});
              }
            }else{
              layout.shapes.push({type:'line', xref:'paper', yref:'y', x0:0, x1:1, y0:v, y1:v, line:lineStyle});
            }
          }
        }
      }

      if(chartType==='histkde'){
        layout.margin.r = Math.max(layout.margin.r || 0, 86);
        layout.yaxis2 = {
          title:{text:'Density', standoff:12, font:{color:T.TXT}},
          overlaying:'y',
          side:'right',
          showgrid:false,
          zeroline:false,
          ticks:'outside',
          automargin:true,
          tickformat:'.3~g',
          exponentformat:'e',
          nticks:6,
          tickfont:{color:T.TXT}
        };
      }

      // Aggregate overlays: mean/median lines for hist/histkde/kde/ecdf
      if(isAgg && (st.showMed || st.showReg)){
        for(const ln of lines){
          const S=store[mk][ln];
          if(!S) continue;
          const bx = st.includeExt ? S.nmX.concat(S.extX) : S.nmX;
          const by = st.includeExt ? S.nmY.concat(S.extY) : S.nmY;
          const bt = st.includeExt ? S.nmT.concat(S.extT) : S.nmT;
          const bi = st.includeExt ? S.nmI.concat(S.extI) : S.nmI;
          const f = applyFilters(bx,by,bt,bi,mk,ln,st);
          if(!f.Y.length) continue;
          const col=colorFor(ln);
          if(st.showMed){
            const q = quantiles(f.Y);
            if(q && Number.isFinite(q.med)){
              layout.shapes.push({type:'line', xref:'x', yref:'paper', x0:q.med, x1:q.med, y0:0, y1:1, line:{color:col, width:1.2, dash:'dot'}});
            }
          }
          if(st.showReg){
            let s=0;
            for(const y of f.Y) s+=y;
            const mean = s/f.Y.length;
            if(Number.isFinite(mean)){
              layout.shapes.push({type:'line', xref:'x', yref:'paper', x0:mean, x1:mean, y0:0, y1:1, line:{color:col, width:1.2, dash:'dash'}});
            }
          }
        }
      }

      const budget = MAX_POINTS_PER_CHART;
      const data = tracesFor(mk, st, budget);

      if(st.trellisOn && lines && lines.length>1){
        const escRE=(s)=>String(s||'').replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
        const linePrefixRe = new RegExp('^' + escRE(LINE_TITLE) + '\\s*:\\s*', 'i');
        const baseLineName=(nm)=>String(nm||'')
          .replace(/^Extremes\s*–\s*/,'')
          .replace(/^Median\s*–\s*/,'')
          .replace(/^Regression\s*–\s*/,'')
          .replace(linePrefixRe,'');

        for(const tr of data){
          const base = baseLineName(tr && tr.name);
          const idx = lines.indexOf(base);
          const ax = (idx>=0 ? (idx+1) : 1);
          tr.xaxis = (ax===1?'x':'x'+ax);
          tr.yaxis = (ax===1?'y':'y'+ax);
          tr.showlegend = false;
        }
      }

      // Legend auto-placement should be based on what will actually render.
      if(chosenPos === 'auto'){
        const legendItemCount = data.reduce((acc, tr)=> acc + ((tr && tr.showlegend!==false) ? 1 : 0), 0);
        const autoLeg = legendSpec('auto', legendItemCount);
        layout.legend = Object.assign(layout.legend || {}, autoLeg);
        const rightLegend = (autoLeg.orientation==='v' && autoLeg.x>=1);
        if(rightLegend && legendItemCount>0) layout.margin.r = Math.max(layout.margin.r || 0, 92);
      }
      await Plotly.react(gd, data, layout, cfgFor(gd, chartId, titleText));
      if(gd._fsOverlay) fitFS(gd);
      markActiveButtons(gd, chartId);
      attachExclude(gd, chartId);
      try{ bindLegendHover(gd); }catch(_){ }
      if(st.showStatus) renderStatusTable(chartId);
      // Force-fit to card width (more reliable than autosize in OAS containers).
      fitPlotToCard(gd);
      // OAS sometimes lays out narrative containers after Plotly has rendered.
      // Follow up with a couple of delayed fits to catch late width changes.
      try{
        requestAnimationFrame(()=>requestAnimationFrame(()=>fitPlotToCard(gd)));
        setTimeout(()=>fitPlotToCard(gd), 220);
      }catch(_){ }
    }

    function makeSection(mk){
      const id='m_' + Math.random().toString(36).slice(2,9);
      const sec=document.createElement('div');
      sec.className='sec';
      sec.innerHTML = `<div id="${id}" class="plot" style="width:100%;height:${chartHeightPx()}px" data-measure="${encodeURIComponent(mk)}"></div><div id="st_${id}" class="status-wrap" style="display:none"></div>`;
      grid.appendChild(sec);
      state[id]={
        includeExt:false,
        excludeExtremes:false,
        showMed:false,
        showReg:false,
        statsScope:'group',
        showStatus:false,
        dragPan:false,
        yScaleMode:'auto', yMin:null, yMax:null,
        fmin:null, fmax:null,
        exclude:new Set(),
        removed:new Set(),
        showLegend:LEG_SHOW,
        uirev:1,
        legendPos:null,
        chartType:DEFAULT_CHART_TYPE,
        chartTypeApply:'this',
        histBins:DEFAULT_HIST_BINS,
        histShowCounts:false,
        histSeparateBars:false,
        errMode:'std',
        pointsMode: isPointsModeKey(DEFAULT_POINTS_MODE) ? DEFAULT_POINTS_MODE : 'auto',
        showCell: DEFAULT_SHOW_CELL,
        minT:null, maxT:null, band:false, showTargets:false,
        trellisOn:false,
        xScroll:false
      };
      return id;
    }

    const ids = mKeys.map(makeSection);
    if(!ids.length) return;

    // Render first chart immediately, lazy-render others
    draw(ids[0]);

    const later=ids.slice(1);
    if('IntersectionObserver' in window){
      const io=new IntersectionObserver((entries)=>{
        for(const e of entries){
          if(e.isIntersecting){ draw(e.target.id); io.unobserve(e.target); }
        }
      }, {root:null, rootMargin:'200px', threshold:0});
      for(const id of later){
        const el=document.getElementById(id);
        if(el) io.observe(el);
      }
    }else{
      for(const id of later) draw(id);
    }

    // Container-driven responsive resize (sidebar/panel changes)
    if('ResizeObserver' in window){
      let rt=null;
      const ro=new ResizeObserver(()=>{
        if(rt) return;
        rt=setTimeout(()=>{
          document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{
            fitPlotToCard(el);
          });
          rt=null;
        }, 90);
      });
      document.querySelectorAll('#chart-grid .sec').forEach((sec)=>ro.observe(sec));
    }

    // Responsive resize (throttled)
    let t=null;
    addEventListener('resize', ()=>{
      if(t) return;
      t=setTimeout(()=>{
        document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>{
          fitPlotToCard(el);
        });
        t=null;
      }, 140);
    });

    // One-time delayed fit (OAS can apply final widths after scripts run)
    setTimeout(()=>{
      try{ document.querySelectorAll('#chart-grid .js-plotly-plot').forEach((el)=>fitPlotToCard(el)); }catch(_){ }
    }, 520);

  }catch(err){
    const grid=document.getElementById('chart-grid');
    if(grid) grid.innerHTML = '<div class="sec" style="color:#b91c1c;font-weight:600">Runtime error: '+(err && err.message ? err.message : err)+'</div>';
    console.error(err);
  }
})();
</script>