Prefix
<div id="box-data" style="display:none">[

Narrative
{"Site Line Design":"@1",
"Cell ID":"@2",
 "Cell Age (days)":"@3",
 "Latest Comb drop":"@4",
 "Latest Comb Res (µΩ)":"@5",
 "Latest BRSP (µΩ)":"@6",
 "BRSP-Comb Res":"@7",
 "Delta":"@8",
 "Proposed BRSP (µΩ)":"@9",
 "Estimated Base RSP (µΩ)":"@10"}

Row separator	
,

Postfix
]</div>

<!-- Scoped container to prevent CSS leaking to OAS global styles -->
<div id="sa-narrative-container">

<div id="scatter-params" style="display:none"
  data-layout="@{PV_Layout}{H}"
  data-table-rows="@{PV_TableRows}{27}"
  data-theme-default="@{PV_Theme}{light}"
  data-grid-gap="@{PV_GridGap}{6}"

  data-fill-height="@{PV_FillHeight}{1}"

  data-chart-height="@{PV_ChartHeight}{540}"
  data-table-height="@{PV_TableHeight}{500}"

  data-normal-color="@{PV_NormalColor}{#0f766e}"
  data-outlier-color="@{PV_OutlierColor}{#f97316}"
  data-trend-color="@{PV_TrendColor}{#6b7280}"
  data-ci-color="@{PV_CIColor}{#90A4AE}"
  data-ci-opacity="@{PV_CIOpacity}{0.30}"

  data-chart-title-size="@{PV_ChartTitleSize}{16}"

  data-hist-show-counts="@{PV_HistShowCounts}{1}"

  data-chart-type="@{PV_ChartType}{scatter}"

  data-enable-multi-section="@{PV_EnableMultiSection}{1}"
  data-x-col="@{PV_XCol}{}"
  data-charts-json="@{PV_ChartsJson}{[]}"
  data-tables-json="@{PV_TablesJson}{[]}"

  data-show-card-titles="@{PV_ShowCardTitles}{0}"
  data-show-plot-titles="@{PV_ShowPlotTitles}{1}"
  data-show-section-selector="@{PV_ShowSectionSelector}{1}"
  data-show-table="@{PV_ShowTable}{1}"
  data-show-chart1="@{PV_ShowChart1}{1}"
  data-show-chart2="@{PV_ShowChart2}{1}"

  data-grid-preset="@{PV_GridPreset}{}"
  data-show-settings-gear="@{PV_ShowSettingsGear}{1}"

  data-charts-per-row="@{PV_ChartsPerRow}{2}"

  data-targets="@{PV_Targets}{}"
  data-targets-enabled="@{PV_TargetsEnabled}{0}"
  data-target-color="@{PV_TargetColor}{#dc2626}"
  data-target-width="@{PV_TargetWidth}{1.5}"
  data-target-dash="@{PV_TargetDash}{dash}"

  data-show-cell="@{PV_ShowCell}{1}"
  data-cf-enabled="@{PV_CF_Enabled}{1}"
  data-axis-decimals="@{PV_AxisDecimals}{2}"
  data-hover-color="@{PV_HoverColor}{#0284c7}"
  data-hover-bg="@{PV_HoverBg}{rgba(2,132,199,0.08)}"
  data-cf-red="@{PV_CF_Red}{#fca5a5}"
  data-cf-green="@{PV_CF_Green}{#bbf7d0}"
  data-report-title="@{PV_ReportTitle}{Scatter and Histogram Analysis}"
  data-report-subtitle="@{PV_ReportSubtitle}{}"
  data-card-border-radius="@{PV_CardBorderRadius}{12}"
  data-axis-fixed-buffer="@{PV_AxisFixedBuffer}{5}"
  data-x-nticks-mult="@{PV_XNticksMult}{1}"
  data-fullscreen-font-scale="@{PV_FullscreenFontScale}{1.2}"
  data-hover-cols-1="@{PV_HoverCols1}{0,1}"
  data-hover-cols-2="@{PV_HoverCols2}{0,1}"
  data-outlier-colored="@{PV_OutlierColored}{1}"
  data-section-col="@{PV_SectionCol}{0}"
  data-chart1-x="@{PV_Chart1X}{4}"
  data-chart1-y="@{PV_Chart1Y}{5}"
  data-chart2-x="@{PV_Chart2X}{4}"
  data-chart2-y="@{PV_Chart2Y}{8}"
  data-cf-col="@{PV_CFCol}{8}"
  data-table-cols="@{PV_TableCols}{1,2,3,4,5,6,7,8,9}"
  data-report-title-border-color="@{PV_ReportTitleBorderColor}{rgba(0,0,0,0.15)}"
  data-table-filter-cols="@{PV_TableFilterCols}{all}"
  data-table-filter-default-col="@{PV_TableFilterDefaultCol}{}"
  data-table-filter-default-min="@{PV_TableFilterDefaultMin}{}"
  data-table-filter-default-max="@{PV_TableFilterDefaultMax}{}"
  data-debug="@{PV_Debug}{0}">
</div>

<!-- PV documentation is kept inline next to each parsed JS variable (search for "// PV_"). -->
<!--
  PV Parameter Reference (Reg_Hist_v2.html)

  Layout / sizing
  - PV_Layout: H | V (grid orientation)
  - PV_GridGap: 0..40 (px gap between cards)
  - PV_FillHeight: 0 | 1 (1 = fill available viewport height; internal scrolling)
  - PV_ChartHeight: number (px; used when PV_FillHeight=0)
  - PV_TableHeight: number (px; used when PV_FillHeight=0)

  Theme / colors
  - PV_Theme: light | paper | dark
  - PV_NormalColor, PV_OutlierColor, PV_TrendColor, PV_CIColor: CSS color (hex/rgb/rgba)
  - PV_CIOpacity: 0..1
  - PV_HoverColor, PV_HoverBg, PV_CF_Red, PV_CF_Green: CSS color

  Fonts
  - PV_ChartTitleSize: number (px). Axis title/tick sizes are auto-derived from this.
  - PV_FullscreenFontScale: e.g. 1.0 .. 1.6

  Behavior
  - PV_ChartType: scatter | scattergl | histogram | hist+kde | bar
  - PV_HistShowCounts: 0 | 1
  - PV_EnableMultiSection: 0 | 1
  - PV_SectionCol: integer column index (0-based into the narrative JSON keys)

  Config JSON
  - PV_ChartsJson: JSON array; default []
  - PV_TablesJson: JSON array; default []

  Visibility
  - PV_ShowCardTitles, PV_ShowPlotTitles, PV_ShowSectionSelector, PV_ShowTable, PV_ShowChart1, PV_ShowChart2: 0 | 1

  Presentation presets
  - PV_GridPreset: optional preset for Table/Charts visibility.
      - Examples: "T" (table only), "T1" (table + 1 chart), "T2" (table + 2 charts), "T12" (table + both charts)
      - Notes: "T2" behaves like "T12" (table + chart 1 + chart 2)

  Settings menu
  - PV_ShowSettingsGear: 0 | 1 (show/hide the Settings gear icon in the report titlebar)

  Grid
  - PV_ChartsPerRow: integer (1..2). Controls chart wrapping in Horizontal layout.

  Targets
  - PV_TargetsEnabled: 0 | 1
  - PV_Targets: comma-separated numbers (e.g. 10,12.5,15)
  - PV_TargetColor: CSS color
  - PV_TargetWidth: number (px)
  - PV_TargetDash: solid | dot | dash | longdash | dashdot | longdashdot

  Table formatting
  - PV_CF_Enabled: 0 | 1
  - PV_CFCol: integer column index used for conditional formatting
  - PV_AxisDecimals: integer (tick formatting)
  - PV_TableCols: comma-separated integer column indices (0-based into narrative JSON keys)
  - PV_TableRows: integer. Approx visible rows before vertical scrolling (when PV_FillHeight=0)
  - PV_TableFilterCols: columns available in the Table Filter dropdown.
      - "all" (default) or a comma-separated list of indices/names, e.g. "0,1,7" or "Line,Cell ID".
  - PV_TableFilterDefaultCol: default filter column (index or name). Filter only activates if min/max is provided.
  - PV_TableFilterDefaultMin: default "between" minimum value (optional).
  - PV_TableFilterDefaultMax: default "between" maximum value (optional).

  Debug
  - PV_Debug: 0 | 1 (console logging + PV wiring audit)
-->
<div id="sa-scatter-root" style="width:100%; height:100%;"></div>

<!-- External Libraries - Loaded from Oracle Analytics Server -->
<script src="/analyticsRes/vendor/plotly/plotly.min.js"></script>
<script src="/analyticsRes/vendor/export/xlsx.full.min.js"></script>
<script src="/analyticsRes/vendor/export/jspdf.umd.min.js"></script>
<script src="/analyticsRes/vendor/export/html2canvas.min.js"></script>
<script src="/analyticsRes/vendor/export/FileSaver.min.js"></script>
<script src="/analyticsRes/vendor/export/exceljs.min.js"></script>
<script src="/analyticsRes/vendor/export/svg2pdf.umd.min.js"></script>

<style>
/*
 * SCOPED STYLES - All CSS is scoped to #sa-narrative-container
 * to prevent leaking into OAS global header/title styles.
 */

/* Scoped box-sizing within narrative container only */
#sa-narrative-container,
#sa-narrative-container *,
#sa-narrative-container *::before,
#sa-narrative-container *::after { box-sizing: border-box; }

/* Keep our own report header separator; strip only heavy shadows */
#sa-narrative-container .sa-report-header {
  box-shadow: none !important;
  background-image: none !important;
  border-image: none !important;
}
  #sa-narrative-container #sa-scatter-root { width: 100%; height: 100%; min-height: 520px; display: flex; flex-direction: column; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
  /* Fill-height mode: constrain to available space (set via JS) so content scrolls internally */
  #sa-narrative-container.sa-fill-height #sa-scatter-root { min-height: 0; height: var(--sa-avail-h, 100vh); max-height: var(--sa-avail-h, 100vh); }
  #sa-narrative-container .sa-report-header { display: flex; justify-content: space-between; align-items: center; padding: 6px 6px; background: #ffffff; gap: 10px; box-shadow: none !important; border-bottom: 1px solid var(--sa-report-sep, rgba(0,0,0,0.15)); }
  #sa-narrative-container .sa-report-title { font-size: 18px; font-weight: 700; color: #111827; letter-spacing: -0.01em; line-height: 1.15; }
  #sa-narrative-container .sa-report-subtitle { font-size: 12px; font-weight: 500; color: #4b5563; line-height: 1.2; margin-top: 2px; }
  #sa-narrative-container .sa-report-controls { display: flex; gap: 8px; align-items: center; }
  /* Report titlebar icon buttons (LineTrend-style sizing) */
  #sa-narrative-container .sa-report-header .sa-report-controls .sa-btn{
    width: 32px;
    height: 32px;
    padding: 0;
    border-radius: 10px;
    justify-content: center;
    gap: 0;
    box-shadow: none;
  }
  #sa-narrative-container .sa-report-header .sa-report-controls .sa-btn:hover{ transform: none; }
  #sa-narrative-container .sa-report-header .sa-report-controls .sa-btn svg{ width: 17px; height: 17px; }
  #sa-narrative-container .sa-grid-wrapper { flex: 1 1 auto; min-height: 0; min-width: 0; overflow: auto; display: flex; flex-direction: column; }
  #sa-narrative-container .sa-grid-h { flex: 1 1 auto; min-height: 0; min-width: 0; height: 100%; display: grid; grid-template-columns: var(--grid-cols, minmax(380px, 1fr) 1fr 1fr); grid-auto-rows: minmax(0, 1fr); gap: var(--grid-gap, 6px); width: 100%; padding: 4px; align-content: stretch; }
  #sa-narrative-container .sa-grid-h > .sa-card { height: 100%; }
  #sa-narrative-container .sa-grid-v { display: flex; flex-direction: column; gap: var(--grid-gap, 6px); padding: 4px; width: 100%; }
  /* Fill-height + vertical layout: ensure cards expand (prevents chart collapse when table toggles) */
  #sa-narrative-container.sa-fill-height .sa-grid-v{ flex: 1 1 auto; min-height: 0; height: 100%; overflow-y: auto; overflow-x: hidden; }
  #sa-narrative-container.sa-fill-height .sa-grid-v > .sa-card{ flex: 1 1 0; min-height: 260px; }
  #sa-narrative-container .sa-section-row { display: grid; width: 100%; justify-items: stretch; align-items: stretch; grid-template-columns: var(--grid-cols, minmax(380px, 1fr) 1fr 1fr); gap: calc(var(--grid-gap, 6px) + 2px); margin-bottom: 20px; border-bottom: 0; padding-bottom: 6px; margin-bottom: 6px; }
  #sa-narrative-container .sa-section-row > .sa-card{ width:100%; }
  #sa-narrative-container .sa-section-row:last-child { border-bottom: none; }
  #sa-narrative-container .sa-section-title { grid-column: 1 / -1; font-size: 16px; font-weight: 700; color: #111827; padding: 4px 8px; background: #f9fafb; border-radius: 8px; margin-bottom: 6px; }
  #sa-narrative-container .sa-card { border-radius: 12px; border: 1px solid #e5e7eb; background: #fff; box-shadow: 0 2px 8px rgba(0,0,0,0.08); display: flex; flex-direction: column; min-height: 0; min-width: 0; position: relative; transition: box-shadow 0.25s; }
  #sa-narrative-container .sa-card:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.12); }
  #sa-narrative-container .sa-titlebar { display: flex; flex-direction: column; padding: 2px 6px; border-bottom: 1px solid rgba(0,0,0,0.06); background: white; gap: 2px; }
  #sa-narrative-container[data-theme="dark"] .sa-titlebar { border-bottom-color: rgba(255,255,255,0.10); background: #0f172a; }
  #sa-narrative-container .sa-titlebar-top { display: flex; justify-content: flex-end; align-items: center; gap: 8px; }
  #sa-narrative-container .sa-titlebar-bottom { display: flex; flex-direction: row; justify-content: flex-end; align-items: center; gap: 6px; }
  #sa-narrative-container .sa-titlebar-title { font-size: 13px; font-weight: 600; color: #1f2937; line-height: 1.4; margin-right:auto; flex:1 1 auto; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  #sa-narrative-container .sa-titlebar-r2 { font-size: 14px; font-weight: 700; color: #0284c7; letter-spacing: -0.01em; background: white; padding: 4px 8px; border-radius: 3px; }
  #sa-narrative-container .sa-modebar { display: flex; gap: 4px; align-items: center; flex-wrap: nowrap; overflow-x: auto; overflow-y: hidden; -ms-overflow-style: none; scrollbar-width: none; }
  /* Chart toolbars are tighter in LineTrend */
  #sa-narrative-container .sa-card[id^="sa-s"] .sa-modebar{ gap: 0px; }
  #sa-narrative-container .sa-modebar::-webkit-scrollbar{ width:0; height:0 }
  #sa-narrative-container .sa-btn { padding: 6px 10px; font-size: 12px; border: 1px solid #d1d5db; background: #fff; border-radius: 6px; cursor: pointer; transition: all 0.2s; white-space: nowrap; color: #374151; display: flex; align-items: center; gap: 4px; font-weight: 500; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
  #sa-narrative-container .sa-btn svg{width:16px;height:16px;display:block}
  #sa-narrative-container .sa-btn svg path{fill:none;stroke:currentColor;stroke-width:80;stroke-linecap:round;stroke-linejoin:round}
  #sa-narrative-container .sa-btn:hover { background: #f9fafb; border-color: #9ca3af; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.08); }
  #sa-narrative-container .sa-btn.active { background: #dbeafe; border-color: #0284c7; color: #0284c7; box-shadow: 0 2px 4px rgba(2,132,199,0.2); }

  /* Chart card modebar: small + borderless (LineTrend-style chartbar feel) */
  #sa-narrative-container .sa-card[id^="sa-s"] .sa-modebar .sa-btn{
    padding: 0;
    width: 26px;
    height: 26px;
    border: 0;
    border-radius: 6px;
    background: transparent;
    box-shadow: none;
    gap: 0;
    justify-content: center;
    transform: none;
  }
  #sa-narrative-container .sa-card[id^="sa-s"] .sa-modebar .sa-btn:hover{
    background: rgba(2,132,199,0.08);
    border: 0;
    box-shadow: none;
    transform: none;
  }
  #sa-narrative-container .sa-card[id^="sa-s"] .sa-modebar .sa-btn.active{
    background: rgba(2,132,199,0.16);
    border: 0;
    box-shadow: none;
  }
  #sa-narrative-container .sa-card[id^="sa-s"] .sa-modebar .sa-btn[data-kind="filter"].active{
    background: rgba(37,99,235,0.14);
    color: #2563eb;
  }
  #sa-narrative-container .sa-card[id^="sa-s"] .sa-modebar .sa-btn[data-kind="remove"].active{
    background: rgba(220,38,38,0.16);
    color: #dc2626;
  }

  /* Table header wrapping: clamp to ~4 lines */
  #sa-narrative-container .sa-thwrap{
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 5;
    line-clamp: 5;
    overflow: hidden;
    white-space: normal;
    line-height: 1.15;
    max-width: none;
    width: 100%;
    margin: 0 auto;
  }

  /* Stats panel header (BoxPlot-like: chart title + actions) */
  #sa-narrative-container .sa-stats-head{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin: 2px 0 6px; }
  #sa-narrative-container .sa-stats-head .ttl{ font-weight: 750; font-size: 13px; color: inherit; min-width: 0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  #sa-narrative-container .sa-stats-head .acts{ display:flex; align-items:center; gap:6px; }
  #sa-narrative-container .sa-stats-head .ico{ width:28px; height:28px; border-radius:10px; border:1px solid rgba(0,0,0,0.12); background:#fff; display:flex; align-items:center; justify-content:center; cursor:pointer; padding:0; }
  #sa-narrative-container[data-theme="dark"] .sa-stats-head .ico{ background:#0f172a; border-color: rgba(255,255,255,0.16); color:#e5e7eb; }
  #sa-narrative-container .sa-stats-head .ico:hover{ background: rgba(2,132,199,0.08); }
  #sa-narrative-container .sa-stats-head .ico svg{ width:16px; height:16px; }
  #sa-narrative-container .sa-sort{
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 11px;
    opacity: .7;
    pointer-events: none;
  }
  #sa-narrative-container .sa-card[id^="sa-s"] .sa-modebar .sa-btn svg{ width: 15px; height: 15px; }
  #sa-narrative-container .sa-dropdown { position: relative; display: inline-block; }
  #sa-narrative-container .sa-panel-close { position: absolute; top: 6px; right: 8px; width: 20px; height: 20px; border-radius: 50%; background: #f3f4f6; border: 1px solid #d1d5db; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; line-height: 1; color: #6b7280; z-index: 1002; }
  #sa-narrative-container .sa-panel-close:hover { background: #e5e7eb; color: #111827; }

  /* Modern popover menus (parity with BoxPlot_v2 / LineTrend_v2) */
  #sa-narrative-container .menu-pop{
    position:fixed;
    z-index:2147483646;
    background:#fff;
    border:1px solid #e5e7eb;
    border-radius:10px;
    padding:10px;
    box-shadow:0 6px 24px rgba(0,0,0,.12);
    min-width:220px;
    max-width:360px;
    font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial;
    user-select:none;
  }
  /* Settings popover: larger, scrollable, with sticky tabs/footer */
  #sa-narrative-container .menu-pop.sa-settings-pop{
    max-width: 560px;
    width: min(560px, calc(100vw - 16px));
    max-height: min(82vh, 720px);
    overflow: auto;
    overscroll-behavior: contain;
  }
  #sa-narrative-container .menu-pop.sa-settings-pop .sa-st-tabs-wrap{
    position: sticky;
    top: 0;
    z-index: 2;
    background: inherit;
    padding-bottom: 8px;
    margin-bottom: 4px;
    border-bottom: 1px solid rgba(229,231,235,.9);
  }
  #sa-narrative-container .menu-pop.sa-settings-pop .sa-st-tabs{
    display: flex;
    gap: 6px;
    flex-wrap: nowrap;
    overflow-x: auto;
    padding-bottom: 6px;
  }
  #sa-narrative-container .menu-pop.sa-settings-pop .sa-st-tabs::-webkit-scrollbar{ height: 8px; }
  #sa-narrative-container .menu-pop.sa-settings-pop .sa-st-tabs::-webkit-scrollbar-thumb{ background: rgba(148,163,184,.6); border-radius: 999px; }
  #sa-narrative-container .menu-pop.sa-settings-pop .sa-st-tabs .item{ flex: 0 0 auto; white-space: nowrap; }
  #sa-narrative-container .menu-pop.sa-settings-pop .sa-st-tabs .item.active{
    background:#dbeafe;
    border-color:#0284c7;
    color:#075985;
    font-weight:700;
  }
  #sa-narrative-container .menu-pop.sa-settings-pop .sa-st-footer{
    position: sticky;
    bottom: 0;
    z-index: 2;
    background: inherit;
    padding-top: 10px;
    margin-top: 10px;
    border-top: 1px solid rgba(229,231,235,.9);
  }
  #sa-narrative-container[data-theme="dark"] .menu-pop.sa-settings-pop .sa-st-tabs-wrap{ border-bottom-color: rgba(51,65,85,.95); }
  #sa-narrative-container[data-theme="dark"] .menu-pop.sa-settings-pop .sa-st-footer{ border-top-color: rgba(51,65,85,.95); }
  #sa-narrative-container .menu-pop, #sa-narrative-container .menu-pop *{ box-sizing:border-box }
  #sa-narrative-container .menu-pop .hdr{font-weight:700;margin-bottom:6px;width:100%}
  #sa-narrative-container .menu-pop .hdr.hdr-top{ display:flex; align-items:center; justify-content:space-between; gap:8px }
  #sa-narrative-container .menu-pop .hdr.hdr-top .ttl{ flex:1; min-width:0 }
  #sa-narrative-container .menu-pop .xbtn{ width:22px; height:22px; line-height:20px; padding:0; border-radius:999px; text-align:center; font-weight:800; display:inline-flex; align-items:center; justify-content:center; border:1px solid #e5e7eb; background:#fff; cursor:pointer }
  #sa-narrative-container .menu-pop .xbtn:hover{ background:#f3f4f6 }
  #sa-narrative-container .menu-pop .row{ display:flex; flex-wrap:wrap; gap:6px; align-items:center }
  #sa-narrative-container .menu-pop.vlist{ display:flex; flex-direction:column; align-items:stretch; gap:6px; flex-wrap:nowrap }
  #sa-narrative-container .menu-pop button{ padding:6px 10px; border:1px solid #cdd0d4; border-radius:8px; background:#fff; cursor:pointer; text-align:left }
  #sa-narrative-container .menu-pop button:hover{ background:#f3f4f6 }
  #sa-narrative-container .menu-pop button:disabled{ opacity:.5; cursor:not-allowed }
  #sa-narrative-container .menu-pop .sep{ height:1px; background:#e5e7eb; opacity:.9; margin:6px 0 }
  #sa-narrative-container .menu-pop label.seg{display:inline-flex;align-items:center;gap:0}
  #sa-narrative-container .menu-pop label.seg input{position:absolute;opacity:0;pointer-events:none}
  #sa-narrative-container .menu-pop label.seg span{display:inline-block;padding:6px 10px;border:1px solid #cdd0d4;border-radius:999px;background:#fff;cursor:pointer;white-space:nowrap}
  #sa-narrative-container .menu-pop label.seg span:hover{background:#f3f4f6}
  #sa-narrative-container .menu-pop label.seg input:checked + span{background:#e5e7eb;border-color:#9ca3af;font-weight:700}
  #sa-narrative-container .menu-pop select,
  #sa-narrative-container .menu-pop input[type="text"]{
    width: 100%;
    padding: 6px 8px;
    border: 1px solid #cdd0d4;
    border-radius: 8px;
    font: inherit;
    color: inherit;
    background: #fff;
  }
  #sa-narrative-container[data-theme="dark"] .menu-pop{ background:#0f172a; border-color:#2b3447; color:#e5e7eb }
  #sa-narrative-container[data-theme="dark"] .menu-pop button{ border-color:#394357; color:#e5e7eb; background:#0f172a }
  #sa-narrative-container[data-theme="dark"] .menu-pop button:hover{ background:#1f2937 }
  #sa-narrative-container[data-theme="dark"] .menu-pop .xbtn{ border-color:#394357; color:#e5e7eb; background:#0f172a }
  #sa-narrative-container[data-theme="dark"] .menu-pop .xbtn:hover{ background:#1f2937 }
  #sa-narrative-container[data-theme="dark"] .menu-pop .sep{ background:#334155 }
  #sa-narrative-container[data-theme="dark"] .menu-pop label.seg span{background:#0f172a;border-color:#334155;color:#e5e7eb}
  #sa-narrative-container[data-theme="dark"] .menu-pop label.seg span:hover{background:#1f2937}
  #sa-narrative-container[data-theme="dark"] .menu-pop label.seg input:checked + span{background:#1f2937;border-color:#475569}
  #sa-narrative-container[data-theme="dark"] .menu-pop select,
  #sa-narrative-container[data-theme="dark"] .menu-pop input[type="text"]{
    background: #0f172a;
    border-color: #394357;
  }
  #sa-narrative-container .sa-filter-dialog { position: absolute; display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 1px solid #d1d5db; border-radius: 10px; padding: 20px; z-index: 2000; box-shadow: 0 10px 40px rgba(0,0,0,0.3); min-width: 360px; display: none; }
  #sa-narrative-container .sa-filter-dialog.show { display: block; }
  #sa-narrative-container .sa-filter-title { font-size: 14px; font-weight: 700; margin-bottom: 12px; color: #111827; }
  #sa-narrative-container .sa-filter-group { margin-bottom: 14px; }
  #sa-narrative-container .sa-filter-label { display: block; font-size: 11px; font-weight: 600; margin-bottom: 6px; color: #374151; }
  #sa-narrative-container .sa-filter-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  #sa-narrative-container input[type="number"] { width: 100%; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 11px; }
  #sa-narrative-container .sa-filter-checkbox { display: flex; align-items: center; gap: 8px; margin-top: 8px; }
  #sa-narrative-container .sa-filter-buttons { display: flex; gap: 8px; margin-top: 14px; }
  #sa-narrative-container .sa-filter-buttons button { flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #d1d5db; cursor: pointer; font-size: 11px; font-weight: 600; }
  #sa-narrative-container .sa-filter-buttons .apply { background: #0284c7; color: white; border-color: #0284c7; }
  #sa-narrative-container .sa-filter-buttons .clear { background: #f3f4f6; color: #374151; }
  #sa-narrative-container .sa-filter-overlay { position: absolute; display: none; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.3); z-index: 1999; display: none; }
  #sa-narrative-container .sa-filter-overlay.show { display: block; }
  #sa-narrative-container .sa-inner { flex: 1; position: relative; min-height: 0; padding: 4px; overflow: hidden; background: white; }

  /* Table filter summary (small text above table) */
  #sa-narrative-container .sa-table-filter-summary{
    display:none;
    font-size: 11px;
    font-weight: 600;
    color: #6b7280;
    padding: 4px 6px 0;
  }
  #sa-narrative-container[data-theme="dark"] .sa-table-filter-summary{ color: #94a3b8; }

  /* Chart Statistics panel (shown below the chart like BoxPlot) */
  #sa-narrative-container .sa-chart-stats{
    display:none;
    padding: 10px 8px;
    border-top: 1px solid rgba(0,0,0,0.08);
    background: rgba(255,255,255,0.98);
    color: inherit;
    max-height: 46%;
    overflow: auto;
  }
  #sa-narrative-container[data-theme="dark"] .sa-chart-stats{
    border-top-color: rgba(255,255,255,0.10);
    background: rgba(11,18,32,0.92);
  }
  #sa-narrative-container .plotly-graph-div { width: 100% !important; height: 100% !important; }
    #sa-narrative-container #sa-table-wrap,
    #sa-narrative-container .sa-table-wrap { display: flex; flex-direction: column; overflow: hidden; flex: 0 0 auto; min-height: 0; }
    /* Fill-height: table height is still capped by PV_TableRows (JS sets max-height + scroll). */
    #sa-narrative-container.sa-fill-height #sa-table-wrap{ flex: 0 0 auto !important; height: auto !important; }
  #sa-narrative-container #sa-table-wrap,
  #sa-narrative-container .sa-table-wrap { overflow-y: auto !important; overflow-x: auto !important; scrollbar-width: thin; scrollbar-color: #94a3b8 #e2e8f0; }
  /* Make horizontal scrollbars visible (avoid being clipped at the very bottom) */
  #sa-narrative-container #sa-table-wrap,
  #sa-narrative-container .sa-table-wrap{ padding-bottom: 12px; scrollbar-gutter: stable both-edges; overscroll-behavior: contain; }
  #sa-narrative-container #sa-table-wrap::-webkit-scrollbar { width: 12px; height: 10px; }
  #sa-narrative-container #sa-table-wrap::-webkit-scrollbar-track { background: #e2e8f0; border-radius: 4px; margin: 2px; }
  #sa-narrative-container #sa-table-wrap::-webkit-scrollbar-thumb { background: #64748b; border-radius: 4px; }
  #sa-narrative-container #sa-table-wrap::-webkit-scrollbar-thumb:hover { background: #475569; }
  /* Tables: content-based column widths (no forced equal widths) */
  #sa-narrative-container #sa-table,
  #sa-narrative-container table[id^="sa-table-"],
  #sa-narrative-container table[id^="sa-table-sec"]{
    width: 100%;
    min-width: 100%;
    table-layout: fixed;
    border-collapse: collapse;
    font-size: clamp(11px, 1.05vw, 13px);
  }
  /* Center header text for tables (minimal padding for column names) */
  #sa-narrative-container #sa-table thead th { position: sticky; top: 0; z-index: 10; background: #f3f4f6; border: 1px solid #e5e7eb; padding: 2px 4px; font-weight: 650; color: #374151; cursor: pointer; user-select: none; text-align: center; white-space: normal; overflow-wrap: anywhere; word-break: break-word; padding-right: 16px; }
  #sa-narrative-container table[id^="sa-table-"],
  #sa-narrative-container table[id^="sa-table-sec"]{ width:100%; }
  #sa-narrative-container table[id^="sa-table-"] thead th,
  #sa-narrative-container table[id^="sa-table-sec"] thead th { position: sticky; top: 0; z-index: 10; background: #f3f4f6; border: 1px solid #e5e7eb; padding: 2px 4px; font-weight: 600; color: #374151; cursor: pointer; user-select: none; text-align: center; white-space: normal; overflow-wrap: anywhere; word-break: break-word; padding-right: 16px; }
  #sa-narrative-container #sa-table thead th:last-child { padding-right: 8px; }
  #sa-narrative-container #sa-table thead th:hover { background: #e5e7eb; }
  #sa-narrative-container #sa-table tbody td { border: 1px solid #e5e7eb; padding: 4px 6px; color: #1f2937; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  #sa-narrative-container table[id^="sa-table-"] tbody td,
  #sa-narrative-container table[id^="sa-table-sec"] tbody td { border: 1px solid #e5e7eb; padding: 3px 5px; color: #1f2937; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  /* Keep first column readable and aligned */
  #sa-narrative-container #sa-table tbody td,
  #sa-narrative-container table[id^="sa-table-"] tbody td { line-height: 1.25; vertical-align: middle; }
  #sa-narrative-container #sa-table tbody td:first-child,
  #sa-narrative-container table[id^="sa-table-"] tbody td:first-child { font-size: inherit; font-family: inherit; }
  #sa-narrative-container #sa-table tbody tr:nth-child(2n) { background: #f9fafb; }
  #sa-narrative-container #sa-table tbody tr:hover { background: #dbeafe; }
  #sa-narrative-container .sa-num {
    text-align: right;
    font-variant-numeric: tabular-nums;
    font-feature-settings: "tnum";
  }
  #sa-narrative-container .sa-fullscreen { position: fixed !important; display: flex !important; flex-direction: column !important; top: 0; left: 0; right: 0; bottom: 0; width: 100vw !important; height: 100vh !important; z-index: 9999; background: white; padding: 0 !important; margin: 0 !important; border-radius: 0 !important; overflow: hidden; }
  #sa-narrative-container .sa-fullscreen .sa-inner { flex: 1 1 auto !important; min-height: 0 !important; height: auto !important; }
  #sa-narrative-container .sa-fullscreen .sa-chart-stats{ flex: 0 0 auto; }
  #sa-narrative-container .sa-avg-label { position: absolute; font-size: 10px; font-weight: 600; color: #6b7280; background: rgba(255,255,255,0.9); padding: 2px 4px; border-radius: 3px; pointer-events: none; }
  #sa-narrative-container .sa-filter-close-btn { position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; border-radius: 50%; background: #f3f4f6; border: 1px solid #d1d5db; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; color: #6b7280; }
  #sa-narrative-container .sa-filter-close-btn:hover { background: #e5e7eb; color: #111827; }
  /* Dynamic axis label styles */
  #sa-narrative-container .sa-axis-label { position: absolute; display: none; font-size: 11px; font-weight: 700; padding: 3px 6px; border-radius: 2px; pointer-events: none; z-index: 999; box-shadow: 0 1px 3px rgba(0,0,0,0.15); }
  #sa-narrative-container .sa-axis-x-label { background: #06b6d4; color: white; }
  #sa-narrative-container .sa-axis-y-label { background: #f97316; color: white; }
  /* Legend - allow 2 rows and rely on Plotly layout for font size */
  #sa-narrative-container .plotly .legend { overflow-x: auto !important; overflow-y: auto !important; max-height: 80px !important; width: 100% !important; }
  #sa-narrative-container .plotly .legend g.traces { display: inline-block !important; }

  /* Statistics popover table (BoxPlot-like scroller + table look) */
  #sa-narrative-container .sa-stat-scroller{
    display: inline-block;
    max-width: 100%;
    max-height: clamp(180px, 34vh, 460px);
    overflow: auto;
    overscroll-behavior: contain;
    border: 1px solid rgba(148,163,184,.6);
    border-radius: 10px;
    background: #fff;
    padding: 1px;
  }
  #sa-narrative-container[data-theme="dark"] .sa-stat-scroller{
    background: #0f172a;
    border-color: #334155;
  }
  #sa-narrative-container .sa-stat-table{
    width: max-content;
    min-width: 100%;
    border-collapse: collapse;
    font-size: 12px;
    color: inherit;
  }
  #sa-narrative-container .sa-stat-table th,
  #sa-narrative-container .sa-stat-table td{
    border: 1px solid rgba(148,163,184,.6);
    padding: 6px 8px;
    white-space: nowrap;
  }
  #sa-narrative-container[data-theme="dark"] .sa-stat-table th,
  #sa-narrative-container[data-theme="dark"] .sa-stat-table td{ border-color: #334155; }
  #sa-narrative-container .sa-stat-table th{
    position: sticky;
    top: 0;
    z-index: 2;
    background: #fff;
    text-align: center;
    font-weight: 700;
  }
  #sa-narrative-container[data-theme="dark"] .sa-stat-table th{ background: #0f172a; }
  #sa-narrative-container .sa-stat-table td:first-child{ text-align: left; }
  #sa-narrative-container .sa-stat-table td{ text-align: right; }
  #sa-narrative-container .sa-stat-table tbody tr:nth-child(even) td{ background: rgba(0,0,0,.02); }
  #sa-narrative-container[data-theme="dark"] .sa-stat-table tbody tr:nth-child(even) td{ background: rgba(255,255,255,.03); }
  #sa-narrative-container .sa-stat-table td.med{ background: rgba(59,130,246,.10); font-weight: 650; }
  #sa-narrative-container[data-theme="dark"] .sa-stat-table td.med{ background: rgba(59,130,246,.20); }

  /* Settings panel */
  /* Legacy settings panel removed (migrated into report header popover) */

  /* Class used to strip bottom borders when applied to ancestors - scoped to container */
  #sa-narrative-container .sa-no-bottom-border,
  #sa-narrative-container .sa-no-bottom-border * {
    border-bottom: none !important;
    box-shadow: none !important;
    background-image: none !important;
    border-image: none !important;
  }

</style>

<script>
(function() {
  if (typeof Plotly === 'undefined') {
    document.getElementById('sa-scatter-root').innerHTML = '<div style="padding:24px;color:#b91c1c;font-weight:700;text-align:center;">Plotly library not loaded</div>';
    return;
  }

  var dataHost = document.getElementById('scatter-data') || document.getElementById('box-data');
  var paramsHost = document.getElementById('scatter-params');
  var rootHost = document.getElementById('sa-scatter-root');
  if (!dataHost || !rootHost) return;

  var ds = (paramsHost && paramsHost.dataset) || {};
  var DEBUG = String(ds.debug || '0') !== '0';

  // PV wiring audit: in DEBUG mode, report missing dataset keys
  (function(){
    if(!DEBUG) return;
    try{
      var expectedKeys = [
        'layout','tableRows','themeDefault','gridGap','fillHeight','chartHeight','tableHeight',
        'normalColor','outlierColor','trendColor','ciColor','ciOpacity',
        'chartTitleSize','histShowCounts','chartType',
        'enableMultiSection','xCol','chartsJson','tablesJson',
        'showCardTitles','showPlotTitles','showSectionSelector','showTable','showChart1','showChart2','gridPreset','showSettingsGear','chartsPerRow',
        'targets','targetsEnabled','targetColor','targetWidth','targetDash',
        'showCell','cfEnabled','axisDecimals','hoverColor','hoverBg','cfRed','cfGreen',
        'reportTitle','reportSubtitle','cardBorderRadius','axisFixedBuffer','xNticksMult','fullscreenFontScale',
        'hoverCols1','hoverCols2','outlierColored','sectionCol','chart1X','chart1Y','chart2X','chart2Y','cfCol','tableCols',
        'reportTitleBorderColor',
        'tableFilterCols','tableFilterDefaultCol','tableFilterDefaultMin','tableFilterDefaultMax'
      ];
      var missing = [];
      expectedKeys.forEach(function(k){
        if(ds[k] === undefined) missing.push(k);
      });
      if(missing.length){
        try{ console.warn('[Reg_Hist] Missing PV wiring for data-* keys:', missing.join(', ')); }catch(_){ }
      }
    }catch(e){ }
  })();
  function dbg(){ if(DEBUG && window.console && console.log) try{ console.log.apply(console, arguments); }catch(_){ } }
  function dbgWarn(){ if(DEBUG && window.console && console.warn) try{ console.warn.apply(console, arguments); }catch(_){ } }

  function resetAllChartsToDefaults(){
    try{
      STATE.filterX={min:null,max:null};
      STATE.filterY={min:null,max:null};
      STATE.excludeOutliers=false;
      STATE.removedIndices={};
      for(var chartNum=1; chartNum<=CHART_COUNT; chartNum++){
        var defC = CHART_DEFS[chartNum-1] || {};
        STATE['showOutliers'+chartNum]=true;
        STATE['showAvgX'+chartNum]=true;
        STATE['showAvgY'+chartNum]=true;
        STATE['showRegression'+chartNum]=true;
        STATE['showCI'+chartNum]=true;
        STATE['showRegTicks'+chartNum]=false;
        STATE['removeMode'+chartNum]=false;
        STATE['yMode'+chartNum]='auto';
        STATE['yMin'+chartNum]=null;
        STATE['yMax'+chartNum]=null;
        STATE['yScale'+chartNum]='linear';
        STATE['xMin'+chartNum]=null;
        STATE['xMax'+chartNum]=null;
        STATE['chartType'+chartNum]=normChartType(defC.defaultType || DEFAULT_CHART_TYPE || 'scatter');
        STATE['dragMode'+chartNum]='zoom';
        STATE['regressionMethod'+chartNum]=String(defC.defaultRegressionMethod || 'linear');
        STATE['histBins'+chartNum]=20;
        STATE['legendPos'+chartNum]='bottom';
        STATE['showLegend'+chartNum]=true;
        STATE['pointsMode'+chartNum]='auto';
        STATE['showLabels'+chartNum]=false;
        STATE['xRangeSlider'+chartNum]=false;
        STATE['showStatsTable'+chartNum]=false;

        // per-chart targets
        STATE['targetsOn'+chartNum]=false;
        STATE['tXMin'+chartNum]=null; STATE['tXMax'+chartNum]=null;
        STATE['tYMin'+chartNum]=null; STATE['tYMax'+chartNum]=null;
        STATE['tXBand'+chartNum]=false; STATE['tYBand'+chartNum]=false;
      }
      rebuildLayout();
    }catch(e){ }
  }
  // Layout & sizing (PV_*)
  var LAYOUT = (ds.layout || 'H').toUpperCase(); // PV_Layout: H | V
  var TABLE_ROWS = parseInt(ds.tableRows || '27', 10); // PV_TableRows: integer
  var CHART_HEIGHT = parseInt(ds.chartHeight || '540', 10); // PV_ChartHeight: px (used when PV_FillHeight=0)
  var TABLE_HEIGHT = parseInt(ds.tableHeight || '450', 10); // PV_TableHeight: px (used when PV_FillHeight=0)
  var CHARTS_PER_ROW = Math.max(1, Math.min(2, parseInt(ds.chartsPerRow || '2', 10) || 2)); // PV_ChartsPerRow

  // Table Filter (PV_*)
  var TABLE_FILTER_COLS_RAW = String(ds.tableFilterCols || 'all').trim(); // PV_TableFilterCols
  var TABLE_FILTER_DEFAULT_COL_RAW = String(ds.tableFilterDefaultCol || '').trim(); // PV_TableFilterDefaultCol
  var TABLE_FILTER_DEFAULT_MIN_RAW = String(ds.tableFilterDefaultMin || '').trim(); // PV_TableFilterDefaultMin
  var TABLE_FILTER_DEFAULT_MAX_RAW = String(ds.tableFilterDefaultMax || '').trim(); // PV_TableFilterDefaultMax

  // Conditional formatting & numeric formatting (PV_*)
  var CF_ENABLED = (ds.cfEnabled || '1') !== '0'; // PV_CF_Enabled: 0 | 1
  var AXIS_DEC = parseInt(ds.axisDecimals || '2', 10); // PV_AxisDecimals: integer

  // Report header (PV_*)
  var REPORT_TITLE = ds.reportTitle || 'Scatter and Histogram Analysis'; // PV_ReportTitle: string
  var REPORT_SUBTITLE = ds.reportSubtitle || ''; // PV_ReportSubtitle: string
  var REPORT_TITLE_BORDER_COLOR = ds.reportTitleBorderColor || 'rgba(0,0,0,0.15)'; // PV_ReportTitleBorderColor: CSS color

  // Theme/colors (PV_*)
  var OUTLIER_COLOR = ds.outlierColor || '#f97316'; // PV_OutlierColor: CSS color
  var NORMAL_COLOR = ds.normalColor || '#0f766e'; // PV_NormalColor: CSS color
  var HOVER_COLOR = ds.hoverColor || '#0284c7'; // PV_HoverColor: CSS color
  var HOVER_BG = ds.hoverBg || 'rgba(2,132,199,0.08)'; // PV_HoverBg: CSS color
  var TREND_COLOR = ds.trendColor || '#6b7280'; // PV_TrendColor: CSS color
  var BAND_COLOR = ds.ciColor || ds.bandColor || '#90A4AE'; // PV_CIColor: CSS color
  var CF_RED = ds.cfRed || '#fca5a5'; // PV_CF_Red: CSS color
  var CF_GREEN = ds.cfGreen || '#bbf7d0'; // PV_CF_Green: CSS color

  var FILL_HEIGHT = String(ds.fillHeight || '0') !== '0'; // PV_FillHeight: 0 | 1
  try{
    var cont = document.getElementById('sa-narrative-container');
    if(cont && FILL_HEIGHT) cont.classList.add('sa-fill-height');
  }catch(_){ }

  // In OAS dashboards there is often a prompts region above the narrative.
  // Fill-height mode should use only the remaining visible viewport height.
  function __saSyncAvailableHeight(){
    if(!FILL_HEIGHT) return;
    try{
      var contEl = document.getElementById('sa-narrative-container');
      var rootEl = document.getElementById('sa-scatter-root');
      if(!contEl || !rootEl || !rootEl.getBoundingClientRect) return;
      var r = rootEl.getBoundingClientRect();
      var top = (r && isFinite(r.top)) ? r.top : 0;
      // Clamp when scrolled so we don't grow beyond viewport.
      top = Math.max(0, top);
      var pad = 8;
      var avail = Math.floor((window.innerHeight || 0) - top - pad);
      if(!isFinite(avail) || avail < 240) avail = 240;
      contEl.style.setProperty('--sa-avail-h', avail + 'px');
    }catch(e){ }
  }
  function __saDebounce(fn, ms){
    var t=null;
    return function(){
      try{ if(t) clearTimeout(t); }catch(_){ }
      var args=arguments;
      t=setTimeout(function(){ fn.apply(null, args); }, ms||120);
    };
  }
  var __saSyncAvailDebounced = __saDebounce(__saSyncAvailableHeight, 120);
  try{
    if(FILL_HEIGHT){
      __saSyncAvailableHeight();
      // Run a few times after load to catch prompt expand/collapse.
      setTimeout(__saSyncAvailableHeight, 50);
      setTimeout(__saSyncAvailableHeight, 250);
      setTimeout(__saSyncAvailableHeight, 900);
      setTimeout(__saSyncAvailableHeight, 2000);
      window.addEventListener('resize', __saSyncAvailDebounced);
      window.addEventListener('scroll', __saSyncAvailDebounced, {passive:true});
      // Best-effort: prompt region changes often mutate DOM.
      if(window.MutationObserver){
        var mo = new MutationObserver(function(){ __saSyncAvailDebounced(); });
        mo.observe(document.body, {subtree:true, childList:true, attributes:true});
      }
    }
  }catch(_){ }

  // Plot fonts & bands (PV_*)
  var TITLE_FONT_SIZE = parseInt(ds.chartTitleSize || '16', 10); // PV_ChartTitleSize: px
  // Axis font sizes are derived automatically from PV_ChartTitleSize.
  var AXIS_TITLE_FONT_SIZE = 14;
  var AXIS_TICK_FONT_SIZE = 12;
  function __saSyncAxisFontSizes(){
    try{
      var t = isFinite(TITLE_FONT_SIZE) ? TITLE_FONT_SIZE : 16;
      AXIS_TITLE_FONT_SIZE = Math.max(12, Math.round(t * 0.85));
      AXIS_TICK_FONT_SIZE = Math.max(10, Math.round(t * 0.72));
    }catch(_){
      AXIS_TITLE_FONT_SIZE = 14;
      AXIS_TICK_FONT_SIZE = 12;
    }
  }
  __saSyncAxisFontSizes();
  var BAND_OPACITY = parseFloat(ds.ciOpacity || '0.30'); // PV_CIOpacity: 0..1
  var LEGEND_LABEL_MAX = 24; // computed dynamically per chart

  var CARD_BORDER_RADIUS = parseInt(ds.cardBorderRadius || '12', 10); // PV_CardBorderRadius: px
  var AXIS_FIXED_BUFFER = parseFloat(ds.axisFixedBuffer || '5'); // PV_AxisFixedBuffer: number
  var X_NTICKS_MULT = parseInt(ds.xNticksMult || '1', 10); // PV_XNticksMult: integer
  var FULLSCREEN_FONT_SCALE = parseFloat(ds.fullscreenFontScale || '1.2'); // PV_FullscreenFontScale: number
  var HOVER_COLS_1 = (ds.hoverCols1 || '0,1').split(',').map(function(s){return s.trim();}).filter(function(s){return s.length;});
  var HOVER_COLS_2 = (ds.hoverCols2 || '0,1').split(',').map(function(s){return s.trim();}).filter(function(s){return s.length;});
  var OUTLIER_COLORED = (ds.outlierColored || '1') !== '0'; // PV_OutlierColored: 0 | 1
  var SECTION_COL = parseInt(ds.sectionCol || '0', 10); // PV_SectionCol: 0-based index
  var CHART1_X = parseInt(ds.chart1X || '4', 10); // PV_Chart1X: 0-based index
  var CHART1_Y = parseInt(ds.chart1Y || '5', 10); // PV_Chart1Y: 0-based index
  var CHART2_X = parseInt(ds.chart2X || '4', 10); // PV_Chart2X: 0-based index
  var CHART2_Y = parseInt(ds.chart2Y || '8', 10); // PV_Chart2Y: 0-based index
  var CF_COL = parseInt(ds.cfCol || '8', 10); // PV_CFCol: 0-based index
  var TABLE_COLS = (ds.tableCols || '1,2,3,4,5,6,7,8,9').split(',').map(function(s){return parseInt(s.trim(),10);}).filter(function(n){return !isNaN(n);}); // PV_TableCols: comma-separated 0-based indices
  var HIST_SHOW_COUNTS = (ds.histShowCounts || '1') !== '0'; // PV_HistShowCounts: 0 | 1

  // Parameter-driven layout/config
  var ENABLE_MULTI_SECTION = (ds.enableMultiSection || '0') !== '0'; // PV_EnableMultiSection: 0 | 1
  var X_COL_RAW = ds.xCol;
  var CHARTS_JSON_RAW = ds.chartsJson;
  var TABLES_JSON_RAW = ds.tablesJson;

  var SHOW_CARD_TITLES = String(ds.showCardTitles || '1') !== '0'; // PV_ShowCardTitles: 0 | 1
  var SHOW_PLOT_TITLES = String(ds.showPlotTitles || '0') !== '0'; // PV_ShowPlotTitles: 0 | 1
  var SHOW_SECTION_SELECTOR = String(ds.showSectionSelector || '0') !== '0'; // PV_ShowSectionSelector: 0 | 1
  var SHOW_TABLE = String(ds.showTable || '1') !== '0'; // PV_ShowTable: 0 | 1
  var SHOW_CHART1 = String(ds.showChart1 || '1') !== '0'; // PV_ShowChart1: 0 | 1
  var SHOW_CHART2 = String(ds.showChart2 || '1') !== '0'; // PV_ShowChart2: 0 | 1

  var GRID_PRESET_RAW = String(ds.gridPreset || '').trim(); // PV_GridPreset
  var SHOW_SETTINGS_GEAR = String(ds.showSettingsGear || '1') !== '0'; // PV_ShowSettingsGear

  function normChartType(v){
    v = String(v||'').trim().toLowerCase();
    var alias = {
      'hist': 'histogram',
      'histogram': 'histogram',
      'histkde': 'hist+kde',
      'hist+kde': 'hist+kde',
      'hist-kde': 'hist+kde',
      'bar': 'bar',
      'scatter': 'scatter',
      'scattergl': 'scattergl'
    };
    v = alias[v] || v;
    var ok = {scatter:1, scattergl:1, bar:1, histogram:1, 'hist+kde':1};
    return ok[v] ? v : 'scatter';
  }
  var DEFAULT_CHART_TYPE = normChartType(ds.chartType || 'scatter');

  function normTheme(v){
    v = String(v||'').trim().toLowerCase();
    if(v==='dark') return 'dark';
    if(v==='paper') return 'paper';
    return 'light';
  }
  function parseTargets(txt){
    return String(txt||'').split(/[,;\s]+/).map(function(s){return s.trim();}).filter(Boolean).map(Number).filter(function(n){return isFinite(n);});
  }

  var THEME_DEFAULT = normTheme(ds.themeDefault || ds.theme || 'light');
  var GRID_GAP_DEFAULT = Math.max(0, Math.min(40, parseInt(ds.gridGap || '6', 10) || 6));
  var GRID_GAP = GRID_GAP_DEFAULT;
  var TARGETS_ENABLED_DEFAULT = (ds.targetsEnabled || '0') !== '0';
  var TARGETS_DEFAULT = parseTargets(ds.targets || '');
  var TARGET_COLOR_DEFAULT = (ds.targetColor || '#dc2626');
  var TARGET_WIDTH_DEFAULT = Math.max(0.5, Math.min(6, parseFloat(String(ds.targetWidth || '1.5')) || 1.5));
  var TARGET_DASH_DEFAULT = (ds.targetDash || 'dash');
  var SHOW_CELL_DEFAULT = (ds.showCell || '1') !== '0';

  function applyGridGap(px){
    var n = parseInt(px, 10);
    if(!isFinite(n)) n = GRID_GAP_DEFAULT;
    n = Math.max(0, Math.min(40, n));
    GRID_GAP = n;
    try{ rootHost.style.setProperty('--grid-gap', GRID_GAP + 'px'); }catch(e){}
  }

  applyGridGap(GRID_GAP_DEFAULT);

  // Defaults snapshot (based on OAS params, before any persisted overrides)
  var DEFAULTS = {
    layout: (ds.layout || 'H').toUpperCase(),
    gridGap: GRID_GAP_DEFAULT,
    chartHeight: parseInt(ds.chartHeight || '540', 10),
    tableHeight: parseInt(ds.tableHeight || '500', 10),
    tableRows: parseInt(ds.tableRows || '27', 10),
    chartsPerRow: Math.max(1, Math.min(2, parseInt(ds.chartsPerRow || '2', 10) || 2)),
    autoSize: true,
    showTable: !!SHOW_TABLE,
    showChart1: !!SHOW_CHART1,
    showChart2: !!SHOW_CHART2,
    gridPreset: GRID_PRESET_RAW || '',

    // Presentation / report
    theme: THEME_DEFAULT,
    reportTitle: REPORT_TITLE,
    reportSubtitle: REPORT_SUBTITLE,
    reportTitleBorderColor: REPORT_TITLE_BORDER_COLOR,
    enableMultiSection: !!ENABLE_MULTI_SECTION,
    showCardTitles: !!SHOW_CARD_TITLES,
    showPlotTitles: !!SHOW_PLOT_TITLES,
    showSectionSelector: !!SHOW_SECTION_SELECTOR,

    // Styling
    titleFontSize: TITLE_FONT_SIZE,
    cardBorderRadius: CARD_BORDER_RADIUS,
    axisDecimals: AXIS_DEC,
    axisFixedBuffer: AXIS_FIXED_BUFFER,
    xNticksMult: X_NTICKS_MULT,
    fullscreenFontScale: FULLSCREEN_FONT_SCALE,
    normalColor: NORMAL_COLOR,
    outlierColor: OUTLIER_COLOR,
    trendColor: TREND_COLOR,
    ciColor: BAND_COLOR,
    ciOpacity: BAND_OPACITY,
    hoverColor: HOVER_COLOR,
    hoverBg: HOVER_BG,
    outlierColored: !!OUTLIER_COLORED,

    // Conditional formatting
    cfEnabled: !!CF_ENABLED,
    cfRed: CF_RED,
    cfGreen: CF_GREEN,

    // Targets
    targetColor: TARGET_COLOR_DEFAULT,
    targetWidth: TARGET_WIDTH_DEFAULT,
    targetDash: TARGET_DASH_DEFAULT,

    // Column mappings
    xCol: X_COL,
    sectionCol: SECTION_COL,
    cfCol: CF_COL,
    tableCols: (TABLE_COLS||[]).slice(),
    hoverCols1: (HOVER_COLS_1||[]).slice(),
    hoverCols2: (HOVER_COLS_2||[]).slice(),

    // Table filter
    tableFilterCols: String(TABLE_FILTER_COLS_RAW||'all')
  };

  function safeParseJSON(txt) {
    if (!txt) return [];
    txt = txt.trim();
    try { return JSON.parse(txt); } catch(e) {}
    var out = [];
    var rx = /\{[\s\S]*?\}/g, m;
    while ((m = rx.exec(txt)) !== null) {
      try { out.push(JSON.parse(m[0])); } catch(e2) {}
    }
    return out;
  }

  var rawText = dataHost.textContent || dataHost.innerText || '';
	
	// Debug logs are opt-in via PV_Debug
	dbg('DEBUG: Raw text from scatter-data div:', rawText);
	dbg('DEBUG: Raw text length:', rawText.length);
	
  // Check if data contains unresolved OAS tokens
  var hasUnresolvedTokens = /@\d+/.test(rawText);
  if (hasUnresolvedTokens) {
    dbgWarn('WARNING: Found unresolved OAS tokens (@1, @2, etc.) in data. Data may not be properly bound.');
  }
	
  var rowsRaw = safeParseJSON(rawText);
  dbg('DEBUG: Parsed rows count:', rowsRaw.length);
  if (rowsRaw.length > 0) {
    dbg('DEBUG: First row:', rowsRaw[0]);
    dbg('DEBUG: Keys:', Object.keys(rowsRaw[0]));
    // Check if values contain unresolved tokens
    var firstRow = rowsRaw[0];
    var hasTokenValues = false;
    Object.keys(firstRow).forEach(function(key) {
      if (/@\d+/.test(String(firstRow[key]))) {
        hasTokenValues = true;
        dbgWarn('WARNING: Unresolved token found in column "' + key + '": ' + firstRow[key]);
      }
    });
    if (hasTokenValues) {
      rootHost.innerHTML = '<div style="padding:24px;color:#d97706;font-weight:700;"><div style="font-size:16px;margin-bottom:10px;">⚠️ Data contains unresolved tokens</div>' +
        '<div style="font-size:12px;font-weight:400;color:#92400e;background:#fef3c7;padding:12px;border-radius:6px;text-align:left;max-width:700px;margin:0 auto;">' +
        '<strong>The data contains OAS tokens (@1, @2, etc.) that were not replaced with actual values.</strong><br><br>' +
        '<strong>To fix this:</strong><br>' +
        '• Make sure this narrative is linked to a visualization with data<br>' +
        '• Ensure you are viewing in Preview/Dashboard mode, not Edit mode<br>' +
        '• Verify the underlying visualization has query results<br>' +
        '• Check that column references in the Narrative section match your data<br><br>' +
        '<strong>First row data (partial):</strong><br><pre style="white-space:pre-wrap;font-size:10px;background:#fff;padding:8px;border:1px solid #ccc;border-radius:4px;max-height:150px;overflow:auto;">' + 
        JSON.stringify(firstRow, null, 2).substring(0, 400) + '</pre>' +
        '</div></div>';
      return;
    }
  }
	
  if (!rowsRaw.length) {
    rootHost.innerHTML = '<div style="padding:24px;color:#b91c1c;font-weight:700;"><div style="font-size:16px;margin-bottom:10px;">⚠️ No data found</div>' +
      '<div style="font-size:12px;font-weight:400;color:#991b1b;background:#fee;padding:12px;border-radius:6px;text-align:left;max-width:600px;margin:0 auto;">' +
      '<strong>Debugging Information:</strong><br><br>' +
      '<strong>Raw text content:</strong><br><pre style="white-space:pre-wrap;font-size:10px;background:#fff;padding:8px;border:1px solid #ccc;border-radius:4px;max-height:200px;overflow:auto;">' + 
      (rawText || '(empty)').substring(0, 500) + (rawText.length > 500 ? '...' : '') + '</pre><br>' +
      '<strong>Possible causes:</strong><br>' +
      '• Narrative is not connected to a data source<br>' +
      '• Visualization has no data/results<br>' +
      '• Data tokens (@1, @2, etc.) are not being replaced by OAS<br>' +
      '• Check browser console for more details (F12)<br><br>' +
      '<strong>Expected format:</strong> Array of JSON objects like [{"Line":"value","Cell ID":"value",...}]' +
      '</div></div>';
    return;
  }

  var KEYS = Object.keys(rowsRaw[0]);
  function findKey(name) { var i = KEYS.indexOf(name); return i === -1 ? null : i; }
  function coalesceIndex(a,b,def){ return a!==null && a!==undefined ? a : (b!==null && b!==undefined ? b : def); }

  function safeParseConfigJson(txt, fallback){
    try{
      if(txt == null) return fallback;
      var s = String(txt).trim();
      if(!s) return fallback;
      return JSON.parse(s);
    }catch(e){
      return fallback;
    }
  }
  function resolveColRef(ref){
    if(ref === null || ref === undefined) return null;
    if(typeof ref === 'number' && isFinite(ref)) return Math.round(ref);
    var s = String(ref).trim();
    if(!s) return null;
    if(/^\d+$/.test(s)) return parseInt(s, 10);
    var idx = findKey(s);
    return idx === null ? null : idx;
  }

  // Use configured column indices
  var idxSection = SECTION_COL;
  var idxCell = 1;

  // Parameter-driven chart config: one shared X column + N chart Y columns
  var X_COL = resolveColRef(X_COL_RAW);
  if(X_COL === null) X_COL = CHART1_X;
  X_COL = Math.max(0, Math.min(KEYS.length - 1, X_COL));

  function normalizeChartDefs(raw){
    var arr = safeParseConfigJson(raw, []);
    if(!Array.isArray(arr)) arr = [];
    var out = [];
    arr.forEach(function(c){
      if(!c) return;
      var yRef = (c.yCol!=null ? c.yCol : (c.y!=null ? c.y : null));
      var yCol = resolveColRef(yRef);
      if(yCol === null) return;
      yCol = Math.max(0, Math.min(KEYS.length - 1, yCol));
      out.push({
        title: c.title,
        yCol: yCol,
        defaultType: c.type,
        defaultRegressionMethod: c.regressionMethod,
        show: (c.show===undefined ? true : !!c.show)
      });
    });
    if(!out.length){
      out.push({title:'Latest BRSP vs Latest Comb Res', yCol: CHART1_Y, show:true});
      out.push({title:'Proposed BRSP vs Latest Comb Res', yCol: CHART2_Y, show:true});
    }
    return out;
  }

  var CHART_DEFS = normalizeChartDefs(CHARTS_JSON_RAW);
  var CHART_COUNT = CHART_DEFS.length;

  var combLabel = KEYS[X_COL];
  var latestLabel = KEYS[(CHART_DEFS[0] && CHART_DEFS[0].yCol != null) ? CHART_DEFS[0].yCol : CHART1_Y];
  var propLabel = KEYS[(CHART_DEFS[1] && CHART_DEFS[1].yCol != null) ? CHART_DEFS[1].yCol : CHART2_Y];
  var cfColLabel = KEYS[CF_COL];
  var sectionLabel = KEYS[idxSection];

  function rgba(hex, a){
    if(!hex) return 'rgba(148,163,184,'+a+')';
    if(hex.indexOf('rgba')===0) return hex; if(hex.indexOf('rgb(')===0) return hex.replace('rgb(','rgba(').replace(')',','+a+')');
    var h = String(hex).replace('#','');
    if(h.length===3) h = h[0]+h[0]+h[1]+h[1]+h[2]+h[2];
    var r=parseInt(h.substring(0,2),16), g=parseInt(h.substring(2,4),16), b=parseInt(h.substring(4,6),16);
    return 'rgba('+r+','+g+','+b+','+a+')';
  }

  function toNum(v) {
    if (v === null || v === undefined || v === '') return null;
    var cleaned = String(v).replace(/,/g, '').trim();
    var n = Number(cleaned);
    return isFinite(n) ? n : null;
  }

  function rawDecimalsCount(v){
    if(v===null || v===undefined) return null;
    var s=String(v).trim();
    if(!s) return null;
    s=s.replace(/,/g,'');
    var m=s.match(/^[-+]?\d+(?:\.(\d+))?(?:[eE][-+]?\d+)?$/);
    if(!m) return null;
    return m[1] ? m[1].length : 0;
  }
  function inferDecimalsForKey(key){
    var mx = 0;
    var scan = Math.min(rowsRaw.length, 4000);
    for(var i=0;i<scan;i++){
      var dc = rawDecimalsCount(rowsRaw[i] && rowsRaw[i][key]);
      if(dc===null) continue;
      if(dc>mx) mx = dc;
      if(mx>=6) break;
    }
    return Math.max(0, Math.min(6, mx));
  }

  function fmtFixedTrim(v, dp){
    if(v===null || v===undefined || !isFinite(v)) return 'N/A';
    var n = Number(v);
    var d = Math.max(0, Math.min(6, (dp===null || dp===undefined) ? AXIS_DEC : dp));
    if(d===0) return String(Math.round(n));
    var s = n.toFixed(d);
    return s.replace(/\.?0+$/,'');
  }

  var calc = rowsRaw.map(function(r) {
    var ys = [];
    for(var i=0;i<CHART_COUNT;i++){
      var yKey = KEYS[CHART_DEFS[i].yCol];
      ys[i+1] = toNum(r[yKey]);
    }
    return {
      raw: r,
      cell: String(r[KEYS[idxCell]] || ''),
      section: String(r[sectionLabel] || ''),
      x: toNum(r[combLabel]),
      ys: ys,
      // Back-compat for legacy code paths (first two charts)
      yLatest: ys[1] ?? null,
      yProp: ys[2] ?? null
    };
  });

  // Use dataset precision for the selected columns (fallback to PV_AxisDecimals)
  var DEC_X = inferDecimalsForKey(combLabel);
  var DEC_Y1 = inferDecimalsForKey(latestLabel);
  var DEC_Y2 = inferDecimalsForKey(propLabel);
  if(!isFinite(DEC_X)) DEC_X = AXIS_DEC;
  if(!isFinite(DEC_Y1)) DEC_Y1 = AXIS_DEC;
  if(!isFinite(DEC_Y2)) DEC_Y2 = AXIS_DEC;

  var DEC_Y_BY_CHART = {};
  for(var cNum=1;cNum<=CHART_COUNT;cNum++){
    var def = CHART_DEFS[cNum-1];
    var yLbl = (def && def.yCol != null) ? KEYS[def.yCol] : null;
    var dy = yLbl ? inferDecimalsForKey(yLbl) : AXIS_DEC;
    if(!isFinite(dy)) dy = AXIS_DEC;
    DEC_Y_BY_CHART[cNum] = dy;
  }
  function getDecY(which){
    which = parseInt(which, 10);
    if(!isFinite(which)) return AXIS_DEC;
    return DEC_Y_BY_CHART[which] != null ? DEC_Y_BY_CHART[which] : (which===1?DEC_Y1:(which===2?DEC_Y2:AXIS_DEC));
  }
  function getYLabel(which){
    which = parseInt(which, 10);
    var def = (isFinite(which) && which>=1) ? CHART_DEFS[which-1] : null;
    if(def && def.yCol != null && KEYS[def.yCol] != null) return KEYS[def.yCol];
    return which===1 ? latestLabel : propLabel;
  }
  function isChartShown(which){
    which = parseInt(which, 10);
    if(!isFinite(which) || which<1) return false;
    if(which===1) return (STATE && typeof STATE.showChart1==='boolean') ? STATE.showChart1 : SHOW_CHART1;
    if(which===2) return (STATE && typeof STATE.showChart2==='boolean') ? STATE.showChart2 : SHOW_CHART2;
    if(STATE && typeof STATE['showChart'+which] === 'boolean') return !!STATE['showChart'+which];
    var def = CHART_DEFS[which-1];
    return def ? (def.show !== false) : true;
  }

  function __saRecomputeModel(){
    try{
      // Clamp core column indices
      X_COL = Math.max(0, Math.min(KEYS.length - 1, parseInt(X_COL, 10) || 0));
      SECTION_COL = Math.max(0, Math.min(KEYS.length - 1, parseInt(SECTION_COL, 10) || 0));
      CF_COL = Math.max(0, Math.min(KEYS.length - 1, parseInt(CF_COL, 10) || 0));

      // Ensure chart defs are valid
      if(!Array.isArray(CHART_DEFS)) CHART_DEFS = [];
      CHART_DEFS = CHART_DEFS.map(function(d, idx){
        d = d || {};
        var yCol = (d.yCol!=null) ? parseInt(d.yCol,10) : null;
        if(yCol==null || !isFinite(yCol)) yCol = Math.min(KEYS.length-1, Math.max(0, idx+1));
        yCol = Math.max(0, Math.min(KEYS.length-1, yCol));
        return {
          title: d.title,
          yCol: yCol,
          defaultType: d.defaultType,
          defaultRegressionMethod: d.defaultRegressionMethod,
          show: (d.show===undefined ? true : !!d.show)
        };
      });
      CHART_COUNT = CHART_DEFS.length;
      if(CHART_COUNT<1){
        CHART_DEFS = [{title:'Chart 1', yCol: Math.max(0, Math.min(KEYS.length-1, 0)), show:true}];
        CHART_COUNT = 1;
      }

      // Derived labels
      combLabel = KEYS[X_COL];
      latestLabel = KEYS[(CHART_DEFS[0] && CHART_DEFS[0].yCol != null) ? CHART_DEFS[0].yCol : CHART1_Y];
      propLabel = KEYS[(CHART_DEFS[1] && CHART_DEFS[1].yCol != null) ? CHART_DEFS[1].yCol : CHART2_Y];
      cfColLabel = KEYS[CF_COL];
      idxSection = SECTION_COL;
      sectionLabel = KEYS[idxSection];

      // Recompute calc
      calc = rowsRaw.map(function(r) {
        var ys = [];
        for(var i=0;i<CHART_COUNT;i++){
          var yKey = KEYS[CHART_DEFS[i].yCol];
          ys[i+1] = toNum(r[yKey]);
        }
        return {
          raw: r,
          cell: String(r[KEYS[idxCell]] || ''),
          section: String(r[sectionLabel] || ''),
          x: toNum(r[combLabel]),
          ys: ys,
          yLatest: ys[1] ?? null,
          yProp: ys[2] ?? null
        };
      });

      // Recompute sections + keys
      sections = {};
      calc.forEach(function(d){
        if(!sections[d.section]) sections[d.section] = [];
        sections[d.section].push(d);
      });
      sectionKeys = Object.keys(sections).sort();
      DEFAULT_SECTION = (sectionKeys.length > 1) ? 'All' : (sectionKeys.length ? sectionKeys[0] : 'All');

      // Keep current section valid
      if(!STATE.currentSection) STATE.currentSection = DEFAULT_SECTION;
      if(STATE.currentSection !== 'All' && sectionKeys.indexOf(STATE.currentSection)===-1){
        STATE.currentSection = DEFAULT_SECTION;
      }

      // Recompute decimals maps
      DEC_X = inferDecimalsForKey(combLabel);
      DEC_Y1 = inferDecimalsForKey(latestLabel);
      DEC_Y2 = inferDecimalsForKey(propLabel);
      if(!isFinite(DEC_X)) DEC_X = AXIS_DEC;
      if(!isFinite(DEC_Y1)) DEC_Y1 = AXIS_DEC;
      if(!isFinite(DEC_Y2)) DEC_Y2 = AXIS_DEC;

      DEC_Y_BY_CHART = {};
      for(var cNum=1;cNum<=CHART_COUNT;cNum++){
        var def = CHART_DEFS[cNum-1];
        var yLbl = (def && def.yCol != null) ? KEYS[def.yCol] : null;
        var dy = yLbl ? inferDecimalsForKey(yLbl) : AXIS_DEC;
        if(!isFinite(dy)) dy = AXIS_DEC;
        DEC_Y_BY_CHART[cNum] = dy;
      }
    }catch(_){ }
  }

  // Group data by section
  var sections = {};
  calc.forEach(function(d) {
    if(!sections[d.section]) sections[d.section] = [];
    sections[d.section].push(d);
  });
  var sectionKeys = Object.keys(sections).sort();
  var DEFAULT_SECTION = (sectionKeys.length > 1) ? 'All' : (sectionKeys.length ? sectionKeys[0] : 'All');

  // Default section to first available (fall back to 'All') handled after STATE init

  // STATE - initialize early
  var STATE = {
    theme: THEME_DEFAULT,
    excludeOutliers: false,
    filterX: {min:null,max:null},
    filterY: {min:null,max:null},
    removedIndices: {},
    sortCol: null,
    sortDir: 1,
    showHistCounts: HIST_SHOW_COUNTS,
    currentSection: DEFAULT_SECTION,
    outlierMethod: 'kmeans',
    autoSize: true,
    showTable: !!SHOW_TABLE,
    showChart1: !!SHOW_CHART1,
    showChart2: !!SHOW_CHART2,
    gridPreset: '',
    settingsTab: 'presentation',
    targetsOn: TARGETS_ENABLED_DEFAULT,
    targets: TARGETS_DEFAULT.slice(),
    showCell: SHOW_CELL_DEFAULT,
    tableFilter: { colLabel: null, min: '', max: '' }
  };
  for(var iChart=1;iChart<=CHART_COUNT;iChart++){
    var defC = CHART_DEFS[iChart-1] || {};
    // Support more than 2 charts: keep explicit show flags for charts 3+.
    // Charts 1/2 are governed by STATE.showChart1/showChart2 for compatibility.
    if(iChart>=3){
      STATE['showChart'+iChart] = (defC.show !== false);
    }
    STATE['showOutliers'+iChart] = true;
    STATE['showAvgX'+iChart] = true;
    STATE['showAvgY'+iChart] = true;
    STATE['showRegression'+iChart] = true;
    STATE['showCI'+iChart] = true;
    STATE['chartType'+iChart] = normChartType(defC.defaultType || DEFAULT_CHART_TYPE || 'scatter');
    STATE['dragMode'+iChart] = 'zoom';
    STATE['legendPos'+iChart] = 'bottom';
    STATE['showLegend'+iChart] = true;
    STATE['lastReg'+iChart] = null;
    STATE['regressionMethod'+iChart] = String(defC.defaultRegressionMethod || 'linear');
    STATE['histBins'+iChart] = 20;
    STATE['showRegTicks'+iChart] = false;

    STATE['pointsMode'+iChart] = 'all'; // all | none
    STATE['showLabels'+iChart] = false;

    STATE['removeMode'+iChart] = false;
    STATE['yMode'+iChart] = 'auto'; // auto | manual | tozero
    STATE['yMin'+iChart] = null;
    STATE['yMax'+iChart] = null;
    STATE['yScale'+iChart] = 'linear'; // linear | log

    // Scatter X-axis manual range
    STATE['xMin'+iChart] = null;
    STATE['xMax'+iChart] = null;

    // Targets per chart (new model; replaces global STATE.targets)
    STATE['targetsOn'+iChart] = false;
    STATE['tXMin'+iChart] = null;
    STATE['tXMax'+iChart] = null;
    STATE['tYMin'+iChart] = null;
    STATE['tYMax'+iChart] = null;
    STATE['tXBand'+iChart] = false;
    STATE['tYBand'+iChart] = false;
  }

  function __saInitChartState(chartNum){
    chartNum = parseInt(chartNum,10);
    if(!isFinite(chartNum) || chartNum<1) return;
    var defC = CHART_DEFS[chartNum-1] || {};
    if(chartNum>=3 && typeof STATE['showChart'+chartNum] !== 'boolean') STATE['showChart'+chartNum] = (defC.show !== false);
    if(STATE['showOutliers'+chartNum]===undefined) STATE['showOutliers'+chartNum]=true;
    if(STATE['showAvgX'+chartNum]===undefined) STATE['showAvgX'+chartNum]=true;
    if(STATE['showAvgY'+chartNum]===undefined) STATE['showAvgY'+chartNum]=true;
    if(STATE['showRegression'+chartNum]===undefined) STATE['showRegression'+chartNum]=true;
    if(STATE['showCI'+chartNum]===undefined) STATE['showCI'+chartNum]=true;
    if(STATE['chartType'+chartNum]===undefined) STATE['chartType'+chartNum]=normChartType(defC.defaultType || DEFAULT_CHART_TYPE || 'scatter');
    if(STATE['dragMode'+chartNum]===undefined) STATE['dragMode'+chartNum]='zoom';
    if(STATE['legendPos'+chartNum]===undefined) STATE['legendPos'+chartNum]='bottom';
    if(STATE['showLegend'+chartNum]===undefined) STATE['showLegend'+chartNum]=true;
    if(STATE['lastReg'+chartNum]===undefined) STATE['lastReg'+chartNum]=null;
    if(STATE['regressionMethod'+chartNum]===undefined) STATE['regressionMethod'+chartNum]=String(defC.defaultRegressionMethod || 'linear');
    if(STATE['histBins'+chartNum]===undefined) STATE['histBins'+chartNum]=20;
    if(STATE['showRegTicks'+chartNum]===undefined) STATE['showRegTicks'+chartNum]=false;
    if(STATE['pointsMode'+chartNum]===undefined) STATE['pointsMode'+chartNum]='all';
    if(STATE['showLabels'+chartNum]===undefined) STATE['showLabels'+chartNum]=false;
    if(STATE['removeMode'+chartNum]===undefined) STATE['removeMode'+chartNum]=false;
    if(STATE['yMode'+chartNum]===undefined) STATE['yMode'+chartNum]='auto';
    if(STATE['yMin'+chartNum]===undefined) STATE['yMin'+chartNum]=null;
    if(STATE['yMax'+chartNum]===undefined) STATE['yMax'+chartNum]=null;
    if(STATE['yScale'+chartNum]===undefined) STATE['yScale'+chartNum]='linear';
    if(STATE['xMin'+chartNum]===undefined) STATE['xMin'+chartNum]=null;
    if(STATE['xMax'+chartNum]===undefined) STATE['xMax'+chartNum]=null;
    if(STATE['targetsOn'+chartNum]===undefined) STATE['targetsOn'+chartNum]=false;
    if(STATE['tXMin'+chartNum]===undefined) STATE['tXMin'+chartNum]=null;
    if(STATE['tXMax'+chartNum]===undefined) STATE['tXMax'+chartNum]=null;
    if(STATE['tYMin'+chartNum]===undefined) STATE['tYMin'+chartNum]=null;
    if(STATE['tYMax'+chartNum]===undefined) STATE['tYMax'+chartNum]=null;
    if(STATE['tXBand'+chartNum]===undefined) STATE['tXBand'+chartNum]=false;
    if(STATE['tYBand'+chartNum]===undefined) STATE['tYBand'+chartNum]=false;
  }

  // Snapshot defaults for reset-to-PV behavior
  var DEFAULT_CHART_DEFS = (CHART_DEFS||[]).map(function(d){
    return { title:d && d.title, yCol:d && d.yCol, defaultType:d && d.defaultType, defaultRegressionMethod:d && d.defaultRegressionMethod, show:(d && d.show!==false) };
  });
  var DEFAULT_CHART_STATE = [];
  for(var _c=1; _c<=CHART_COUNT; _c++){
    DEFAULT_CHART_STATE.push({
      chartType: String(STATE['chartType'+_c]||'scatter'),
      histBins: parseInt(STATE['histBins'+_c]||20,10),
      pointsMode: String(STATE['pointsMode'+_c]||'auto'),
      showLabels: !!STATE['showLabels'+_c],
      showLegend: !!STATE['showLegend'+_c],
      legendPos: String(STATE['legendPos'+_c]||'auto'),
      regressionMethod: String(STATE['regressionMethod'+_c]||'linear'),
      showRegression: !!STATE['showRegression'+_c],
      showCI: !!STATE['showCI'+_c],
      showAvgX: !!STATE['showAvgX'+_c],
      showAvgY: !!STATE['showAvgY'+_c],
      showRegTicks: !!STATE['showRegTicks'+_c]
    });
  }

  function __saPresetToVisibility(preset){
    var raw = String(preset||'').trim();
    if(!raw) return null;
    var v = raw.toUpperCase().replace(/\s+/g,'');
    // Supported shorthands:
    // T   => table only
    // T1  => table + chart 1
    // T2  => table + 2 charts (chart1 + chart2)
    // T12 => table + chart 1 + chart 2
    // 1   => same as T1
    // 2   => same as T2
    if(v==='0'){
      return {preset:'T', showTable:true, showChart1:false, showChart2:false};
    }
    if(v==='1' || v==='T1' || v==='TABLE1' || v==='TABLE+1' || v==='TABLE+ONE'){
      return {preset:'T1', showTable:true, showChart1:true, showChart2:false};
    }
    if(v==='2' || v==='T2' || v==='TABLE2' || v==='TABLE+2' || v==='TABLE+TWO'){
      return {preset:'T2', showTable:true, showChart1:true, showChart2:true};
    }
    if(v==='T12' || v==='TABLE12' || v==='TABLE+12' || v==='TABLE+1+2'){
      return {preset:'T12', showTable:true, showChart1:true, showChart2:true};
    }
    if(v==='T' || v==='TABLE' || v==='TABLEONLY'){
      return {preset:'T', showTable:true, showChart1:false, showChart2:false};
    }
    return null;
  }

  function __saApplyGridPreset(preset){
    var vis = __saPresetToVisibility(preset);
    if(!vis){
      STATE.gridPreset = '';
      // fall back to PV defaults
      STATE.showTable = !!DEFAULTS.showTable;
      STATE.showChart1 = !!DEFAULTS.showChart1;
      STATE.showChart2 = !!DEFAULTS.showChart2;
      // Extra charts fall back to their CHART_DEFS show flags.
      for(var k=3;k<=CHART_COUNT;k++){
        try{ STATE['showChart'+k] = (CHART_DEFS[k-1] && CHART_DEFS[k-1].show !== false); }catch(_){ STATE['showChart'+k]=true; }
      }
      return;
    }
    STATE.gridPreset = vis.preset;
    STATE.showTable = !!vis.showTable;
    STATE.showChart1 = !!vis.showChart1;
    STATE.showChart2 = !!vis.showChart2;
    // When a preset is active, hide charts beyond chart2 unless user switches back to Custom.
    for(var k2=3;k2<=CHART_COUNT;k2++){
      STATE['showChart'+k2] = false;
    }
  }

  // Apply PV_GridPreset (can be overridden by persisted settings)
  __saApplyGridPreset(GRID_PRESET_RAW);

  // Settings persistence (localStorage)
  var SETTINGS_KEY = 'sa-scatter-settings-v2-' + String(REPORT_TITLE || 'default').replace(/\W+/g,'_');
  function getCurrentSettings(){
    var chartDefs = [];
    var chartState = [];
    for(var i=1;i<=CHART_COUNT;i++){
      var def = CHART_DEFS[i-1] || {};
      chartDefs.push({
        title: (def.title!=null?String(def.title):''),
        yCol: (def.yCol!=null?def.yCol:null),
        show: (function(){
          if(i===1) return !!STATE.showChart1;
          if(i===2) return !!STATE.showChart2;
          if(typeof STATE['showChart'+i] === 'boolean') return !!STATE['showChart'+i];
          return (def.show !== false);
        })()
      });
      chartState.push({
        chartType: String(STATE['chartType'+i]||'scatter'),
        histBins: parseInt(STATE['histBins'+i]||20,10),
        pointsMode: String(STATE['pointsMode'+i]||'auto'),
        showLabels: !!STATE['showLabels'+i],
        showLegend: !!STATE['showLegend'+i],
        legendPos: String(STATE['legendPos'+i]||'auto'),
        regressionMethod: String(STATE['regressionMethod'+i]||'linear'),
        showRegression: !!STATE['showRegression'+i],
        showCI: !!STATE['showCI'+i],
        showAvgX: !!STATE['showAvgX'+i],
        showAvgY: !!STATE['showAvgY'+i],
        showRegTicks: !!STATE['showRegTicks'+i]
      });
    }
    return {
      layout: LAYOUT,
      gridGap: GRID_GAP,
      chartHeight: CHART_HEIGHT,
      tableHeight: TABLE_HEIGHT,
      tableRows: TABLE_ROWS,
      chartsPerRow: CHARTS_PER_ROW,
      autoSize: STATE.autoSize,
      theme: String(STATE.theme||THEME_DEFAULT),
      settingsChartScope: String(STATE.settingsChartScope||'all'),
      showTable: !!STATE.showTable,
      showChart1: !!STATE.showChart1,
      showChart2: !!STATE.showChart2,
      gridPreset: String(STATE.gridPreset||''),
      enableMultiSection: !!ENABLE_MULTI_SECTION,
      showCardTitles: !!SHOW_CARD_TITLES,
      showPlotTitles: !!SHOW_PLOT_TITLES,
      showSectionSelector: !!SHOW_SECTION_SELECTOR,
      reportTitle: String(REPORT_TITLE||''),
      reportSubtitle: String(REPORT_SUBTITLE||''),
      reportTitleBorderColor: String(REPORT_TITLE_BORDER_COLOR||''),
      cardBorderRadius: CARD_BORDER_RADIUS,
      titleFontSize: TITLE_FONT_SIZE,
      axisDecimals: AXIS_DEC,
      axisFixedBuffer: AXIS_FIXED_BUFFER,
      xNticksMult: X_NTICKS_MULT,
      fullscreenFontScale: FULLSCREEN_FONT_SCALE,
      normalColor: NORMAL_COLOR,
      outlierColor: OUTLIER_COLOR,
      trendColor: TREND_COLOR,
      ciColor: BAND_COLOR,
      ciOpacity: BAND_OPACITY,
      hoverColor: HOVER_COLOR,
      hoverBg: HOVER_BG,
      outlierColored: !!OUTLIER_COLORED,
      cfEnabled: !!CF_ENABLED,
      cfRed: CF_RED,
      cfGreen: CF_GREEN,
      cfCol: CF_COL,
      xCol: X_COL,
      sectionCol: SECTION_COL,
      tableCols: (TABLE_COLS||[]).slice(),
      hoverCols1: (HOVER_COLS_1||[]).slice(),
      hoverCols2: (HOVER_COLS_2||[]).slice(),
      targetColor: TARGET_COLOR_DEFAULT,
      targetWidth: TARGET_WIDTH_DEFAULT,
      targetDash: TARGET_DASH_DEFAULT,
      legendPos: STATE.legendPos1,
      showLegend: STATE.showLegend1,
      showRegression: STATE.showRegression1,
      showCI: STATE.showCI1,
      showAvgX: STATE.showAvgX1,
      showAvgY: STATE.showAvgY1,
      showHistCounts: STATE.showHistCounts,
      chartDefs: chartDefs,
      chartState: chartState,
      tableFilter: (STATE && STATE.tableFilter) ? { colLabel: STATE.tableFilter.colLabel, min: STATE.tableFilter.min, max: STATE.tableFilter.max } : null,
      tableFilterCols: String(TABLE_FILTER_COLS_RAW||'all')
    };
  }
  function applySettingsObj(obj){
    if(!obj) return;
    var needsModelRecompute = false;
    if(obj.layout) LAYOUT = obj.layout;
    if(isFinite(obj.gridGap)) applyGridGap(obj.gridGap);
    if(isFinite(obj.chartHeight)) CHART_HEIGHT = obj.chartHeight;
    if(isFinite(obj.tableHeight)) TABLE_HEIGHT = obj.tableHeight;
    if(isFinite(obj.tableRows)) TABLE_ROWS = Math.max(1, Math.min(200, parseInt(obj.tableRows, 10) || 18));
    if(isFinite(obj.chartsPerRow)) CHARTS_PER_ROW = Math.max(1, Math.min(2, parseInt(obj.chartsPerRow, 10) || 2));
    if(typeof obj.autoSize === 'boolean') STATE.autoSize = obj.autoSize;
    if(typeof obj.theme === 'string' && obj.theme.trim()) STATE.theme = normTheme(obj.theme);
    if(typeof obj.settingsChartScope === 'string' && obj.settingsChartScope.trim()) STATE.settingsChartScope = String(obj.settingsChartScope);
    // Visibility / presentation
    if(typeof obj.gridPreset === 'string' && obj.gridPreset.trim()){
      __saApplyGridPreset(obj.gridPreset);
    }else{
      if(typeof obj.showTable === 'boolean') STATE.showTable = obj.showTable;
      if(typeof obj.showChart1 === 'boolean') STATE.showChart1 = obj.showChart1;
      if(typeof obj.showChart2 === 'boolean') STATE.showChart2 = obj.showChart2;
      STATE.gridPreset = '';
    }
    if(isFinite(obj.titleFontSize)){
      TITLE_FONT_SIZE = obj.titleFontSize;
      try{ __saSyncAxisFontSizes(); }catch(_){ }
    }
    if(isFinite(obj.axisDecimals)) AXIS_DEC = Math.max(0, Math.min(6, parseInt(obj.axisDecimals,10) || 0));
    if(isFinite(obj.axisFixedBuffer)) AXIS_FIXED_BUFFER = parseFloat(obj.axisFixedBuffer);
    if(isFinite(obj.xNticksMult)) X_NTICKS_MULT = Math.max(1, Math.min(10, parseInt(obj.xNticksMult,10) || 1));
    if(isFinite(obj.fullscreenFontScale)) FULLSCREEN_FONT_SCALE = Math.max(0.6, Math.min(2.2, parseFloat(obj.fullscreenFontScale) || 1.2));
    if(typeof obj.normalColor === 'string') NORMAL_COLOR = obj.normalColor;
    if(typeof obj.outlierColor === 'string') OUTLIER_COLOR = obj.outlierColor;
    if(typeof obj.trendColor === 'string') TREND_COLOR = obj.trendColor;
    if(typeof obj.ciColor === 'string') BAND_COLOR = obj.ciColor;
    if(isFinite(obj.ciOpacity)) BAND_OPACITY = obj.ciOpacity;
    if(typeof obj.hoverColor === 'string') HOVER_COLOR = obj.hoverColor;
    if(typeof obj.hoverBg === 'string') HOVER_BG = obj.hoverBg;
    if(typeof obj.outlierColored === 'boolean') OUTLIER_COLORED = obj.outlierColored;
    if(typeof obj.cfEnabled === 'boolean') CF_ENABLED = obj.cfEnabled;
    if(typeof obj.cfRed === 'string') CF_RED = obj.cfRed;
    if(typeof obj.cfGreen === 'string') CF_GREEN = obj.cfGreen;
    if(typeof obj.targetColor === 'string') TARGET_COLOR_DEFAULT = obj.targetColor;
    if(isFinite(obj.targetWidth)) TARGET_WIDTH_DEFAULT = Math.max(0.5, Math.min(6, parseFloat(obj.targetWidth) || TARGET_WIDTH_DEFAULT));
    if(typeof obj.targetDash === 'string') TARGET_DASH_DEFAULT = obj.targetDash;
    if(isFinite(obj.cfCol)) { CF_COL = Math.max(0, Math.min(KEYS.length-1, parseInt(obj.cfCol,10))); needsModelRecompute = true; }
    if(isFinite(obj.xCol)) { X_COL = Math.max(0, Math.min(KEYS.length-1, parseInt(obj.xCol,10))); needsModelRecompute = true; }
    if(isFinite(obj.sectionCol)) { SECTION_COL = Math.max(0, Math.min(KEYS.length-1, parseInt(obj.sectionCol,10))); needsModelRecompute = true; }
    if(Array.isArray(obj.tableCols)) { TABLE_COLS = obj.tableCols.map(function(n){ return parseInt(n,10); }).filter(function(n){ return isFinite(n); }); }
    if(Array.isArray(obj.hoverCols1)) { HOVER_COLS_1 = obj.hoverCols1.map(function(s){ return String(s).trim(); }).filter(Boolean); }
    if(Array.isArray(obj.hoverCols2)) { HOVER_COLS_2 = obj.hoverCols2.map(function(s){ return String(s).trim(); }).filter(Boolean); }

    if(typeof obj.enableMultiSection === 'boolean') ENABLE_MULTI_SECTION = obj.enableMultiSection;
    if(typeof obj.showCardTitles === 'boolean') SHOW_CARD_TITLES = obj.showCardTitles;
    if(typeof obj.showPlotTitles === 'boolean') SHOW_PLOT_TITLES = obj.showPlotTitles;
    if(typeof obj.showSectionSelector === 'boolean') SHOW_SECTION_SELECTOR = obj.showSectionSelector;

    if(typeof obj.reportTitle === 'string') REPORT_TITLE = obj.reportTitle;
    if(typeof obj.reportSubtitle === 'string') REPORT_SUBTITLE = obj.reportSubtitle;
    if(typeof obj.reportTitleBorderColor === 'string') REPORT_TITLE_BORDER_COLOR = obj.reportTitleBorderColor;
    if(isFinite(obj.cardBorderRadius)) CARD_BORDER_RADIUS = Math.max(0, Math.min(40, parseInt(obj.cardBorderRadius,10) || 0));

    // Chart definitions and per-chart state
    if(Array.isArray(obj.chartDefs) && obj.chartDefs.length){
      try{
        var nextDefs = [];
        obj.chartDefs.forEach(function(d){
          if(!d) return;
          var yCol = (d.yCol!=null) ? parseInt(d.yCol,10) : null;
          if(yCol==null || !isFinite(yCol)) return;
          yCol = Math.max(0, Math.min(KEYS.length-1, yCol));
          nextDefs.push({
            title: (d.title!=null?String(d.title):''),
            yCol: yCol,
            defaultType: null,
            defaultRegressionMethod: null,
            show: (d.show===undefined ? true : !!d.show)
          });
        });
        if(nextDefs.length){
          CHART_DEFS = nextDefs;
          CHART_COUNT = CHART_DEFS.length;
          // Ensure visibility flags for extra charts exist
          for(var ck=3; ck<=CHART_COUNT; ck++){
            if(typeof STATE['showChart'+ck] !== 'boolean') STATE['showChart'+ck] = (CHART_DEFS[ck-1].show !== false);
          }
          for(var ini=1; ini<=CHART_COUNT; ini++){
            try{ __saInitChartState(ini); }catch(_){ }
          }
          needsModelRecompute = true;
        }
      }catch(_){ }
    }
    if(Array.isArray(obj.chartState) && obj.chartState.length){
      for(var cs=0; cs<obj.chartState.length; cs++){
        var i = cs+1;
        var st = obj.chartState[cs] || {};
        if(st.chartType!=null) STATE['chartType'+i] = normChartType(st.chartType);
        if(isFinite(st.histBins)) STATE['histBins'+i] = Math.max(1, Math.min(500, parseInt(st.histBins,10) || 20));
        if(st.pointsMode!=null) STATE['pointsMode'+i] = String(st.pointsMode||'auto');
        if(typeof st.showLabels === 'boolean') STATE['showLabels'+i] = st.showLabels;
        if(typeof st.showLegend === 'boolean') STATE['showLegend'+i] = st.showLegend;
        if(st.legendPos!=null) STATE['legendPos'+i] = String(st.legendPos||'auto');
        if(st.regressionMethod!=null) STATE['regressionMethod'+i] = String(st.regressionMethod||'linear');
        if(typeof st.showRegression === 'boolean') STATE['showRegression'+i] = st.showRegression;
        if(typeof st.showCI === 'boolean') STATE['showCI'+i] = st.showCI;
        if(typeof st.showAvgX === 'boolean') STATE['showAvgX'+i] = st.showAvgX;
        if(typeof st.showAvgY === 'boolean') STATE['showAvgY'+i] = st.showAvgY;
        if(typeof st.showRegTicks === 'boolean') STATE['showRegTicks'+i] = st.showRegTicks;
      }
    }
    // Visibility for charts
    if(Array.isArray(obj.chartDefs) && obj.chartDefs.length){
      obj.chartDefs.forEach(function(d, idx){
        var i = idx+1;
        if(i===1 && typeof d.show === 'boolean') STATE.showChart1 = d.show;
        else if(i===2 && typeof d.show === 'boolean') STATE.showChart2 = d.show;
        else if(typeof d.show === 'boolean') STATE['showChart'+i] = d.show;
      });
    }

    // Persisted table filter defaults
    if(obj.tableFilter && typeof obj.tableFilter === 'object'){
      try{ STATE.tableFilter = { colLabel: obj.tableFilter.colLabel||null, min: obj.tableFilter.min||'', max: obj.tableFilter.max||'' }; }catch(_){ }
    }
    if(typeof obj.tableFilterCols === 'string') TABLE_FILTER_COLS_RAW = String(obj.tableFilterCols||'').trim() || 'all';

    if(obj.legendPos) { STATE.legendPos1 = obj.legendPos; STATE.legendPos2 = obj.legendPos; }
    if(typeof obj.showLegend === 'boolean'){ STATE.showLegend1 = STATE.showLegend2 = obj.showLegend; }
    if(typeof obj.showRegression === 'boolean'){ STATE.showRegression1 = STATE.showRegression2 = obj.showRegression; }
    if(typeof obj.showCI === 'boolean'){ STATE.showCI1 = STATE.showCI2 = obj.showCI; }
    if(typeof obj.showAvgX === 'boolean'){ STATE.showAvgX1 = STATE.showAvgX2 = obj.showAvgX; }
    if(typeof obj.showAvgY === 'boolean'){ STATE.showAvgY1 = STATE.showAvgY2 = obj.showAvgY; }
    if(typeof obj.showHistCounts === 'boolean'){ STATE.showHistCounts = obj.showHistCounts; }

    // If column mappings or chart defs changed, recompute the derived model.
    if(needsModelRecompute){
      try{ __saRecomputeModel(); }catch(_){ }
    }
  }
  function loadSavedSettings(){
    try{
      var raw = localStorage.getItem(SETTINGS_KEY);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch(e){ return null; }
  }
  function saveSettings(){
    try{ localStorage.setItem(SETTINGS_KEY, JSON.stringify(getCurrentSettings())); }catch(e){}
  }

  // Apply persisted settings before building UI
  applySettingsObj(loadSavedSettings());

  function __saTableFilterCols(){
    try{
      var raw = String(TABLE_FILTER_COLS_RAW || 'all').trim();
      if(!raw || raw.toLowerCase()==='all') return (KEYS||[]).slice();
      var tokens = raw.split(',').map(function(s){ return String(s||'').trim(); }).filter(Boolean);
      var out = [];
      var seen = {};
      tokens.forEach(function(t){
        var idx = null;
        if(/^\d+$/.test(t)) idx = parseInt(t, 10);
        if(idx!=null && isFinite(idx) && KEYS && KEYS[idx]!=null){
          var lbl = KEYS[idx];
          if(!seen[lbl]){ out.push(lbl); seen[lbl]=1; }
          return;
        }
        // Name match (case-insensitive)
        var ti = -1;
        try{
          var low = t.toLowerCase();
          for(var i=0;i<(KEYS||[]).length;i++){
            if(String(KEYS[i]||'').toLowerCase()===low){ ti=i; break; }
          }
        }catch(_){ ti=-1; }
        if(ti>=0 && KEYS[ti]!=null){
          var lbl2 = KEYS[ti];
          if(!seen[lbl2]){ out.push(lbl2); seen[lbl2]=1; }
        }
      });
      return out.length ? out : (KEYS||[]).slice();
    }catch(_){ return (KEYS||[]).slice(); }
  }

  function __saInitTableFilterFromPV(){
    try{
      var colRaw = String(TABLE_FILTER_DEFAULT_COL_RAW || '').trim();
      var minRaw = String(TABLE_FILTER_DEFAULT_MIN_RAW || '').trim();
      var maxRaw = String(TABLE_FILTER_DEFAULT_MAX_RAW || '').trim();
      if(!colRaw) return;
      if(!minRaw && !maxRaw) return;
      var idx = resolveColRef(colRaw);
      if(idx==null || !KEYS || KEYS[idx]==null) return;
      STATE.tableFilter = { colLabel: KEYS[idx], min: minRaw, max: maxRaw };
    }catch(_){ }
  }
  __saInitTableFilterFromPV();

  rootHost.innerHTML = '';

  // Shared SVG icons (aligned with BoxPlot_v2 / LineTrend_v2)
  function iconSvg(path){ return '<svg viewBox="0 0 1000 1000" aria-hidden="true" focusable="false"><path d="'+path+'"></path></svg>'; }
  var homeI='M500 150 L900 450 V850 H650 V600 H350 V850 H100 V450 Z';
  var themeI='M700 500 A200 200 0 1 1 300 500 A200 200 0 1 0 700 500 Z M500 100 A400 400 0 1 0 900 500 A250 250 0 0 1 500 100 Z';
  var linesI='M180 720 L420 520 L620 600 L820 300 M220 740 A30 30 0 1 0 221 740 M420 520 A30 30 0 1 0 421 520 M620 600 A30 30 0 1 0 621 600';
  var extI='M500 120 L860 880 H140 Z';
  var filtI='M200 200 H800 L600 520 V800 H400 V520 Z';
  var downI='M500 180 V720 M500 720 L420 640 M500 720 L580 640';
  var fullI='M140 180 L140 140 L380 140 L380 180 L180 180 L180 380 L140 380 Z M620 140 L860 140 L860 380 L820 380 L820 180 L620 180 Z M140 620 L180 620 L180 820 L380 820 L380 860 L140 860 Z M820 620 L860 620 L860 860 L620 860 L620 820 L820 820 Z';
  var zoomI='M420 200 A220 220 0 1 0 420 640 A220 220 0 1 0 420 200 Z M580 580 L820 820';
  var posI='M200 200 H800 V300 H200 Z M200 450 H350 V650 H200 Z M450 450 H800 V650 H450 Z';
  var gearI='M500 140 L500 210 L560 170 L606 214 L566 272 L640 272 L660 340 L592 380 L660 420 L640 488 L566 488 L606 546 L560 590 L500 550 L500 620 L430 590 L394 546 L434 488 L360 488 L340 420 L408 380 L340 340 L360 272 L434 272 L394 214 L430 170 Z';
  var tableI='M160 200 H840 V800 H160 Z M160 320 H840 M160 480 H840 M160 640 H840 M360 200 V800 M560 200 V800';
  var typeI='M160 820 H860 V860 H160 Z M220 820 V520 H300 V820 Z M360 820 V420 H440 V820 Z M500 820 V600 H580 V820 Z M210 520 L400 380 L540 560 L760 260';
  var targetI='M200 720 H800 M200 280 H800 M180 720 L220 720 M180 280 L220 280';
  var dotsI='M260 520 A60 60 0 1 0 261 520 M500 520 A60 60 0 1 0 501 520 M740 520 A60 60 0 1 0 741 520';
  var removeI='M260 260 L740 740 M740 260 L260 740';
  var statusI='M180 720 L420 520 L620 600 L820 300 M220 740 A30 30 0 1 0 221 740 M420 520 A30 30 0 1 0 421 520 M620 600 A30 30 0 1 0 621 600';
  var yI='M220 800 H860 M220 800 V200 M220 200 L160 260 M220 200 L280 260 M420 800 V360 M420 360 L360 420 M420 360 L480 420 M620 800 V520 M620 520 L560 580 M620 520 L680 580';
  var helpI='M500 180 A320 320 0 1 0 500 820 A320 320 0 1 0 500 180 Z M500 460 V680 M500 340 V360';

  // Report header
  var header = document.createElement('div');
  header.className = 'sa-report-header';
  try{ rootHost.style.setProperty('--sa-report-sep', String(REPORT_TITLE_BORDER_COLOR||'rgba(0,0,0,0.15)')); }catch(_){ }

  var titleWrap = document.createElement('div');
  titleWrap.style.display = 'flex';
  titleWrap.style.flexDirection = 'column';
  titleWrap.style.minWidth = '0';
  var titleEl = document.createElement('div'); titleEl.className = 'sa-report-title'; titleEl.textContent = REPORT_TITLE;
  titleWrap.appendChild(titleEl);
  var subEl = document.createElement('div'); subEl.className = 'sa-report-subtitle'; subEl.textContent = String(REPORT_SUBTITLE||'');
  if(!String(REPORT_SUBTITLE||'').trim()) subEl.style.display = 'none';
  titleWrap.appendChild(subEl);
  header.appendChild(titleWrap);
  var ctrlGroup = document.createElement('div'); ctrlGroup.className = 'sa-report-controls';
  var downloadDropdown = null;

  function togglePageFullscreen(){
    var root = document.documentElement;
    try{
      if(document.fullscreenElement) { document.exitFullscreen(); return; }
      if(root && root.requestFullscreen) root.requestFullscreen();
    }catch(e){ /* ignore */ }
  }

  function applyAllCharts(fn){
    for(var i=1;i<=CHART_COUNT;i++){
      try{ fn(i); }catch(_){ }
    }
  }
  function applyAllAndRebuild(fn){
    closeAllMenus();
    applyAllCharts(fn);
    try{ saveSettings(); }catch(_){ }
    rebuildLayout();
  }
  // Download (report-level)
  // LineTrend-like: keep report-level exports minimal
  downloadDropdown = createDropdownBtn(iconSvg(downI),'Download',[
    {label:'Table Excel', action:function(){ downloadReport('table-xlsx'); }},
    {label:'Chart PDF', action:function(){ downloadReport('chart-pdf'); }},
    {label:'Rawdata Excel', action:function(){ downloadReport('raw-xlsx'); }}
  ]);
  ctrlGroup.appendChild(downloadDropdown);

  // Settings popover (single grid icon; PV_ShowSettingsGear can hide)
  // Note: This is intentionally inserted as the first titlebar button (before Reset).
  if(SHOW_SETTINGS_GEAR) (function(){
    var btn = document.createElement('button');
    btn.className = 'sa-btn';
    btn.title = 'Settings';
    // Use the grid icon (requested) instead of a generic gear.
    btn.innerHTML = iconSvg(posI);

    function __saSetTab(popEl, tab){
      tab = String(tab||'presentation');
      STATE.settingsTab = tab;
      try{
        var tabs = popEl.querySelectorAll('[data-st-tab]');
        for(var i=0;i<tabs.length;i++){
          var el = tabs[i];
          var key = el.getAttribute('data-st-tab');
          el.classList.toggle('active', key===tab);
        }
        var bodies = popEl.querySelectorAll('[data-st-body]');
        for(var j=0;j<bodies.length;j++){
          var b = bodies[j];
          var k = b.getAttribute('data-st-body');
          b.style.display = (k===tab) ? '' : 'none';
        }
      }catch(_){ }
    }

    function __saOpenSettings(){
      var key = 'report-settings';

      // Per-chart scoping for Settings > Charts
      var scopeRaw = String(STATE.settingsChartScope || 'all');
      if(scopeRaw!=='all'){
        var nn = parseInt(scopeRaw,10);
        if(!isFinite(nn) || nn<1 || nn>CHART_COUNT) scopeRaw = 'all';
      }
      var scopeNum = (scopeRaw==='all') ? null : parseInt(scopeRaw,10);

      function getScoped(keyBase, fallback){
        if(scopeNum){
          var v = STATE[keyBase+scopeNum];
          return (v===undefined) ? fallback : v;
        }
        return fallback;
      }

      // Snapshot scoped values (either chart-specific or "all charts")
      var curType = scopeNum ? String(STATE['chartType'+scopeNum] || DEFAULT_CHART_TYPE || 'scatter') : String(STATE.chartTypeAll || '').trim();
      if(!curType){ curType = String(STATE['chartType1'] || DEFAULT_CHART_TYPE || 'scatter'); }
      var curBins = scopeNum ? parseInt(STATE['histBins'+scopeNum] || 10, 10) : parseInt(STATE.histBinsAll || STATE['histBins1'] || 10, 10);
      if(!isFinite(curBins) || curBins<1) curBins = 10;
      var pm = scopeNum ? String(STATE['pointsMode'+scopeNum] || 'auto') : String(STATE.pointsModeAll || STATE['pointsMode1'] || 'auto');
      if(pm!=='auto' && pm!=='none' && pm!=='all') pm='auto';
      var lbl = scopeNum ? !!STATE['showLabels'+scopeNum] : ((STATE.labelsAll!=null) ? !!STATE.labelsAll : !!STATE['showLabels1']);
      var lshow = scopeNum ? !!STATE['showLegend'+scopeNum] : ((STATE.legendAll!=null) ? !!STATE.legendAll : !!STATE['showLegend1']);
      var lpos = scopeNum ? String(STATE['legendPos'+scopeNum] || 'auto') : String(STATE.legendPosAll || STATE['legendPos1'] || 'auto');
      if(!lpos) lpos='auto';
      var outMode = (STATE.excludeOutliersAll!=null) ? (STATE.excludeOutliersAll?'exclude':'show') : (STATE.excludeOutliers?'exclude':'show');
      var hov = (STATE.hoverCellAll!=null) ? (STATE.hoverCellAll?'on':'off') : (STATE.showCell?'on':'off');
      var om = String(STATE.outlierMethod || 'kmeans');
      if(om!=='kmeans' && om!=='distance' && om!=='hierarchical') om='kmeans';
      var rm = scopeNum ? String(STATE['regressionMethod'+scopeNum] || 'linear') : String(STATE.regressionAll || STATE['regressionMethod1'] || 'linear');
      if(rm!=='none' && rm!=='linear') rm='linear';
      var showReg = scopeNum ? !!STATE['showRegression'+scopeNum] : ((STATE.showRegressionAll!=null) ? !!STATE.showRegressionAll : !!STATE['showRegression1']);
      var showCI = scopeNum ? !!STATE['showCI'+scopeNum] : ((STATE.showCIAll!=null) ? !!STATE.showCIAll : !!STATE['showCI1']);
      var showXM = scopeNum ? !!STATE['showAvgX'+scopeNum] : ((STATE.showAvgXAll!=null) ? !!STATE.showAvgXAll : !!STATE['showAvgX1']);
      var showYM = scopeNum ? !!STATE['showAvgY'+scopeNum] : ((STATE.showAvgYAll!=null) ? !!STATE.showAvgYAll : !!STATE['showAvgY1']);
      var showTicks = scopeNum ? !!STATE['showRegTicks'+scopeNum] : ((STATE.showRegTicksAll!=null) ? !!STATE.showRegTicksAll : !!STATE['showRegTicks1']);

      var showBins = (curType==='histogram' || curType==='hist+kde');

      var preset = String(STATE.gridPreset||'').trim();
      var presetSel = preset ? preset : 'custom';

      function tabBtn(id, label, title){
        return '<button type="button" class="item" data-st-tab="'+id+'" title="'+escapeHtml(title||'')+'" style="flex:1;min-width:0">'+escapeHtml(label)+'</button>';
      }
      function seg2(name, on, label){
        return '<div class="row" style="justify-content:space-between">'
          + '<div style="opacity:.9">'+escapeHtml(label)+'</div>'
          + '<div>'
          + '<label class="seg"><input type="radio" name="'+name+'" value="1" '+(on?'checked':'')+'><span>On</span></label>'
          + '<label class="seg"><input type="radio" name="'+name+'" value="0" '+(!on?'checked':'')+'><span>Off</span></label>'
          + '</div></div>';
      }

      function __saIdxSet(arr){
        var set = {};
        try{
          (arr||[]).forEach(function(v){
            var idx = resolveColRef(v);
            if(idx!=null && isFinite(idx)) set[idx]=1;
          });
        }catch(_){ }
        return set;
      }
      function __saBuildColOptions(selectedIdx){
        var out='';
        for(var i=0;i<(KEYS||[]).length;i++){
          var lbl = String(KEYS[i]||'');
          out += '<option value="'+i+'" '+(i===selectedIdx?'selected':'')+'>'+escapeHtml(lbl)+'</option>';
        }
        return out;
      }

      var html='';
      html += '<div class="group sa-st-tabs-wrap">';
      html += '<div class="sa-st-tabs">'
        + tabBtn('presentation','Presentation','Show/hide table & charts; presets')
        + tabBtn('data','Data','Map dataset columns to table/charts; manage charts')
        + tabBtn('layout','Layout','Layout, spacing, heights, rows')
        + tabBtn('style','Style','Report title + colors + formatting')
        + tabBtn('targets','Targets','Target line defaults')
        + tabBtn('charts','Charts','Type, points/labels/legend, stats')
        + tabBtn('table','Table','Table filter defaults')
        + tabBtn('advanced','Advanced','Multi-section, CF, and PV-like toggles')
        + tabBtn('help','Help','How to use this template')
        + '</div>';
      html += '</div>';

      // Presentation
      html += '<div data-st-body="presentation">';
      html += '<div class="group">';
      html += '<div class="hdr" style="margin-top:6px" title="Preset visibility for table/charts">Grid preset</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="Choose a preset layout. Use Custom to manually toggle.">Preset</div>'
        + '<select id="st-preset" style="flex:1;min-width:160px">'
        + '<option value="custom" '+(presetSel==='custom'?'selected':'')+'>Custom</option>'
        + '<option value="T" '+(presetSel==='T'?'selected':'')+'>Table only</option>'
        + '<option value="T1" '+(presetSel==='T1'?'selected':'')+'>Table + 1 chart</option>'
        + '<option value="T2" '+(presetSel==='T2'?'selected':'')+'>Table + 2 charts</option>'
        + '</select>'
        + '</div>';
      html += '<div class="row" style="gap:12px;flex-wrap:wrap" title="These apply when preset is Custom">'
        + '<label><input id="st-show-table" type="checkbox" '+(STATE.showTable?'checked':'')+'> Table</label>'
        + '<label><input id="st-show-c1" type="checkbox" '+(STATE.showChart1?'checked':'')+'> Chart 1</label>'
        + '<label><input id="st-show-c2" type="checkbox" '+(STATE.showChart2?'checked':'')+'> Chart 2</label>'
        + '</div>';
      html += '<div class="sep"></div>';
      html += '<div class="hdr" title="Theme affects menu/table styling and chart theme">Theme</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-theme" value="light" '+(STATE.theme==='light'?'checked':'')+'><span>Light</span></label>'
        + '<label class="seg"><input type="radio" name="st-theme" value="paper" '+(STATE.theme==='paper'?'checked':'')+'><span>Paper</span></label>'
        + '<label class="seg"><input type="radio" name="st-theme" value="dark" '+(STATE.theme==='dark'?'checked':'')+'><span>Dark</span></label>'
        + '</div>';
      html += '</div>';
      html += '</div>';

      // Data mapping
      html += '<div data-st-body="data">';
      html += '<div class="group">';
      html += '<div class="hdr" style="margin-top:6px" title="Choose which dataset columns map to sectioning, x-axis, conditional formatting and table columns">Data mapping</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="Section column used when PV_EnableMultiSection=1">Section</div>'
        + '<select id="dm-section" style="flex:1;min-width:160px">'
        + __saBuildColOptions(Math.max(0, Math.min(KEYS.length-1, parseInt(SECTION_COL,10)||0)))
        + '</select>'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="X-axis column for all charts">X axis</div>'
        + '<select id="dm-x" style="flex:1;min-width:160px">'
        + __saBuildColOptions(Math.max(0, Math.min(KEYS.length-1, parseInt(X_COL,10)||0)))
        + '</select>'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="Conditional formatting column (used for red/green compare)">CF col</div>'
        + '<select id="dm-cf" style="flex:1;min-width:160px">'
        + __saBuildColOptions(Math.max(0, Math.min(KEYS.length-1, parseInt(CF_COL,10)||0)))
        + '</select>'
        + '</div>';

      // Table columns (multi-select)
      var tblSet = __saIdxSet(TABLE_COLS||[]);
      html += '<div class="hdr" style="margin-top:10px" title="Select which columns are visible in the Data Table">Table columns</div>';
      html += '<select id="dm-table-cols" multiple size="8" style="width:100%;min-height:150px">';
      for(var ti=0;ti<(KEYS||[]).length;ti++){
        var tLbl = String(KEYS[ti]||'');
        html += '<option value="'+ti+'" '+(tblSet[ti]?'selected':'')+'>'+escapeHtml(tLbl)+'</option>';
      }
      html += '</select>';
      html += '<div style="opacity:.75;margin-top:6px">Tip: Ctrl/Shift to multi-select. This affects the table only.</div>';

      // Hover columns
      html += '<div class="hdr" style="margin-top:10px" title="Columns shown in the chart hover tooltip">Hover columns</div>';
      var h1Set = __saIdxSet(HOVER_COLS_1||[]);
      var h2Set = __saIdxSet(HOVER_COLS_2||[]);
      html += '<div class="row" style="gap:10px;flex-wrap:wrap">'
        + '<div style="flex:1;min-width:160px">'
        + '<div style="opacity:.85;margin-bottom:4px">Chart 1</div>'
        + '<select id="dm-hov1" multiple size="6" style="width:100%;min-height:120px">';
      for(var hi=0;hi<(KEYS||[]).length;hi++){
        var hLbl = String(KEYS[hi]||'');
        html += '<option value="'+hi+'" '+(h1Set[hi]?'selected':'')+'>'+escapeHtml(hLbl)+'</option>';
      }
      html += '</select></div>';
      html += '<div style="flex:1;min-width:160px">'
        + '<div style="opacity:.85;margin-bottom:4px">Chart 2</div>'
        + '<select id="dm-hov2" multiple size="6" style="width:100%;min-height:120px">';
      for(var hj=0;hj<(KEYS||[]).length;hj++){
        var hLbl2 = String(KEYS[hj]||'');
        html += '<option value="'+hj+'" '+(h2Set[hj]?'selected':'')+'>'+escapeHtml(hLbl2)+'</option>';
      }
      html += '</select></div>';
      html += '</div>';

      // Charts list
      html += '<div class="sep"></div>';
      html += '<div class="hdr" title="Edit chart titles and Y-columns (one chart per Y-column)">Charts</div>';
      for(var c=1;c<=CHART_COUNT;c++){
        var defC = CHART_DEFS[c-1] || {};
        var cTitle = (defC.title!=null?String(defC.title):('Chart '+c));
        var showC = (function(){
          if(c===1) return !!STATE.showChart1;
          if(c===2) return !!STATE.showChart2;
          if(typeof STATE['showChart'+c]==='boolean') return !!STATE['showChart'+c];
          return (defC.show !== false);
        })();
        var canRemove = (CHART_COUNT>1 && c>=2);
        html += '<div class="row" style="gap:8px;align-items:center;flex-wrap:wrap">'
          + '<label style="min-width:70px"><input id="dm-show-'+c+'" type="checkbox" '+(showC?'checked':'')+'> Show</label>'
          + '<input id="dm-title-'+c+'" type="text" value="'+escapeHtml(cTitle)+'" style="flex:1;min-width:160px" title="Chart title">'
          + (canRemove?('<button class="item" type="button" data-act="dm-remove-chart" data-chart="'+c+'" style="flex:0 0 auto" title="Remove this chart">Remove</button>'):'')
          + '</div>';
        html += '<div class="row" style="gap:8px;align-items:center">'
          + '<div style="min-width:92px" title="Y-axis column">Y axis</div>'
          + '<select id="dm-y-'+c+'" style="flex:1;min-width:160px">'
          + __saBuildColOptions(Math.max(0, Math.min(KEYS.length-1, parseInt(defC.yCol,10)||0)))
          + '</select>'
          + '</div>';
        html += '<div class="sep" style="margin:8px 0"></div>';
      }

      // Add chart (optional)
      html += '<div class="hdr" style="margin-top:6px" title="Add a new chart (will appear as a new card)">Add chart</div>';
      html += '<div class="row" style="gap:8px;align-items:center;flex-wrap:wrap">'
        + '<select id="dm-add-y" style="flex:1;min-width:160px" title="Y-axis column for the new chart">'
        + __saBuildColOptions(0)
        + '</select>'
        + '<input id="dm-add-title" type="text" placeholder="Chart title" style="flex:1;min-width:160px">'
        + '<button class="item" type="button" data-act="dm-add-chart" style="flex:0 0 auto">Add</button>'
        + '</div>';
      html += '<div style="opacity:.75;margin-top:6px">Adding charts is supported, but grid presets only control chart1/chart2. Use Custom for 3+ charts.</div>';
      html += '</div>';
      html += '</div>';

      // Layout
      html += '<div data-st-body="layout">';
      html += '<div class="group">';
      html += '<div class="hdr" style="margin-top:6px">Layout</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="ls-layout" value="H" '+((LAYOUT||'H')==='H'?'checked':'')+'><span>Horizontal</span></label>'
        + '<label class="seg"><input type="radio" name="ls-layout" value="V" '+((LAYOUT||'H')==='V'?'checked':'')+'><span>Vertical</span></label>'
        + '</div>';
      html += '<div class="hdr" style="margin-top:10px">Widths</div>';
      html += '<div class="row" style="gap:10px;align-items:center">'
        + '<div style="min-width:92px" title="Horizontal layout only: 1 or 2 charts per row">Charts/row</div>'
        + '<input id="ls-cpr" type="number" min="1" max="2" step="1" value="'+escapeHtml(String(CHARTS_PER_ROW||DEFAULTS.chartsPerRow||2))+'" style="width:90px">'
        + '</div>';
      html += '<div class="hdr" style="margin-top:10px">Spacing</div>';
      html += '<div class="row" style="gap:8px">'
        + '<div style="min-width:92px" title="Gap between cards (pixels)">Grid gap (px)</div>'
        + '<input id="ls-gap" type="number" min="0" max="40" step="1" value="'+escapeHtml(String(GRID_GAP||DEFAULTS.gridGap||6))+'" style="width:90px">'
        + '</div>';
      html += '<div class="hdr" style="margin-top:10px">Chart</div>';
      html += '<div class="row" style="gap:10px;align-items:center">'
        + '<div style="min-width:92px" title="Chart card height in pixels (when FillHeight=0 or Auto size)">Height (px)</div>'
        + '<input id="ls-chart" type="number" min="220" max="1400" step="10" value="'+escapeHtml(String(CHART_HEIGHT||DEFAULTS.chartHeight||500))+'" style="width:90px">'
        + '</div>';
      html += '<div class="hdr" style="margin-top:10px">Table</div>';
      html += '<div class="row" style="gap:10px;align-items:center">'
        + '<div style="min-width:92px" title="Approx visible table rows before scrolling">Rows</div>'
        + '<input id="ls-rows" type="number" min="1" max="200" step="1" value="'+escapeHtml(String(TABLE_ROWS||DEFAULTS.tableRows||18))+'" style="width:90px">'
        + '<div style="opacity:.75">(scroll after)</div>'
        + '</div>';
      html += '<div class="row" style="margin-top:10px">'
        + '<label title="When enabled, sizes table/charts to fit available height"><input id="ls-autosize" type="checkbox" '+(STATE.autoSize?'checked':'')+'> Auto size</label>'
        + '</div>';
      html += '</div>';
      html += '</div>';

      // Charts
      html += '<div data-st-body="charts">';
      html += '<div class="group">';
      html += '<div class="hdr" style="margin-top:6px">Applies to</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="Choose whether chart settings apply to one chart or all charts">Chart</div>'
        + '<select id="st-chart-scope" style="flex:1;min-width:160px">'
        + '<option value="all" '+(scopeRaw==='all'?'selected':'')+'>All charts</option>';
      for(var sc=1; sc<=CHART_COUNT; sc++){
        var defSc = CHART_DEFS[sc-1] || {};
        var lblSc = (defSc.title!=null?String(defSc.title):('Chart '+sc));
        html += '<option value="'+sc+'" '+(String(scopeRaw)===String(sc)?'selected':'')+'>Chart '+sc+' - '+escapeHtml(lblSc)+'</option>';
      }
      html += '</select>'
        + '</div>';

      html += '<div class="hdr" style="margin-top:6px">Type</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-ct" value="scatter" '+(curType==='scatter'?'checked':'')+'><span>Scatter</span></label>'
        + '<label class="seg"><input type="radio" name="st-ct" value="histogram" '+(curType==='histogram'?'checked':'')+'><span>Histogram</span></label>'
        + '<label class="seg"><input type="radio" name="st-ct" value="hist+kde" '+(curType==='hist+kde'?'checked':'')+'><span>Hist + KDE</span></label>'
        + '</div>';
      if(showBins){
        html += '<div class="hdr" style="margin-top:10px">Histogram bins</div>';
        html += '<div class="row" style="gap:6px;flex-wrap:wrap">'
          + '<label class="seg"><input type="radio" name="st-bins" value="10" '+(curBins===10?'checked':'')+'><span>10</span></label>'
          + '<label class="seg"><input type="radio" name="st-bins" value="20" '+(curBins===20?'checked':'')+'><span>20</span></label>'
          + '<label class="seg"><input type="radio" name="st-bins" value="30" '+(curBins===30?'checked':'')+'><span>30</span></label>'
          + '</div>';
        html += '<div class="row" style="align-items:center;margin-top:6px">'
          + '<input id="st-bins-custom" type="number" min="1" step="1" value="'+escapeHtml(String(curBins))+'" style="width:90px;flex:0 0 90px">'
          + '<button class="item" data-act="st-bins-apply" type="button" style="flex:1">Apply</button>'
          + '<button class="item" data-act="st-bins-reset" type="button" style="flex:1">Reset</button>'
          + '</div>';
        html += '<div class="row" style="margin-top:8px">'
          + '<label><input type="checkbox" id="st-hist-counts" '+(STATE.showHistCounts?'checked':'')+'> Show Bar Counts</label>'
          + '</div>';
      }else{
        html += '<div style="opacity:.75;margin-top:10px">Histogram settings appear when Type is Histogram.</div>';
      }

      html += '<div class="sep"></div>';
      html += '<div class="hdr">Points</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-pm" value="auto" '+(pm==='auto'?'checked':'')+'><span>Auto</span></label>'
        + '<label class="seg"><input type="radio" name="st-pm" value="none" '+(pm==='none'?'checked':'')+'><span>None</span></label>'
        + '<label class="seg"><input type="radio" name="st-pm" value="all" '+(pm==='all'?'checked':'')+'><span>All</span></label>'
        + '</div>';
      html += '<div class="hdr">Labels</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-lbl" value="off" '+(!lbl?'checked':'')+'><span>Off</span></label>'
        + '<label class="seg"><input type="radio" name="st-lbl" value="on" '+(lbl?'checked':'')+'><span>On</span></label>'
        + '</div>';
      html += '<div class="hdr">Legend</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-lshow" value="1" '+(lshow?'checked':'')+'><span>Show</span></label>'
        + '<label class="seg"><input type="radio" name="st-lshow" value="0" '+(!lshow?'checked':'')+'><span>Hide</span></label>'
        + '</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-lpos" value="auto" '+(lpos==='auto'?'checked':'')+'><span>Auto</span></label>'
        + '<label class="seg"><input type="radio" name="st-lpos" value="top" '+(lpos==='top'?'checked':'')+'><span>Top</span></label>'
        + '<label class="seg"><input type="radio" name="st-lpos" value="bottom" '+(lpos==='bottom'?'checked':'')+'><span>Bottom</span></label>'
        + '</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-lpos" value="left" '+(lpos==='left'?'checked':'')+'><span>Left</span></label>'
        + '<label class="seg"><input type="radio" name="st-lpos" value="right" '+(lpos==='right'?'checked':'')+'><span>Right</span></label>'
        + '</div>';

      html += '<div class="hdr">Outliers</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-out" value="show" '+(outMode==='show'?'checked':'')+'><span>Show</span></label>'
        + '<label class="seg"><input type="radio" name="st-out" value="exclude" '+(outMode==='exclude'?'checked':'')+'><span>Exclude</span></label>'
        + '</div>';

      html += '<div class="hdr">Hover</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-hov" value="on" '+(hov==='on'?'checked':'')+'><span>Cell On</span></label>'
        + '<label class="seg"><input type="radio" name="st-hov" value="off" '+(hov==='off'?'checked':'')+'><span>Cell Off</span></label>'
        + '</div>';

      html += '<div class="hdr">Detection</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-om" value="kmeans" '+(om==='kmeans'?'checked':'')+'><span>KMeans</span></label>'
        + '<label class="seg"><input type="radio" name="st-om" value="distance" '+(om==='distance'?'checked':'')+'><span>Distance</span></label>'
        + '<label class="seg"><input type="radio" name="st-om" value="hierarchical" '+(om==='hierarchical'?'checked':'')+'><span>Hier</span></label>'
        + '</div>';

      html += '<div class="sep"></div>';
      html += '<div class="hdr">Regression</div>';
      html += '<div class="row">'
        + '<label class="seg"><input type="radio" name="st-rm" value="none" '+(rm==='none'?'checked':'')+'><span>Off</span></label>'
        + '<label class="seg"><input type="radio" name="st-rm" value="linear" '+(rm!=='none'?'checked':'')+'><span>Regression</span></label>'
        + '</div>';
      html += '<div class="hdr">Display</div>';
      html += '<div class="row">'
        + '<button class="item" type="button" data-act="st-disp-none">None</button>'
        + '<button class="item" type="button" data-act="st-disp-all">All</button>'
        + '</div>';
      html += seg2('st-ov_reg', showReg, 'Regression line');
      html += seg2('st-ov_ticks', showTicks, 'Tick marks');
      html += seg2('st-ov_ci', showCI, '95% CI band');
      html += seg2('st-ov_xm', showXM, 'X mean');
      html += seg2('st-ov_ym', showYM, 'Y mean');
      html += '</div>';
      html += '</div>';

      // Style
      html += '<div data-st-body="style">';
      html += '<div class="group">';
      html += '<div class="hdr" style="margin-top:6px">Report</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="Report title">Title</div>'
        + '<input id="st-rt" type="text" value="'+escapeHtml(String(REPORT_TITLE||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="Report subtitle (optional)">Subtitle</div>'
        + '<input id="st-rs" type="text" value="'+escapeHtml(String(REPORT_SUBTITLE||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="Separator / underline color under the report header">Title line</div>'
        + '<input id="st-rb" type="text" value="'+escapeHtml(String(REPORT_TITLE_BORDER_COLOR||''))+'" style="flex:1;min-width:160px" placeholder="rgba(0,0,0,0.15)">'
        + '</div>';
      html += '<div class="sep"></div>';
      html += '<div class="hdr">Formatting</div>';
      html += '<div class="row" style="gap:10px;align-items:center;flex-wrap:wrap">'
        + '<div style="min-width:92px" title="Chart title font size">Title font</div>'
        + '<input id="st-tfs" type="number" min="10" max="32" step="1" value="'+escapeHtml(String(TITLE_FONT_SIZE||16))+'" style="width:90px">'
        + '<div style="min-width:92px" title="Numeric decimals fallback (0-6)">Decimals</div>'
        + '<input id="st-dec" type="number" min="0" max="6" step="1" value="'+escapeHtml(String(AXIS_DEC||2))+'" style="width:90px">'
        + '</div>';
      html += '<div class="row" style="gap:10px;align-items:center;flex-wrap:wrap">'
        + '<div style="min-width:92px" title="Extra buffer added when fixing axis ranges">Axis buffer</div>'
        + '<input id="st-abuf" type="number" min="0" max="100" step="1" value="'+escapeHtml(String(AXIS_FIXED_BUFFER||5))+'" style="width:90px">'
        + '<div style="min-width:92px" title="X-axis tick density multiplier">X nticks</div>'
        + '<input id="st-xnt" type="number" min="1" max="10" step="1" value="'+escapeHtml(String(X_NTICKS_MULT||1))+'" style="width:90px">'
        + '<div style="min-width:92px" title="Scales fonts in fullscreen mode">FS font</div>'
        + '<input id="st-fsfs" type="number" min="0.6" max="2.2" step="0.1" value="'+escapeHtml(String(FULLSCREEN_FONT_SCALE||1.2))+'" style="width:90px">'
        + '</div>';
      html += '<div class="row" style="gap:10px;align-items:center;flex-wrap:wrap">'
        + '<div style="min-width:92px" title="Card corner rounding">Card radius</div>'
        + '<input id="st-cr" type="number" min="0" max="40" step="1" value="'+escapeHtml(String(CARD_BORDER_RADIUS||12))+'" style="width:90px">'
        + '<div style="min-width:92px" title="95% CI band opacity (0..1)">CI opacity</div>'
        + '<input id="st-cio" type="number" min="0" max="1" step="0.05" value="'+escapeHtml(String(BAND_OPACITY))+'" style="width:90px">'
        + '</div>';
      html += '<div class="sep"></div>';
      html += '<div class="hdr">Colors</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px">Normal</div>'
        + '<input id="st-col-n" type="text" value="'+escapeHtml(String(NORMAL_COLOR||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px">Outlier</div>'
        + '<input id="st-col-o" type="text" value="'+escapeHtml(String(OUTLIER_COLOR||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px">Trend</div>'
        + '<input id="st-col-t" type="text" value="'+escapeHtml(String(TREND_COLOR||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px">CI band</div>'
        + '<input id="st-col-ci" type="text" value="'+escapeHtml(String(BAND_COLOR||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px">Hover</div>'
        + '<input id="st-col-h" type="text" value="'+escapeHtml(String(HOVER_COLOR||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px">Hover bg</div>'
        + '<input id="st-col-hb" type="text" value="'+escapeHtml(String(HOVER_BG||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '<div class="row" style="margin-top:8px">'
        + '<label title="Color outliers differently from normal points"><input id="st-outcol" type="checkbox" '+(OUTLIER_COLORED?'checked':'')+'> Outlier colored</label>'
        + '</div>';
      html += '<div class="sep"></div>';
      html += '<div class="hdr">Conditional formatting</div>';
      html += '<div class="row" style="margin-top:4px">'
        + '<label title="Enable conditional formatting on table rows"><input id="st-cfen" type="checkbox" '+(CF_ENABLED?'checked':'')+'> Enable CF</label>'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px">CF Red</div>'
        + '<input id="st-cfr" type="text" value="'+escapeHtml(String(CF_RED||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px">CF Green</div>'
        + '<input id="st-cfg" type="text" value="'+escapeHtml(String(CF_GREEN||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '</div>';
      html += '</div>';

      // Targets
      html += '<div data-st-body="targets">';
      html += '<div class="group">';
      html += '<div class="hdr" style="margin-top:6px" title="Default target line styling (used by chart Target tool)">Target defaults</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px">Color</div>'
        + '<input id="st-tcol" type="text" value="'+escapeHtml(String(TARGET_COLOR_DEFAULT||''))+'" style="flex:1;min-width:160px">'
        + '</div>';
      html += '<div class="row" style="gap:10px;align-items:center;flex-wrap:wrap">'
        + '<div style="min-width:92px">Width</div>'
        + '<input id="st-tw" type="number" min="0.5" max="6" step="0.1" value="'+escapeHtml(String(TARGET_WIDTH_DEFAULT||1.5))+'" style="width:90px">'
        + '<div style="min-width:92px">Dash</div>'
        + '<select id="st-td" style="flex:1;min-width:160px">'
        + '<option value="solid" '+(String(TARGET_DASH_DEFAULT)==='solid'?'selected':'')+'>solid</option>'
        + '<option value="dash" '+(String(TARGET_DASH_DEFAULT)==='dash'?'selected':'')+'>dash</option>'
        + '<option value="dot" '+(String(TARGET_DASH_DEFAULT)==='dot'?'selected':'')+'>dot</option>'
        + '<option value="dashdot" '+(String(TARGET_DASH_DEFAULT)==='dashdot'?'selected':'')+'>dashdot</option>'
        + '</select>'
        + '</div>';
      html += '<div style="opacity:.75;margin-top:6px">Targets are stored per chart when you use the chart toolbar.</div>';
      html += '</div>';
      html += '</div>';

      // Table
      html += '<div data-st-body="table">';
      html += '<div class="group">';
      html += '<div class="hdr" style="margin-top:6px" title="Sets the default Table Filter (between min/max)">Table Filter</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="Which columns are allowed in the Table Filter dropdown. Use all, or comma-separated indices/names.">Allowed cols</div>'
        + '<input id="st-tf-cols" type="text" value="'+escapeHtml(String(TABLE_FILTER_COLS_RAW||'all'))+'" style="flex:1;min-width:160px" placeholder="all">'
        + '</div>';
      var tfCols = [];
      try{ tfCols = __saTableFilterCols(); }catch(_){ tfCols = (KEYS||[]).slice(); }
      var curTfCol = (STATE.tableFilter && STATE.tableFilter.colLabel) ? String(STATE.tableFilter.colLabel) : '';
      var tfMin = (STATE.tableFilter && STATE.tableFilter.min!=null) ? String(STATE.tableFilter.min) : '';
      var tfMax = (STATE.tableFilter && STATE.tableFilter.max!=null) ? String(STATE.tableFilter.max) : '';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="Column to filter (can be hidden from the table)">Column</div>'
        + '<select id="st-tf-col" style="flex:1;min-width:160px">'
        + '<option value="">(none)</option>';
      (tfCols||[]).forEach(function(lbl){
        var s = String(lbl||'');
        html += '<option value="'+escapeHtml(s)+'" '+(s===curTfCol?'selected':'')+'>'+escapeHtml(s)+'</option>';
      });
      html += '</select>';
      html += '</div>';
      html += '<div class="row" style="gap:8px;align-items:center">'
        + '<div style="min-width:92px" title="Between minimum value">Min</div>'
        + '<input id="st-tf-min" type="text" value="'+escapeHtml(tfMin)+'" style="width:90px">'
        + '<div style="min-width:52px" title="Between maximum value">Max</div>'
        + '<input id="st-tf-max" type="text" value="'+escapeHtml(tfMax)+'" style="width:90px">'
        + '</div>';
      html += '<div style="opacity:.75;margin-top:6px">Filter applies to the table only (charts are unchanged).</div>';
      html += '</div>';
      html += '</div>';

      // Advanced
      html += '<div data-st-body="advanced">';
      html += '<div class="group">';
      html += '<div class="hdr" style="margin-top:6px">PV-like toggles</div>';
      html += '<div class="row" style="gap:12px;flex-wrap:wrap">'
        + '<label title="Enable section splitting for All sections"><input id="ad-ms" type="checkbox" '+(ENABLE_MULTI_SECTION?'checked':'')+'> Multi-section</label>'
        + '<label title="Show card titles"><input id="ad-sct" type="checkbox" '+(SHOW_CARD_TITLES?'checked':'')+'> Card titles</label>'
        + '<label title="Show plot titles inside charts"><input id="ad-spt" type="checkbox" '+(SHOW_PLOT_TITLES?'checked':'')+'> Plot titles</label>'
        + '</div>';
      html += '<div class="sep"></div>';
      html += '<div class="hdr">Fill height</div>';
      html += '<div style="opacity:.8">PV_FillHeight is currently <b>'+(FILL_HEIGHT?'On':'Off')+'</b>. Changing this usually requires a dashboard refresh.</div>';
      html += '</div>';
      html += '</div>';

      // Help
      html += '<div data-st-body="help">';
      html += '<div class="group">';
      html += '<div style="max-width:340px">';
      html += '<div style="opacity:.85">This template is PV-driven and uses a single Settings menu for configuration.</div>';
      html += '<div class="sep"></div>';
      html += '<div style="font-weight:700;margin-top:2px;margin-bottom:6px">Report controls</div>';
      html += '<div>Settings: presentation, layout, charts, table filter.</div>';
      html += '<div>Reset: resets chart interactions to defaults.</div>';
      html += '<div>Download: exports table + charts.</div>';
      html += '<div>Fullscreen: expands the full report area.</div>';
      html += '<div class="sep"></div>';
      html += '<div style="font-weight:700;margin-top:2px;margin-bottom:6px">Sizing</div>';
      html += '<div><b>PV_FillHeight=1</b> makes table and charts fill available height.</div>';
      html += '<div class="sep"></div>';
      html += '<div style="font-weight:700;margin-top:2px;margin-bottom:6px">Chart toolbar</div>';
      html += '<div>Each chart still has its own toolbar for chart-specific controls.</div>';
      html += '<div style="margin-top:8px;opacity:.85">Tip: press <b>Esc</b> to close menus.</div>';
      html += '</div>';
      html += '</div>';
      html += '</div>';

      // Global apply/reset buttons
      html += '<div class="group sa-st-footer">';
      html += '<div class="row" style="margin-top:4px">'
        + '<button class="item" data-act="st-apply" type="button" style="flex:1">Apply</button>'
        + '<button class="item" data-act="st-reset" type="button" style="flex:1">Reset</button>'
        + '</div>';
      html += '</div>';

      __saOpenMenuPop(key, btn, 'Settings', html, function(popEl){
        try{ popEl.classList.add('sa-settings-pop'); }catch(_){ }
        // Activate last-used tab
        __saSetTab(popEl, STATE.settingsTab || 'presentation');
        // Mark the active tab button
        try{
          var firstActive = popEl.querySelector('[data-st-tab="'+(STATE.settingsTab||'presentation')+'"]');
          if(firstActive) firstActive.classList.add('active');
        }catch(_){ }

        popEl.addEventListener('click', function(ev){
          var t = ev && ev.target;
          if(!t) return;
          var tab = t.getAttribute && t.getAttribute('data-st-tab');
          if(tab){
            ev.preventDefault();
            __saSetTab(popEl, tab);
            return;
          }

          var act = t.getAttribute && t.getAttribute('data-act');
          if(!act) return;

          // Chart-only quick actions
          if(act==='dm-add-chart'){
            try{
              var yEl = popEl.querySelector('#dm-add-y');
              var tEl = popEl.querySelector('#dm-add-title');
              var y = yEl ? parseInt(String(yEl.value||'').trim(),10) : NaN;
              if(!isFinite(y)) return;
              y = Math.max(0, Math.min(KEYS.length-1, y));
              var title = tEl ? String(tEl.value||'').trim() : '';
              if(!title) title = 'Chart ' + (CHART_DEFS.length + 1);
              // Switch to Custom to ensure new charts can be shown.
              STATE.gridPreset = '';
              CHART_DEFS.push({ title:title, yCol:y, defaultType: DEFAULT_CHART_TYPE, defaultRegressionMethod:'linear', show:true });
              CHART_COUNT = CHART_DEFS.length;
              __saInitChartState(CHART_COUNT);
              if(CHART_COUNT>=3) STATE['showChart'+CHART_COUNT] = true;
              __saRecomputeModel();
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
              setTimeout(function(){ try{ STATE.settingsTab='data'; btn.click(); }catch(_){} }, 0);
            }catch(_){ }
            return;
          }
          if(act==='dm-remove-chart'){
            try{
              var idx = parseInt(String(t.getAttribute('data-chart')||'').trim(),10);
              if(!isFinite(idx) || idx<1 || idx>CHART_COUNT) return;
              if(CHART_COUNT<=1) return;

              var oldCount = CHART_COUNT;

              // Capture existing show flags then shift them after removal.
              function getShow(i){
                if(i===1) return !!STATE.showChart1;
                if(i===2) return !!STATE.showChart2;
                if(typeof STATE['showChart'+i] === 'boolean') return !!STATE['showChart'+i];
                return true;
              }
              var showArr = [];
              for(var si=1; si<=oldCount; si++) showArr[si] = getShow(si);
              for(var sj=idx; sj<=oldCount-1; sj++) showArr[sj] = showArr[sj+1];

              // Remove def
              CHART_DEFS.splice(idx-1, 1);
              CHART_COUNT = CHART_DEFS.length;

              // Shift per-chart state keys down
              var stKeys = ['chartType','histBins','pointsMode','showLabels','showLegend','legendPos','regressionMethod','showRegression','showCI','showAvgX','showAvgY','showRegTicks'];
              for(var k=idx; k<=oldCount-1; k++){
                for(var kk=0; kk<stKeys.length; kk++){
                  var base = stKeys[kk];
                  STATE[base+k] = STATE[base+(k+1)];
                }
              }
              for(var kk2=0; kk2<stKeys.length; kk2++){
                try{ delete STATE[stKeys[kk2]+oldCount]; }catch(_){ STATE[stKeys[kk2]+oldCount] = undefined; }
              }

              // Apply shifted show flags
              STATE.showChart1 = !!showArr[1];
              if(CHART_COUNT>=2) STATE.showChart2 = !!showArr[2];
              else STATE.showChart2 = false;
              for(var ss=3; ss<=CHART_COUNT; ss++) STATE['showChart'+ss] = !!showArr[ss];
              try{ delete STATE['showChart'+(oldCount)]; }catch(_){ }

              // Clamp scope selector if needed
              try{
                var raw = String(STATE.settingsChartScope||'all');
                if(raw!=='all'){
                  var nn = parseInt(raw,10);
                  if(!isFinite(nn) || nn<1 || nn>CHART_COUNT) STATE.settingsChartScope = 'all';
                }
              }catch(_){ }

              for(var ii=1; ii<=CHART_COUNT; ii++) __saInitChartState(ii);
              __saRecomputeModel();
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
              setTimeout(function(){ try{ STATE.settingsTab='data'; btn.click(); }catch(_){} }, 0);
            }catch(_){ }
            return;
          }
          if(act==='st-bins-apply'){
            function __saGetScopeNum(){
              var scEl = popEl.querySelector('#st-chart-scope');
              var raw = scEl ? String(scEl.value||'all') : 'all';
              if(raw!=='all'){
                var n = parseInt(raw,10);
                if(isFinite(n) && n>=1 && n<=CHART_COUNT) return n;
              }
              return null;
            }
            var inp = popEl.querySelector('#st-bins-custom');
            var n = inp ? parseInt(String(inp.value||'').trim(),10) : NaN;
            if(isFinite(n) && n>0){
              var sc = __saGetScopeNum();
              if(sc){
                STATE['histBins'+sc] = n;
                try{ saveSettings(); }catch(_){ }
                rebuildLayout();
              }else{
                STATE.histBinsAll = n;
                applyAllAndRebuild(function(i){ STATE['histBins'+i] = n; });
              }
              setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            }
            return;
          }
          if(act==='st-bins-reset'){
            var sc2 = null;
            try{
              var scEl2 = popEl.querySelector('#st-chart-scope');
              var raw2 = scEl2 ? String(scEl2.value||'all') : 'all';
              if(raw2!=='all'){
                var nn = parseInt(raw2,10);
                if(isFinite(nn) && nn>=1 && nn<=CHART_COUNT) sc2 = nn;
              }
            }catch(_){ }
            if(sc2){
              STATE['histBins'+sc2] = 10;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.histBinsAll = 10;
              applyAllAndRebuild(function(i){ STATE['histBins'+i] = 10; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(act==='st-disp-none'){
            var sc3 = null;
            try{
              var scEl3 = popEl.querySelector('#st-chart-scope');
              var raw3 = scEl3 ? String(scEl3.value||'all') : 'all';
              if(raw3!=='all'){
                var nn3 = parseInt(raw3,10);
                if(isFinite(nn3) && nn3>=1 && nn3<=CHART_COUNT) sc3 = nn3;
              }
            }catch(_){ }
            if(sc3){
              STATE['showRegression'+sc3]=false;
              STATE['showCI'+sc3]=false;
              STATE['showAvgX'+sc3]=false;
              STATE['showAvgY'+sc3]=false;
              STATE['showRegTicks'+sc3]=false;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.showRegressionAll=false;
              STATE.showCIAll=false;
              STATE.showAvgXAll=false;
              STATE.showAvgYAll=false;
              STATE.showRegTicksAll=false;
              applyAllAndRebuild(function(i){
                STATE['showRegression'+i]=false;
                STATE['showCI'+i]=false;
                STATE['showAvgX'+i]=false;
                STATE['showAvgY'+i]=false;
                STATE['showRegTicks'+i]=false;
              });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(act==='st-disp-all'){
            var sc4 = null;
            try{
              var scEl4 = popEl.querySelector('#st-chart-scope');
              var raw4 = scEl4 ? String(scEl4.value||'all') : 'all';
              if(raw4!=='all'){
                var nn4 = parseInt(raw4,10);
                if(isFinite(nn4) && nn4>=1 && nn4<=CHART_COUNT) sc4 = nn4;
              }
            }catch(_){ }
            if(sc4){
              STATE['showRegression'+sc4]=true;
              STATE['showCI'+sc4]=true;
              STATE['showAvgX'+sc4]=true;
              STATE['showAvgY'+sc4]=true;
              STATE['showRegTicks'+sc4]=false;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.showRegressionAll=true;
              STATE.showCIAll=true;
              STATE.showAvgXAll=true;
              STATE.showAvgYAll=true;
              STATE.showRegTicksAll=false;
              applyAllAndRebuild(function(i){
                STATE['showRegression'+i]=true;
                STATE['showCI'+i]=true;
                STATE['showAvgX'+i]=true;
                STATE['showAvgY'+i]=true;
              });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }

          if(act==='st-reset'){
            // Reset to PV defaults snapshot
            LAYOUT = (DEFAULTS.layout || 'H');
            applyGridGap(DEFAULTS.gridGap);
            CHART_HEIGHT = DEFAULTS.chartHeight;
            TABLE_HEIGHT = DEFAULTS.tableHeight;
            TABLE_ROWS = DEFAULTS.tableRows;
            CHARTS_PER_ROW = DEFAULTS.chartsPerRow;
            STATE.autoSize = !!DEFAULTS.autoSize;
            __saApplyGridPreset(DEFAULTS.gridPreset);
            STATE.theme = DEFAULTS.theme || THEME_DEFAULT;
            ENABLE_MULTI_SECTION = !!DEFAULTS.enableMultiSection;
            SHOW_CARD_TITLES = !!DEFAULTS.showCardTitles;
            SHOW_PLOT_TITLES = !!DEFAULTS.showPlotTitles;
            SHOW_SECTION_SELECTOR = !!DEFAULTS.showSectionSelector;

            REPORT_TITLE = DEFAULTS.reportTitle;
            REPORT_SUBTITLE = DEFAULTS.reportSubtitle;
            REPORT_TITLE_BORDER_COLOR = DEFAULTS.reportTitleBorderColor;
            TITLE_FONT_SIZE = DEFAULTS.titleFontSize;
            try{ __saSyncAxisFontSizes(); }catch(_){ }
            CARD_BORDER_RADIUS = DEFAULTS.cardBorderRadius;
            AXIS_DEC = DEFAULTS.axisDecimals;
            AXIS_FIXED_BUFFER = DEFAULTS.axisFixedBuffer;
            X_NTICKS_MULT = DEFAULTS.xNticksMult;
            FULLSCREEN_FONT_SCALE = DEFAULTS.fullscreenFontScale;

            NORMAL_COLOR = DEFAULTS.normalColor;
            OUTLIER_COLOR = DEFAULTS.outlierColor;
            TREND_COLOR = DEFAULTS.trendColor;
            BAND_COLOR = DEFAULTS.ciColor;
            BAND_OPACITY = DEFAULTS.ciOpacity;
            HOVER_COLOR = DEFAULTS.hoverColor;
            HOVER_BG = DEFAULTS.hoverBg;
            OUTLIER_COLORED = !!DEFAULTS.outlierColored;

            CF_ENABLED = !!DEFAULTS.cfEnabled;
            CF_RED = DEFAULTS.cfRed;
            CF_GREEN = DEFAULTS.cfGreen;

            TARGET_COLOR_DEFAULT = DEFAULTS.targetColor;
            TARGET_WIDTH_DEFAULT = DEFAULTS.targetWidth;
            TARGET_DASH_DEFAULT = DEFAULTS.targetDash;

            X_COL = DEFAULTS.xCol;
            SECTION_COL = DEFAULTS.sectionCol;
            CF_COL = DEFAULTS.cfCol;
            TABLE_COLS = (DEFAULTS.tableCols||[]).slice();
            HOVER_COLS_1 = (DEFAULTS.hoverCols1||[]).slice();
            HOVER_COLS_2 = (DEFAULTS.hoverCols2||[]).slice();

            // Reset chart defs/state
            CHART_DEFS = (DEFAULT_CHART_DEFS||[]).map(function(d){
              return { title:d.title, yCol:d.yCol, defaultType:d.defaultType, defaultRegressionMethod:d.defaultRegressionMethod, show:(d.show!==false) };
            });
            CHART_COUNT = CHART_DEFS.length;
            for(var i=1;i<=CHART_COUNT;i++){
              __saInitChartState(i);
              var ds = (DEFAULT_CHART_STATE && DEFAULT_CHART_STATE[i-1]) ? DEFAULT_CHART_STATE[i-1] : null;
              if(ds){
                STATE['chartType'+i] = normChartType(ds.chartType);
                STATE['histBins'+i] = parseInt(ds.histBins||20,10);
                STATE['pointsMode'+i] = String(ds.pointsMode||'auto');
                STATE['showLabels'+i] = !!ds.showLabels;
                STATE['showLegend'+i] = !!ds.showLegend;
                STATE['legendPos'+i] = String(ds.legendPos||'auto');
                STATE['regressionMethod'+i] = String(ds.regressionMethod||'linear');
                STATE['showRegression'+i] = !!ds.showRegression;
                STATE['showCI'+i] = !!ds.showCI;
                STATE['showAvgX'+i] = !!ds.showAvgX;
                STATE['showAvgY'+i] = !!ds.showAvgY;
                STATE['showRegTicks'+i] = !!ds.showRegTicks;
              }
            }

            STATE.tableFilter = { colLabel: null, min: '', max: '' };
            TABLE_FILTER_COLS_RAW = DEFAULTS.tableFilterCols || 'all';
            __saRecomputeModel();
            __saRecomputeTableCols();

            // Sync header
            try{ titleEl.textContent = REPORT_TITLE; }catch(_){ }
            try{ subEl.textContent = String(REPORT_SUBTITLE||''); subEl.style.display = (String(REPORT_SUBTITLE||'').trim()? '' : 'none'); }catch(_){ }
            try{ rootHost.style.setProperty('--sa-report-sep', String(REPORT_TITLE_BORDER_COLOR||'rgba(0,0,0,0.15)')); }catch(_){ }

            saveSettings();
            try{ updateTheme(); }catch(_){ }
            rebuildLayout();
            closeAllMenus();
            return;
          }
          if(act==='st-apply'){
            var needsModel = false;
            var needsCols = false;

            // Remember chart-scope selector
            try{
              var scEl = popEl.querySelector('#st-chart-scope');
              if(scEl) STATE.settingsChartScope = String(scEl.value||'all');
            }catch(_){ }

            // Presentation preset / visibility
            var presetEl = popEl.querySelector('#st-preset');
            var presetVal = presetEl ? String(presetEl.value||'custom') : 'custom';
            if(presetVal && presetVal !== 'custom'){
              __saApplyGridPreset(presetVal);
            }else{
              var st = popEl.querySelector('#st-show-table');
              var c1 = popEl.querySelector('#st-show-c1');
              var c2 = popEl.querySelector('#st-show-c2');
              STATE.gridPreset = '';
              STATE.showTable = !!(st && st.checked);
              STATE.showChart1 = !!(c1 && c1.checked);
              STATE.showChart2 = !!(c2 && c2.checked);
            }

            // Layout values
            var gapEl = popEl.querySelector('#ls-gap');
            var chartEl = popEl.querySelector('#ls-chart');
            var cprEl = popEl.querySelector('#ls-cpr');
            var rowsEl = popEl.querySelector('#ls-rows');
            var autoEl = popEl.querySelector('#ls-autosize');
            var newGap = gapEl ? parseInt(String(gapEl.value||'').trim(),10) : NaN;
            var newChartH = chartEl ? parseInt(String(chartEl.value||'').trim(),10) : NaN;
            var newCpr = cprEl ? parseInt(String(cprEl.value||'').trim(),10) : NaN;
            var newRows = rowsEl ? parseInt(String(rowsEl.value||'').trim(),10) : NaN;
            if(isFinite(newGap)) applyGridGap(newGap);
            if(isFinite(newChartH)) CHART_HEIGHT = newChartH;
            if(isFinite(newCpr)) CHARTS_PER_ROW = Math.max(1, Math.min(2, newCpr));
            if(isFinite(newRows)) TABLE_ROWS = Math.max(1, Math.min(200, newRows));
            STATE.autoSize = !!(autoEl && autoEl.checked);

            // Layout radio
            var layEl = popEl.querySelector('input[name="ls-layout"]:checked');
            if(layEl) LAYOUT = String(layEl.value||'H').toUpperCase();

            // Theme
            var themeEl = popEl.querySelector('input[name="st-theme"]:checked');
            if(themeEl) STATE.theme = normTheme(themeEl.value);

            // Data mapping
            var secEl = popEl.querySelector('#dm-section');
            var xEl = popEl.querySelector('#dm-x');
            var cfEl = popEl.querySelector('#dm-cf');
            var nextSec = secEl ? parseInt(String(secEl.value||'').trim(),10) : NaN;
            var nextX = xEl ? parseInt(String(xEl.value||'').trim(),10) : NaN;
            var nextCf = cfEl ? parseInt(String(cfEl.value||'').trim(),10) : NaN;
            if(isFinite(nextSec) && nextSec!==SECTION_COL){ SECTION_COL = nextSec; needsModel=true; }
            if(isFinite(nextX) && nextX!==X_COL){ X_COL = nextX; needsModel=true; }
            if(isFinite(nextCf) && nextCf!==CF_COL){ CF_COL = nextCf; needsModel=true; }

            // Table cols
            var tblSel = popEl.querySelector('#dm-table-cols');
            if(tblSel){
              var nextTbl=[];
              for(var oi=0; oi<tblSel.options.length; oi++){
                var opt = tblSel.options[oi];
                if(opt && opt.selected){
                  var idx = parseInt(String(opt.value||''),10);
                  if(isFinite(idx)) nextTbl.push(idx);
                }
              }
              if(nextTbl.length){ TABLE_COLS = nextTbl; needsCols=true; }
            }

            // Hover cols chart1/2
            function readMultiIdx(id){
              var sel = popEl.querySelector(id);
              var out=[];
              if(!sel) return out;
              for(var oi=0; oi<sel.options.length; oi++){
                var opt = sel.options[oi];
                if(opt && opt.selected){
                  var idx = parseInt(String(opt.value||''),10);
                  if(isFinite(idx)) out.push(String(idx));
                }
              }
              return out;
            }
            HOVER_COLS_1 = readMultiIdx('#dm-hov1');
            HOVER_COLS_2 = readMultiIdx('#dm-hov2');

            // Chart defs (title/y/show)
            var nextDefs = [];
            for(var c=1;c<=CHART_COUNT;c++){
              var tIn = popEl.querySelector('#dm-title-'+c);
              var yIn = popEl.querySelector('#dm-y-'+c);
              var sIn = popEl.querySelector('#dm-show-'+c);
              var tVal = tIn ? String(tIn.value||'').trim() : '';
              var yVal = yIn ? parseInt(String(yIn.value||'').trim(),10) : NaN;
              var showVal = !!(sIn && sIn.checked);
              if(!isFinite(yVal)) yVal = (CHART_DEFS[c-1] && CHART_DEFS[c-1].yCol!=null) ? CHART_DEFS[c-1].yCol : 0;
              yVal = Math.max(0, Math.min(KEYS.length-1, yVal));
              var prev = CHART_DEFS[c-1] || {};
              if(prev.yCol!==yVal) needsModel=true;
              nextDefs.push({
                title: tVal || (prev.title!=null?String(prev.title):('Chart '+c)),
                yCol: yVal,
                defaultType: prev.defaultType,
                defaultRegressionMethod: prev.defaultRegressionMethod,
                show: showVal
              });
              if(c===1) STATE.showChart1 = showVal;
              else if(c===2) STATE.showChart2 = showVal;
              else STATE['showChart'+c] = showVal;
            }
            if(nextDefs.length){ CHART_DEFS = nextDefs; CHART_COUNT = CHART_DEFS.length; }

            // Style
            var rt = popEl.querySelector('#st-rt');
            var rs = popEl.querySelector('#st-rs');
            var rb = popEl.querySelector('#st-rb');
            if(rt) REPORT_TITLE = String(rt.value||'');
            if(rs) REPORT_SUBTITLE = String(rs.value||'');
            if(rb) REPORT_TITLE_BORDER_COLOR = String(rb.value||'');

            var tfs = popEl.querySelector('#st-tfs');
            var dec = popEl.querySelector('#st-dec');
            var abuf = popEl.querySelector('#st-abuf');
            var xnt = popEl.querySelector('#st-xnt');
            var fsfs = popEl.querySelector('#st-fsfs');
            var cr = popEl.querySelector('#st-cr');
            var cio = popEl.querySelector('#st-cio');
            if(tfs && isFinite(parseInt(tfs.value,10))){ TITLE_FONT_SIZE = parseInt(tfs.value,10); try{ __saSyncAxisFontSizes(); }catch(_){ } }
            if(dec && isFinite(parseInt(dec.value,10))) AXIS_DEC = Math.max(0, Math.min(6, parseInt(dec.value,10)));
            if(abuf && isFinite(parseFloat(abuf.value))) AXIS_FIXED_BUFFER = parseFloat(abuf.value);
            if(xnt && isFinite(parseInt(xnt.value,10))) X_NTICKS_MULT = Math.max(1, Math.min(10, parseInt(xnt.value,10)));
            if(fsfs && isFinite(parseFloat(fsfs.value))) FULLSCREEN_FONT_SCALE = Math.max(0.6, Math.min(2.2, parseFloat(fsfs.value)));
            if(cr && isFinite(parseInt(cr.value,10))) CARD_BORDER_RADIUS = Math.max(0, Math.min(40, parseInt(cr.value,10)));
            if(cio && isFinite(parseFloat(cio.value))) BAND_OPACITY = Math.max(0, Math.min(1, parseFloat(cio.value)));

            function val(id){ var el=popEl.querySelector(id); return el?String(el.value||'').trim():''; }
            var ncol = val('#st-col-n'); if(ncol) NORMAL_COLOR=ncol;
            var ocol = val('#st-col-o'); if(ocol) OUTLIER_COLOR=ocol;
            var tcol = val('#st-col-t'); if(tcol) TREND_COLOR=tcol;
            var cicol = val('#st-col-ci'); if(cicol) BAND_COLOR=cicol;
            var hcol = val('#st-col-h'); if(hcol) HOVER_COLOR=hcol;
            var hbcol = val('#st-col-hb'); if(hbcol) HOVER_BG=hbcol;

            var outcolEl = popEl.querySelector('#st-outcol');
            if(outcolEl) OUTLIER_COLORED = !!outcolEl.checked;
            var cfenEl = popEl.querySelector('#st-cfen');
            if(cfenEl) CF_ENABLED = !!cfenEl.checked;
            var cfr = val('#st-cfr'); if(cfr) CF_RED=cfr;
            var cfg = val('#st-cfg'); if(cfg) CF_GREEN=cfg;

            // Targets
            var tc = val('#st-tcol'); if(tc) TARGET_COLOR_DEFAULT=tc;
            var tw = popEl.querySelector('#st-tw'); if(tw && isFinite(parseFloat(tw.value))) TARGET_WIDTH_DEFAULT = Math.max(0.5, Math.min(6, parseFloat(tw.value)));
            var td = popEl.querySelector('#st-td'); if(td) TARGET_DASH_DEFAULT = String(td.value||'dash');

            // Advanced
            var ms = popEl.querySelector('#ad-ms');
            var sct = popEl.querySelector('#ad-sct');
            var spt = popEl.querySelector('#ad-spt');
            if(ms) ENABLE_MULTI_SECTION = !!ms.checked;
            if(sct) SHOW_CARD_TITLES = !!sct.checked;
            if(spt) SHOW_PLOT_TITLES = !!spt.checked;

            // Apply recomputes
            if(needsModel){ try{ __saRecomputeModel(); }catch(_){ } }
            if(needsCols){ try{ __saRecomputeTableCols(); }catch(_){ } }

            // Sync header UI
            try{ titleEl.textContent = REPORT_TITLE; }catch(_){ }
            try{ subEl.textContent = String(REPORT_SUBTITLE||''); subEl.style.display = (String(REPORT_SUBTITLE||'').trim()? '' : 'none'); }catch(_){ }
            try{ rootHost.style.setProperty('--sa-report-sep', String(REPORT_TITLE_BORDER_COLOR||'rgba(0,0,0,0.15)')); }catch(_){ }

            // Table filter defaults
            var tfColsEl = popEl.querySelector('#st-tf-cols');
            if(tfColsEl) TABLE_FILTER_COLS_RAW = String(tfColsEl.value||'').trim() || 'all';
            var tfColEl = popEl.querySelector('#st-tf-col');
            var tfMinEl = popEl.querySelector('#st-tf-min');
            var tfMaxEl = popEl.querySelector('#st-tf-max');
            var nextCol = tfColEl ? String(tfColEl.value||'').trim() : '';
            var nextMin = tfMinEl ? String(tfMinEl.value||'').trim() : '';
            var nextMax = tfMaxEl ? String(tfMaxEl.value||'').trim() : '';
            if(!nextCol || (!nextMin && !nextMax)){
              STATE.tableFilter = { colLabel: null, min: '', max: '' };
            }else{
              STATE.tableFilter = { colLabel: nextCol, min: nextMin, max: nextMax };
            }

            saveSettings();
            try{ updateTheme(); }catch(_){ }
            rebuildLayout();
            closeAllMenus();
            return;
          }
        });

        popEl.addEventListener('change', function(ev){
          var t = ev && ev.target;
          if(!t) return;

          function __saGetChartScope(){
            var scEl = popEl.querySelector('#st-chart-scope');
            var raw = scEl ? String(scEl.value||'all') : 'all';
            if(raw!=='all'){
              var n = parseInt(raw,10);
              if(!isFinite(n) || n<1 || n>CHART_COUNT) return null;
              return n;
            }
            return null;
          }

          // Tabs: remember last used
          try{ STATE.settingsTab = String(STATE.settingsTab||'presentation'); }catch(_){ }

          // Charts scope selector
          if(t.id==='st-chart-scope'){
            try{ STATE.settingsChartScope = String(t.value||'all'); }catch(_){ }
            try{ saveSettings(); }catch(_){ }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }

          // Chart type / bins / options apply immediately (reopen to same tab)
          if(t.name==='st-ct'){
            var v = String(t.value||'scatter');
            var sc = __saGetChartScope();
            if(sc){
              STATE['chartType'+sc] = v;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.chartTypeAll = v;
              applyAllAndRebuild(function(i){ STATE['chartType'+i] = v; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-bins'){
            var n = parseInt(String(t.value||''),10);
            if(isFinite(n) && n>0){
              var sc2 = __saGetChartScope();
              if(sc2){
                STATE['histBins'+sc2] = n;
                try{ saveSettings(); }catch(_){ }
                rebuildLayout();
              }else{
                STATE.histBinsAll = n;
                applyAllAndRebuild(function(i){ STATE['histBins'+i] = n; });
              }
              setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            }
            return;
          }
          if(t.id==='st-hist-counts'){
            STATE.showHistCounts = !!t.checked;
            try{ saveSettings(); }catch(_){ }
            rebuildLayout();
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-pm'){
            var v2=String(t.value||'auto');
            var sc3 = __saGetChartScope();
            if(sc3){
              STATE['pointsMode'+sc3]=v2;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.pointsModeAll = v2;
              applyAllAndRebuild(function(i){ STATE['pointsMode'+i]=v2; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-lbl'){
            var on=(String(t.value)==='on');
            var sc4 = __saGetChartScope();
            if(sc4){
              STATE['showLabels'+sc4]=on;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.labelsAll = on;
              applyAllAndRebuild(function(i){ STATE['showLabels'+i]=on; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-lshow'){
            var on2=(String(t.value)==='1');
            var sc5 = __saGetChartScope();
            if(sc5){
              STATE['showLegend'+sc5]=on2;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.legendAll = on2;
              applyAllAndRebuild(function(i){ STATE['showLegend'+i]=on2; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-lpos'){
            var lp=String(t.value||'auto');
            var sc6 = __saGetChartScope();
            if(sc6){
              STATE['legendPos'+sc6]=lp;
              STATE['showLegend'+sc6]=true;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.legendPosAll = lp;
              applyAllAndRebuild(function(i){ STATE['legendPos'+i]=lp; STATE['showLegend'+i]=true; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-out'){
            var ex=(String(t.value)==='exclude');
            STATE.excludeOutliersAll = ex;
            applyAllAndRebuild(function(i){
              STATE.excludeOutliers = ex;
              if(!ex) STATE['showOutliers'+i]=true;
            });
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-hov'){
            var on3=(String(t.value)==='on');
            STATE.hoverCellAll = on3;
            applyAllAndRebuild(function(i){ STATE.showCell = on3; });
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-om'){
            var m=String(t.value||'kmeans');
            STATE.outlierMethod = m;
            applyAllAndRebuild(function(i){ /* global method */ });
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-rm'){
            var v3 = String(t.value||'linear');
            var sc7 = __saGetChartScope();
            if(sc7){
              STATE['regressionMethod'+sc7] = (v3==='none') ? 'none' : 'linear';
              STATE['showRegression'+sc7] = (v3!=='none');
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.regressionAll = v3;
              STATE.showRegressionAll = (v3!=='none');
              applyAllAndRebuild(function(i){
                STATE['regressionMethod'+i] = (v3==='none') ? 'none' : 'linear';
                STATE['showRegression'+i] = (v3!=='none');
              });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-ov_reg'){
            var on4=(String(t.value)==='1');
            var sc8 = __saGetChartScope();
            if(sc8){
              STATE['showRegression'+sc8]=on4;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.showRegressionAll = on4;
              applyAllAndRebuild(function(i){ STATE['showRegression'+i]=on4; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-ov_ticks'){
            var on5=(String(t.value)==='1');
            var sc9 = __saGetChartScope();
            if(sc9){
              STATE['showRegTicks'+sc9]=on5;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.showRegTicksAll = on5;
              applyAllAndRebuild(function(i){ STATE['showRegTicks'+i]=on5; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-ov_ci'){
            var on6=(String(t.value)==='1');
            var sc10 = __saGetChartScope();
            if(sc10){
              STATE['showCI'+sc10]=on6;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.showCIAll = on6;
              applyAllAndRebuild(function(i){ STATE['showCI'+i]=on6; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-ov_xm'){
            var on7=(String(t.value)==='1');
            var sc11 = __saGetChartScope();
            if(sc11){
              STATE['showAvgX'+sc11]=on7;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.showAvgXAll = on7;
              applyAllAndRebuild(function(i){ STATE['showAvgX'+i]=on7; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
          if(t.name==='st-ov_ym'){
            var on8=(String(t.value)==='1');
            var sc12 = __saGetChartScope();
            if(sc12){
              STATE['showAvgY'+sc12]=on8;
              try{ saveSettings(); }catch(_){ }
              rebuildLayout();
            }else{
              STATE.showAvgYAll = on8;
              applyAllAndRebuild(function(i){ STATE['showAvgY'+i]=on8; });
            }
            setTimeout(function(){ try{ STATE.settingsTab='charts'; btn.click(); }catch(_){} }, 0);
            return;
          }
        }, {passive:true});
      });
    }

    btn.onclick = function(e){
      e.stopPropagation();
      __saOpenSettings();
    };

    // Make Settings the first icon (before Reset)
    try{ ctrlGroup.insertBefore(btn, ctrlGroup.firstChild); }catch(_){ ctrlGroup.appendChild(btn); }
  })();

  // Reset (report-level)
  (function(){
    var btn = document.createElement('button');
    btn.className = 'sa-btn';
    btn.title = 'Reset all charts';
    btn.innerHTML = iconSvg(homeI);
    btn.onclick = function(e){
      e.stopPropagation();
      closeAllMenus();
      try{ resetAllChartsToDefaults(); }catch(_){ }
    };
    ctrlGroup.insertBefore(btn, ctrlGroup.firstChild);
  })();

  // Fullscreen (report-level)
  ctrlGroup.appendChild(createIconBtn(iconSvg(fullI),'Fullscreen report', function(){ togglePageFullscreen(); }));
  // Section selector (report-level)
  var sectionBtnEl = null;
  function setSection(next){
    closeAllMenus();
    STATE.currentSection = next;
    // Section selector removed from titlebar; keep section changes internal.
    rebuildLayout();
  }
  var sectionItems = [{
    label:'All',
    stateGetter:function(){ return STATE.currentSection==='All'; },
    action:function(){ setSection('All'); }
  }];
  sectionKeys.forEach(function(sk){
    sectionItems.push({
      label: sk,
      stateGetter:function(){ return STATE.currentSection===sk; },
      action:function(){ setSection(sk); }
    });
  });
  var folderI = 'M140 260 H420 L480 320 H860 V780 H140 Z M140 260 V210 H390 L450 260 Z';
  var sectionDropdownEl = createDropdownBtn(iconSvg(folderI),'Section', sectionItems);
  sectionBtnEl = sectionDropdownEl.querySelector('button.sa-btn');
  try{ if(sectionBtnEl) sectionBtnEl.title = 'Section: ' + STATE.currentSection; }catch(_){ }
  // Section selector removed from report titlebar (requested).
  header.appendChild(ctrlGroup);
  rootHost.appendChild(header);
  // Note: previously we stripped ancestor underlines. The updated design intentionally
  // shows a subtle separator under the report header (LineTrend parity).

  // Grid wrapper
  var gridWrapper = document.createElement('div'); gridWrapper.className = 'sa-grid-wrapper';
  var layoutRoot = document.createElement('div'); layoutRoot.className = LAYOUT === 'H' ? 'sa-grid-h' : 'sa-grid-v'; gridWrapper.appendChild(layoutRoot); rootHost.appendChild(gridWrapper);

  function applyAutoSizing(){
    try{
      // In fill-height mode we still need to enforce stable card heights (otherwise
      // toggling the report-level Data Table can briefly collapse charts to titlebar-only).
      if(!FILL_HEIGHT && !STATE.autoSize) return;
      var gwH = gridWrapper.getBoundingClientRect().height || 0;
      if(gwH <= 0) return;
      // Single-view only (skip multi-section layouts)
      if(!layoutRoot.querySelector('.sa-section-row')){
        var headerH = header.getBoundingClientRect().height || 0;
        var availableH = (rootHost.getBoundingClientRect().height || gwH) - headerH;
        if(availableH < 300) availableH = gwH; // fallback
        var tableWrap = document.getElementById('sa-table-wrap') || document.querySelector('[id^="sa-table-wrap"]');
        var hasTable = !!(STATE.showTable && tableWrap);
        var tableTargetH = hasTable ? Math.max(180, Math.round(availableH * 0.36)) : 0;
        var chartsTotalH = Math.max(260, availableH - tableTargetH - 16);
        var chartEls = [];
        for(var i=1;i<=CHART_COUNT;i++){
          var el = document.getElementById(chartInnerId(i));
          if(el && el.style.display !== 'none') chartEls.push(el);
        }
        var chartTargetH = Math.max(220, Math.floor(chartsTotalH / Math.max(1, chartEls.length)));
        if(tableWrap && hasTable){
          // Table height is governed by PV_TableRows (even in fill-height).
          // Avoid overriding max-height here; it can make tall tables stretch the whole row.
          if(!(isFinite(TABLE_ROWS) && TABLE_ROWS > 0)){
            var cap = (isFinite(TABLE_HEIGHT) && TABLE_HEIGHT>0) ? TABLE_HEIGHT : tableTargetH;
            var h = Math.min(cap, tableTargetH);
            tableWrap.style.minHeight = h + 'px';
            tableWrap.style.height = h + 'px';
            tableWrap.style.maxHeight = h + 'px';
          }else{
            tableWrap.style.minHeight = '0px';
            tableWrap.style.height = 'auto';
          }
        } else if(tableWrap && !hasTable){
          // Ensure charts can reclaim space when table is hidden.
          tableWrap.style.minHeight = '';
          tableWrap.style.height = '';
          tableWrap.style.maxHeight = '';
        }
        // Only enforce a floor height to prevent collapse; allow flex/grid to expand naturally.
        chartEls.forEach(function(el){
          el.style.minHeight = chartTargetH + 'px';
          el.style.height = '';
          el.style.maxHeight = '';
        });
        if(window.Plotly){ chartEls.forEach(function(el){ try{ Plotly.Plots.resize(el); }catch(_){ } }); }
      }

      // Always do a best-effort resize pass (helps after toggles)
      try{ resizeCharts(); }catch(_2){ }
    }catch(e){}
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // DEFINE ALL DATA/HELPER FUNCTIONS BEFORE BUILDING LAYOUT
  // ═══════════════════════════════════════════════════════════════════════════
	
  // TABLE OPERATIONS - Define COLS early
  var COLS = [];
  function __saRecomputeTableCols(){
    try{
      COLS = (TABLE_COLS||[]).map(function(idx){
        idx = parseInt(idx,10);
        if(!isFinite(idx) || idx<0 || idx >= KEYS.length) return null;
        var label = KEYS[idx];
        var numCount=0, tot=0;
        rowsRaw.forEach(function(r){
          var v=r[label];
          if(v!==null && v!==undefined && v!==''){
            tot++;
            if(isFinite(Number(String(v).replace(/,/g,'')))) numCount++;
          }
        });
        return { label: label, idx: idx, isNum: (tot>0 && numCount===tot) };
      }).filter(function(c){return c!==null;});
    }catch(_){ COLS = []; }
  }
  __saRecomputeTableCols();

  function applyCF(row){ if(!CF_ENABLED || !cfColLabel) return ''; var vProp=row[cfColLabel], vLatest=row[latestLabel]; if(vProp==null||vLatest==null) return ''; var p=Number(vProp), l=Number(vLatest); if(!isFinite(p)||!isFinite(l)) return ''; if(p>l) return CF_RED; if(p<l) return CF_GREEN; return ''; }

  function getSortedRows(){
    var rows = rowsRaw.filter(function(r,idx){ 
      if(STATE.removedIndices[idx]) return false;
      if(STATE.currentSection !== 'All' && String(r[sectionLabel] || '') !== STATE.currentSection) return false;
      return true;
    });

    // Table-only filter: single-column "between" filter (does not affect charts).
    try{
      var tf = STATE && STATE.tableFilter ? STATE.tableFilter : null;
      var colLabel = tf && tf.colLabel ? String(tf.colLabel) : '';
      var minRaw = tf && tf.min != null ? String(tf.min).trim() : '';
      var maxRaw = tf && tf.max != null ? String(tf.max).trim() : '';
      var hasBound = !!(minRaw || maxRaw);
      if(hasBound && colLabel){
        rows = rows.filter(function(r){
          try{
            var v = r ? r[colLabel] : null;
            if(v === null || v === undefined || v === '') return false;
            var vNum = toNum(v);
            var minNum = minRaw ? toNum(minRaw) : null;
            var maxNum = maxRaw ? toNum(maxRaw) : null;
            // Numeric compare when possible
            if(vNum !== null && (minNum !== null || maxNum !== null)){
              if(minNum !== null && vNum < minNum) return false;
              if(maxNum !== null && vNum > maxNum) return false;
              return true;
            }
            // String compare fallback
            var vs = String(v).toLowerCase();
            if(minRaw){
              if(vs.localeCompare(String(minRaw).toLowerCase()) < 0) return false;
            }
            if(maxRaw){
              if(vs.localeCompare(String(maxRaw).toLowerCase()) > 0) return false;
            }
            return true;
          }catch(_){ return true; }
        });
      }
    }catch(_tf){ }

    if(STATE.sortCol!==null){ var col=COLS[STATE.sortCol].label; var dir=STATE.sortDir; var isNum=COLS[STATE.sortCol].isNum;
      rows.sort(function(a,b){ var va=a[col], vb=b[col]; if(va==null && vb==null) return 0; if(va==null) return 1; if(vb==null) return -1; if(isNum) return (Number(va)-Number(vb))*dir; return String(va).localeCompare(String(vb))*dir; });
    }
    return rows;
  }

  function __saTableFilterSummaryText(){
    try{
      var tf = STATE && STATE.tableFilter ? STATE.tableFilter : null;
      var col = tf && tf.colLabel ? String(tf.colLabel).trim() : '';
      var minRaw = tf && tf.min != null ? String(tf.min).trim() : '';
      var maxRaw = tf && tf.max != null ? String(tf.max).trim() : '';
      if(!col || (!minRaw && !maxRaw)) return '';
      if(minRaw && maxRaw) return 'Filter: ' + col + ' between ' + minRaw + ' and ' + maxRaw;
      if(minRaw) return 'Filter: ' + col + ' ≥ ' + minRaw;
      return 'Filter: ' + col + ' ≤ ' + maxRaw;
    }catch(_){ return ''; }
  }
  function __saApplyTableFilterSummary(summaryId){
    try{
      var el = document.getElementById(summaryId);
      if(!el) return;
      var txt = __saTableFilterSummaryText();
      el.textContent = txt;
      el.style.display = txt ? 'block' : 'none';
    }catch(_){ }
  }

  function makeCard(title, id, sectionSuffix) {
    var card = document.createElement('div'); card.className = 'sa-card'; card.id = id + (sectionSuffix || '');
    card.style.borderRadius = CARD_BORDER_RADIUS + 'px';
    var titlebar = document.createElement('div'); titlebar.className = 'sa-titlebar';
    var topRow = document.createElement('div'); topRow.className = 'sa-titlebar-top';
    var titleNode = document.createElement('div'); titleNode.className = 'sa-titlebar-title'; titleNode.textContent = title || '';
    if(!SHOW_CARD_TITLES) titleNode.style.display = 'none';
    topRow.appendChild(titleNode);
    var modebar = document.createElement('div'); modebar.className = 'sa-modebar'; modebar.id = id + '-modebar' + (sectionSuffix || ''); topRow.appendChild(modebar); titlebar.appendChild(topRow);
    var bottomRow = document.createElement('div'); bottomRow.className = 'sa-titlebar-bottom';
    var r2El = document.createElement('div'); r2El.className = 'sa-titlebar-r2'; r2El.id = id + '-r2' + (sectionSuffix || ''); bottomRow.appendChild(r2El); titlebar.appendChild(bottomRow);
    card.appendChild(titlebar);
    var inner = document.createElement('div'); inner.className = 'sa-inner'; inner.id = id + '-inner' + (sectionSuffix || ''); card.appendChild(inner);
    var stats = document.createElement('div'); stats.className = 'sa-chart-stats'; stats.id = id + '-stats' + (sectionSuffix || ''); card.appendChild(stats);
    return { card: card, inner: inner, modebar: modebar, r2El: r2El, bottomRow: bottomRow };
  }

  var tableCard, s1Card, s2Card;
  var sectionCards = {}; // Store cards for each section

  function getShownChartCount(){
    var shownCount = 0;
    for(var k=1;k<=CHART_COUNT;k++){ if(isChartShown(k)) shownCount++; }
    return shownCount;
  }

  function rebuildLayout() {
    dbg('DEBUG rebuildLayout: currentSection =', STATE.currentSection, ', sectionKeys =', sectionKeys);

    var isMultiAll = (ENABLE_MULTI_SECTION && STATE.currentSection === 'All' && sectionKeys.length > 1);

    // Container formation (V1-style):
    // - Single-section respects PV_Layout (H/V)
    // - Multi-section All always stacks sections vertically via sa-grid-v
    try{ layoutRoot.className = (isMultiAll ? 'sa-grid-v' : (LAYOUT === 'H' ? 'sa-grid-h' : 'sa-grid-v')); }catch(_){ }

    // Compute grid columns based on visible cards
    function getGridCols(){
      var cols = [];
      if(STATE.showTable){
        cols.push(LAYOUT === 'H' ? 'minmax(280px, 1fr)' : '1fr');
      }
      if(LAYOUT === 'H'){
        // In Horizontal layout we can wrap charts by limiting the number of chart columns.
        // CHARTS_PER_ROW=2 keeps the classic table+chart1+chart2 row.
        // CHARTS_PER_ROW=1 stacks charts while keeping the table on the left.
        var shownCount = 0;
        for(var k=1;k<=CHART_COUNT;k++){ if(isChartShown(k)) shownCount++; }
        var desiredCols = Math.max(1, Math.min(2, CHARTS_PER_ROW || 2));
        var chartCols = Math.min(desiredCols, Math.max(0, shownCount));
        for(var c=0; c<chartCols; c++) cols.push('minmax(0, 1fr)');
      }else{
        for(var i=1;i<=CHART_COUNT;i++){
          if(isChartShown(i)) cols.push('1fr');
        }
      }
      if(!cols.length) cols.push('1fr');
      return cols.join(' ');
    }
    var colsCss = getGridCols();
    try{ layoutRoot.style.setProperty('--grid-cols', colsCss); }catch(_){ }
		
    // Clear existing layout
    layoutRoot.innerHTML = '';
    sectionCards = {};
		
    if (isMultiAll) {
      dbg('DEBUG: Rendering multi-section view for', sectionKeys.length, 'sections');
      // Create a row for each section
      sectionKeys.forEach(function(sk, idx) {
        var sectionRow = document.createElement('div');
        // V1 forms each section as a single grid row container.
        sectionRow.className = 'sa-section-row';
        // Keep V2's dynamic column sizing (table width, charts/row) by applying --grid-cols per section.
        try{ sectionRow.style.setProperty('--grid-cols', colsCss); }catch(_){ }
				
        // Section title
        var sectionTitle = document.createElement('div');
        sectionTitle.className = 'sa-section-title';
        sectionTitle.textContent = 'Section: ' + sk;
        sectionRow.appendChild(sectionTitle);
				
        // Table card for this section
        var tCard = null;
        if(STATE.showTable){
          tCard = makeCard('Data Table', 'sa-table-card', '-' + idx);
          // Remove rounded corners for section tables
          tCard.card.style.borderRadius = '0';
          tCard.card.style.boxShadow = 'none';
          tCard.bottomRow.style.display = 'none';
          addTableModebar(tCard);
          tCard.inner.id = 'sa-table-wrap-sec' + idx;
          try{ tCard.inner.classList.add('sa-table-wrap'); }catch(_){ }
          if(!FILL_HEIGHT) tCard.inner.style.maxHeight = TABLE_HEIGHT + 'px';
          var sum = document.createElement('div');
          sum.className = 'sa-table-filter-summary';
          sum.id = 'sa-table-filter-summary-sec' + idx;
          tCard.inner.appendChild(sum);
          var tbl = document.createElement('table'); tbl.id = 'sa-table-sec' + idx; tCard.inner.appendChild(tbl);
          sectionRow.appendChild(tCard.card);
        }
				
				
        // Charts for this section
        var charts = {};
        var shownCharts = [];
        for(var i=1;i<=CHART_COUNT;i++){
          if(!isChartShown(i)) continue;
          var def = CHART_DEFS[i-1] || {};
          var title = def.title || ('Chart ' + i);
          var c = makeCard(title, chartCardId(i), '-' + idx);
          c.bottomRow.style.display = 'none';
          // Keep charts readable regardless of table row count / fill-height.
          // In multi-section view, grid row height otherwise follows the (possibly short) table.
          c.inner.style.minHeight = CHART_HEIGHT + 'px';
          c.card.style.minHeight = CHART_HEIGHT + 'px';
          addChartModebar(c, String(i) + '-' + idx);
          sectionRow.appendChild(c.card);
          charts[i] = c;
          shownCharts.push(c);
        }

        // Horizontal layout + charts-per-row stacking: keep table pinned on the left and stack charts in the right column.
        try{
          if(LAYOUT === 'H' && (CHARTS_PER_ROW||2) <= 1){
            var startRow = 2; // row 1 is the section title
            if(tCard && tCard.card){
              tCard.card.style.gridColumn = '1';
              tCard.card.style.gridRow = startRow + ' / span ' + Math.max(1, shownCharts.length);
            }
            shownCharts.forEach(function(cc, ii){
              if(!cc || !cc.card) return;
              cc.card.style.gridColumn = '2';
              cc.card.style.gridRow = (startRow + ii) + '';
            });
          }
        }catch(_gp){ }
				
        layoutRoot.appendChild(sectionRow);
				
        // Store references
        sectionCards[sk] = { table: tCard, charts: charts, section: sk, index: idx };
      });
			
      // Render all sections
      sectionKeys.forEach(function(sk, idx) {
        if(STATE.showTable) renderTableForSection(sk, idx);
        for(var i=1;i<=CHART_COUNT;i++){
          if(!isChartShown(i)) continue;
          renderChartForSection(String(i) + '-' + idx, sk);
        }
      });

      // Multi-pass resize: OAS can finalize widths after our initial frame.
      try{ deferredLayoutRefresh({rerender:false}); }catch(_dr){ }

      // After multi-section DOM rebuilds, do a deferred resize pass (Plotly can measure 0px)
      try{
        requestAnimationFrame(function(){
          try{ applyAutoSizing(); }catch(_){ }
          try{ resizeCharts(); }catch(_2){ }
        });
      }catch(_){
        setTimeout(function(){
          try{ applyAutoSizing(); }catch(_){ }
          try{ resizeCharts(); }catch(_2){ }
        }, 30);
      }

    } else {
      dbg('DEBUG: Rendering single view mode for section:', STATE.currentSection);
      // Single view mode
      tableCard = null;
      if(STATE.showTable){
        tableCard = makeCard('Data Table', 'sa-table-card');
        // Remove rounded corners for main table
        tableCard.card.style.borderRadius = '0';
        tableCard.card.style.boxShadow = 'none';
        tableCard.bottomRow.style.display = 'none';
        addTableModebar(tableCard);
        tableCard.inner.id = 'sa-table-wrap';
        if(!FILL_HEIGHT) tableCard.inner.style.maxHeight = TABLE_HEIGHT + 'px';
        var sum = document.createElement('div');
        sum.className = 'sa-table-filter-summary';
        sum.id = 'sa-table-filter-summary';
        tableCard.inner.appendChild(sum);
        var tbl = document.createElement('table'); tbl.id = 'sa-table'; tableCard.inner.appendChild(tbl);
        layoutRoot.appendChild(tableCard.card);
      }

      var chartCards = {};
      var shownCharts = [];
      for(var i=1;i<=CHART_COUNT;i++){
        if(!isChartShown(i)) continue;
        var def = CHART_DEFS[i-1] || {};
        var title = def.title || ('Chart ' + i);
        var c = makeCard(title, chartCardId(i));
        c.bottomRow.style.display = 'none';
        // Keep charts readable regardless of table visibility/fill-height.
        c.inner.style.minHeight = CHART_HEIGHT + 'px';
        c.card.style.minHeight = CHART_HEIGHT + 'px';
        addChartModebar(c, i);
        layoutRoot.appendChild(c.card);
        chartCards[i] = c;
        shownCharts.push(c);
      }

      // Horizontal layout + charts-per-row stacking: keep table pinned on the left and stack charts in the right column.
      try{
        if(LAYOUT === 'H' && (CHARTS_PER_ROW||2) <= 1){
          if(tableCard && tableCard.card){
            tableCard.card.style.gridColumn = '1';
            tableCard.card.style.gridRow = '1 / span ' + Math.max(1, shownCharts.length);
          }
          shownCharts.forEach(function(cc, ii){
            if(!cc || !cc.card) return;
            cc.card.style.gridColumn = '2';
            cc.card.style.gridRow = (1 + ii) + '';
          });
        }
      }catch(_gp2){ }
			
      dbg('DEBUG: About to call renderTable and renderChart(N)');
      if(STATE.showTable) renderTable();
      applyAutoSizing();
      for(var i=1;i<=CHART_COUNT;i++){
        if(!isChartShown(i)) continue;
        renderChart(i);
      }
        dbg('DEBUG: Finished calling render functions');

      // After DOM rebuilds, Plotly can occasionally measure 0px (notably in Vertical layout
      // or when the Data Table card is toggled). Resize once on the next frame.
      try{
        requestAnimationFrame(function(){
          try{ applyAutoSizing(); }catch(_){ }
          try{ resizeCharts(); }catch(_2){ }
        });
      }catch(_){
        setTimeout(function(){
          try{ applyAutoSizing(); }catch(_){ }
          try{ resizeCharts(); }catch(_2){ }
        }, 30);
      }

      // Multi-pass resize: helps Plotly fill available width in OAS.
      try{ deferredLayoutRefresh({rerender:false}); }catch(_dr2){ }

    }
  }

  // Initial build
  rebuildLayout();

  // FILTER UI
  var filterOverlay = document.createElement('div'); filterOverlay.className = 'sa-filter-overlay'; rootHost.appendChild(filterOverlay);
  var filterDialog = document.createElement('div'); filterDialog.className = 'sa-filter-dialog';
  filterDialog.innerHTML = '\n    <div class="sa-filter-close-btn" onclick="document.querySelector(\'sa-filter-overlay\').classList.remove(\'show\'); this.parentElement.classList.remove(\'show\');">&times;</div>\n    <div class="sa-filter-title">Filter Data</div>\n    <div class="sa-filter-group">\n      <label class="sa-filter-label">X Values Between</label>\n      <div class="sa-filter-inputs">\n        <input type="number" id="filter-x-min" placeholder="Min" step="0.01">\n        <input type="number" id="filter-x-max" placeholder="Max" step="0.01">\n      </div>\n    </div>\n    <div class="sa-filter-group">\n      <label class="sa-filter-label">Y Values Between</label>\n      <div class="sa-filter-inputs">\n        <input type="number" id="filter-y-min" placeholder="Min" step="0.01">\n        <input type="number" id="filter-y-max" placeholder="Max" step="0.01">\n      </div>\n    </div>\n    <div class="sa-filter-checkbox">\n      <input type="checkbox" id="filter-ex-out"> <label for="filter-ex-out" style="font-size:11px;">Exclude outliers</label>\n    </div>\n    <div class="sa-filter-buttons">\n      <button class="apply">Apply</button><button class="clear">Clear</button>\n    </div>\n  ';
  rootHost.appendChild(filterDialog);

  function showFilterDialog(chartId) {
    filterDialog.classList.add('show'); filterOverlay.classList.add('show');
    document.getElementById('filter-x-min').value = STATE.filterX.min ?? '';
    document.getElementById('filter-x-max').value = STATE.filterX.max ?? '';
    document.getElementById('filter-y-min').value = STATE.filterY.min ?? '';
    document.getElementById('filter-y-max').value = STATE.filterY.max ?? '';
    document.getElementById('filter-ex-out').checked = STATE.excludeOutliers;
    var applyBtn = filterDialog.querySelector('.apply');
    var clearBtn = filterDialog.querySelector('.clear');
    applyBtn.onclick = function(){
      STATE.filterX = {min: parseFloat(document.getElementById('filter-x-min').value) || null, max: parseFloat(document.getElementById('filter-x-max').value) || null};
      STATE.filterY = {min: parseFloat(document.getElementById('filter-y-min').value) || null, max: parseFloat(document.getElementById('filter-y-max').value) || null};
      STATE.excludeOutliers = document.getElementById('filter-ex-out').checked;
      hideFilter();
      renderChart(chartId);
    };
    clearBtn.onclick = function(){
      document.getElementById('filter-x-min').value=''; document.getElementById('filter-x-max').value='';
      document.getElementById('filter-y-min').value=''; document.getElementById('filter-y-max').value='';
      document.getElementById('filter-ex-out').checked = false;
      STATE.filterX = {min:null,max:null}; STATE.filterY = {min:null,max:null}; STATE.excludeOutliers=false;
      hideFilter();
    };
  }
  function hideFilter(){ filterDialog.classList.remove('show'); filterOverlay.classList.remove('show'); }

  // MODEBAR HELPERS
  var renderTimers = {};
  function debounceRender(key, func, delay) { if(renderTimers[key]) clearTimeout(renderTimers[key]); renderTimers[key] = setTimeout(func, delay || 100); }
  function escapeHtml(s){
    s = String(s==null?'':s);
    return s.replace(/[&<>"']/g, function(ch){
      return ch==='&'?'&amp;':(ch==='<'?'&lt;':(ch==='>'?'&gt;':(ch==='\"'?'&quot;':'&#39;')));
    });
  }

  var __saOpenMenuPops = [];
  function __saIsPopOpen(key){
    try{ return !!(__saOpenMenuPops && __saOpenMenuPops.some(function(p){ return p && p.__key===key; })); }
    catch(_){ return false; }
  }
  function __saOpenMenuPop(key, anchorEl, title, innerHtml, onReady){
    var already = __saIsPopOpen(key);
    closeAllMenus();
    if(already) return null;

    var pop=document.createElement('div');
    pop.className='menu-pop';
    pop.__key = key;
    pop.innerHTML =
      '<div class="hdr hdr-top"><span class="ttl">'+escapeHtml(title)+'</span><button class="xbtn" data-act="close" title="Close">×</button></div>' +
      (innerHtml || '');

    try{ (rootHost || document.body).appendChild(pop); }catch(e){ document.body.appendChild(pop); }
    __saOpenMenuPops.push(pop);

    function place(){
      var r = (anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {right:innerWidth-14, bottom:54, left:innerWidth-260, top:20};
      var pw=pop.offsetWidth, ph=pop.offsetHeight;
      var top=r.bottom+6;
      var left=(r.right!=null ? (r.right - pw) : (r.left||6));
      top=Math.max(6, Math.min(top, innerHeight - ph - 6));
      left=Math.max(6, Math.min(left, innerWidth - pw - 6));
      pop.style.top=top+'px';
      pop.style.left=left+'px';
    }
    place();

    var rePos = function(){ try{ place(); }catch(_){ } };
    window.addEventListener('resize', rePos);
    window.addEventListener('scroll', rePos, {passive:true});
    pop.__cleanup = function(){
      try{ window.removeEventListener('resize', rePos); }catch(_){ }
      try{ window.removeEventListener('scroll', rePos, {passive:true}); }catch(_){ }
    };

    var x = pop.querySelector('[data-act="close"]');
    if(x) x.onclick=function(ev){ ev.stopPropagation(); closeAllMenus(); };

    if(typeof onReady==='function'){
      try{ onReady(pop); }catch(_){ }
    }
    return pop;
  }
  function closeAllMenus(){
    __saOpenMenuPops.forEach(function(pop){
      try{ if(pop && typeof pop.__onClose==='function') pop.__onClose(); }catch(_0){}
      try{ if(pop && typeof pop.__cleanup==='function') pop.__cleanup(); }catch(e){}
      try{ if(pop && pop.parentNode) pop.parentNode.removeChild(pop); }catch(e2){}
    });
    __saOpenMenuPops = [];
  }

  function fmtNum(v, dec){
    if(v==null || !isFinite(v)) return '';
    var d = (dec==null || !isFinite(dec)) ? 4 : dec;
    try{ return Number(v).toFixed(d); }catch(_){ return String(v); }
  }
  function statsSummaryForPoints(points){
    var n = points && points.length ? points.length : 0;
    if(!n) return null;

    function cleanNums(arr){
      return (arr||[]).map(function(v){ return Number(v); }).filter(function(v){ return isFinite(v); });
    }
    function mean(a){
      if(!a || !a.length) return NaN;
      var s=0; for(var i=0;i<a.length;i++) s+=a[i];
      return s/a.length;
    }
    function std(a){
      if(!a || a.length<2) return NaN;
      var m=mean(a); var ss=0;
      for(var i=0;i<a.length;i++){ var d=a[i]-m; ss+=d*d; }
      return Math.sqrt(ss/(a.length-1));
    }
    function quantileSorted(sorted, q){
      if(!sorted || !sorted.length) return NaN;
      var pos = (sorted.length - 1) * q;
      var base = Math.floor(pos);
      var rest = pos - base;
      if(sorted[base+1] !== undefined) return sorted[base] + rest * (sorted[base+1]-sorted[base]);
      return sorted[base];
    }
    function statPack(vals){
      vals = cleanNums(vals);
      if(!vals.length) return null;
      var sorted = vals.slice().sort(function(a,b){return a-b;});
      var q1 = quantileSorted(sorted, 0.25);
      var med = quantileSorted(sorted, 0.50);
      var q3 = quantileSorted(sorted, 0.75);
      var iqr = (isFinite(q3) && isFinite(q1)) ? (q3-q1) : NaN;
      var lf = (isFinite(iqr) && isFinite(q1)) ? (q1 - 1.5*iqr) : NaN;
      var uf = (isFinite(iqr) && isFinite(q3)) ? (q3 + 1.5*iqr) : NaN;
      return {
        n: sorted.length,
        min: sorted[0],
        max: sorted[sorted.length-1],
        mean: mean(sorted),
        std: std(sorted),
        q1: q1,
        median: med,
        q3: q3,
        iqr: iqr,
        lfence: lf,
        ufence: uf
      };
    }

    var xs = points.map(function(p){ return p.x; });
    var ys = points.map(function(p){ return p.y; });
    return { n:n, x: statPack(xs), y: statPack(ys) };
  }
  function buildStatsPopoverHtml(chartNum, whichKey){
    // If this is a section-suffixed chart key (e.g. '1-0'), temporarily scope stats to that section.
    var originalSection = null;
    try{
      if(typeof whichKey === 'string'){
        var di = whichKey.indexOf('-');
        if(di > 0){
          var idx = parseInt(whichKey.slice(di+1), 10);
          if(isFinite(idx) && sectionKeys && sectionKeys[idx] != null){
            originalSection = STATE.currentSection;
            STATE.currentSection = sectionKeys[idx];
          }
        }
      }
    }catch(_s){}

    var pts = getChartPoints(chartNum);
    var yLbl = getYLabel(chartNum);
    var s = statsSummaryForPoints(pts);
    var outMask = null;
    try{ outMask = getOutliers(pts, STATE.outlierMethod); }catch(_){ outMask = null; }
    var outN = 0;
    if(outMask && outMask.length){ for(var i=0;i<outMask.length;i++) if(outMask[i]) outN++; }
    var reg = null;
    try{ if(whichKey!=null) reg = STATE['lastRegKey:'+String(whichKey)] || null; }catch(_r){}
    if(!reg) reg = STATE['lastReg'+chartNum] || null;

    var html='';
    html += '<div style="max-width:640px">';
    if(!s || !s.x || !s.y){
      html += '<div style="opacity:.8">No data points available.</div>';
      html += '</div>';
      try{ if(originalSection!=null) STATE.currentSection = originalSection; }catch(_rs){}
      return html;
    }

    var outPct = s.n ? Math.round((outN*1000)/s.n)/10 : 0;
    var xDec = DEC_X;
    var yDec = getDecY(chartNum);

        var cTitle = '';
        try{ cTitle = (CHART_DEFS && CHART_DEFS[chartNum-1] && CHART_DEFS[chartNum-1].title) ? String(CHART_DEFS[chartNum-1].title) : ('Chart ' + chartNum); }catch(_t){ cTitle = 'Chart ' + chartNum; }
        html += '<div class="sa-stats-head">'
          + '<div class="ttl">' + escapeHtml(cTitle) + '</div>'
          + '<div class="acts">'
          +   '<button class="ico" data-act="stats-fs" title="Fullscreen">'+iconSvg(fullI)+'</button>'
          + '</div>'
          + '</div>';
    html += '<div class="sa-stat-scroller">';
    html += '<table class="sa-stat-table">'
      + '<thead>'
      + '<tr>'
      + '<th style="text-align:left">Metric</th>'
      + '<th>'+escapeHtml(combLabel)+'</th>'
      + '<th>'+escapeHtml(yLbl)+'</th>'
      + '</tr>'
      + '</thead>'
      + '<tbody>'
      + '<tr><td>N</td><td>'+s.n+'</td><td>'+s.n+'</td></tr>'
      + '<tr><td>Mean</td><td>'+fmtNum(s.x.mean, xDec)+'</td><td>'+fmtNum(s.y.mean, yDec)+'</td></tr>'
      + '<tr><td>Std</td><td>'+fmtNum(s.x.std, xDec)+'</td><td>'+fmtNum(s.y.std, yDec)+'</td></tr>'
      + '<tr><td>Min</td><td>'+fmtNum(s.x.min, xDec)+'</td><td>'+fmtNum(s.y.min, yDec)+'</td></tr>'
      + '<tr><td>Q1</td><td>'+fmtNum(s.x.q1, xDec)+'</td><td>'+fmtNum(s.y.q1, yDec)+'</td></tr>'
      + '<tr><td>Median</td><td class="med">'+fmtNum(s.x.median, xDec)+'</td><td class="med">'+fmtNum(s.y.median, yDec)+'</td></tr>'
      + '<tr><td>Q3</td><td>'+fmtNum(s.x.q3, xDec)+'</td><td>'+fmtNum(s.y.q3, yDec)+'</td></tr>'
      + '<tr><td>Max</td><td>'+fmtNum(s.x.max, xDec)+'</td><td>'+fmtNum(s.y.max, yDec)+'</td></tr>'
      + '<tr><td>IQR</td><td>'+fmtNum(s.x.iqr, xDec)+'</td><td>'+fmtNum(s.y.iqr, yDec)+'</td></tr>'
      + '<tr><td>Lower fence</td><td>'+fmtNum(s.x.lfence, xDec)+'</td><td>'+fmtNum(s.y.lfence, yDec)+'</td></tr>'
      + '<tr><td>Upper fence</td><td>'+fmtNum(s.x.ufence, xDec)+'</td><td>'+fmtNum(s.y.ufence, yDec)+'</td></tr>'
      + '</tbody></table>';
    html += '</div>';

    html += '<div style="margin-top:8px;opacity:.9">Outliers: <b>'+outN+'</b> ('+outPct+'%) \u007C method <b>'+escapeHtml(String(STATE.outlierMethod||'kmeans'))+'</b></div>';

    html += '<div class="hdr" style="margin-top:12px">Regression</div>';
    if(!reg || reg.method==='none'){
      html += '<div style="opacity:.8">Regression is off for this chart.</div>';
    } else {
      html += '<table style="width:100%;border-collapse:collapse;font-size:12px">'
        + '<tbody>'
        + '<tr><td style="padding:4px 6px;border:1px solid #e5e7eb">Method</td><td style="padding:4px 6px;border:1px solid #e5e7eb">'+escapeHtml(String(reg.method||'linear'))+'</td></tr>'
        + '<tr><td style="padding:4px 6px;border:1px solid #e5e7eb">Slope</td><td style="padding:4px 6px;border:1px solid #e5e7eb">'+fmtNum(reg.slope, 6)+'</td></tr>'
        + '<tr><td style="padding:4px 6px;border:1px solid #e5e7eb">Intercept</td><td style="padding:4px 6px;border:1px solid #e5e7eb">'+fmtNum(reg.intercept, 6)+'</td></tr>'
        + '<tr><td style="padding:4px 6px;border:1px solid #e5e7eb">R²</td><td style="padding:4px 6px;border:1px solid #e5e7eb">'+fmtNum(reg.r2, 4)+'</td></tr>'
        + '</tbody></table>';
    }

    html += '<div class="sep"></div>';
    html += '<div style="opacity:.85">This table is chart-specific and does not affect the main Data Table.</div>';
    html += '</div>';
    try{ if(originalSection!=null) STATE.currentSection = originalSection; }catch(_rr){}
    return html;
  }

  document.addEventListener('click', function(e){
    if(!e.target.closest('.sa-dropdown') && !e.target.closest('.sa-filter-dialog') && !e.target.closest('.sa-panel-close') && !e.target.closest('.menu-pop')) closeAllMenus();
  });
  document.addEventListener('keydown', function(e){ if(e.key==='Escape'){ closeAllMenus(); hideFilter(); }});

  function saCopyText(text){
    try{
      if(navigator && navigator.clipboard && navigator.clipboard.writeText) return navigator.clipboard.writeText(String(text||''));
    }catch(_){ }
    try{
      var ta=document.createElement('textarea');
      ta.value=String(text||'');
      ta.style.position='fixed';
      ta.style.left='-9999px';
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
    }catch(_2){}
  }

  function createIconBtn(icon, title, onclick){ var b=document.createElement('button'); b.className='sa-btn'; b.title=title; b.innerHTML=icon; b.onclick=function(e){ e.stopPropagation(); closeAllMenus(); onclick(e); }; return b; }
  function createDropdownBtn(icon, title, items){
    var d=document.createElement('div'); d.className='sa-dropdown';
    var b=document.createElement('button'); b.className='sa-btn'; b.title=title; b.innerHTML=icon;
    function buildPop(){
      var pop=document.createElement('div');
      pop.className='menu-pop vlist';
      pop.__ownerBtn = b;
      var html='';
      html += '<div class="hdr hdr-top"><span class="ttl">' + escapeHtml(title) + '</span><button class="xbtn" data-act="close" title="Close">×</button></div>';
      items.forEach(function(item, idx){
        var lbl = String(item && item.label != null ? item.label : '');
        var isSep = /^(\s*[\u2500\u2014\-]{3,}\s*.*\s*[\u2500\u2014\-]{3,}\s*)$/.test(lbl) || /^\s*[\u2500\u2014\-]{6,}\s*$/.test(lbl);
        if(isSep){
          // Convert separator rows into a subtle heading
          var t = lbl.replace(/[\u2500\u2014\-]/g,'').trim();
          if(!t) html += '<div class="sep"></div>';
          else html += '<div class="hdr" style="margin-top:6px;opacity:.85">' + escapeHtml(t) + '</div>';
          return;
        }

        var checked = (item && item.stateGetter) ? !!item.stateGetter() : false;
        var disabled = !!(item && item.disabled);
        html += '<button class="item" type="button" data-idx="' + idx + '"' + (disabled?' disabled':'') + '>' + (item && item.stateGetter ? (checked?'✓ ':'') : '') + escapeHtml(lbl) + '</button>';
      });
      pop.innerHTML = html;

      // Position near the triggering button
      var r = b.getBoundingClientRect();
      try{ (rootHost || document.body).appendChild(pop); }catch(e){ document.body.appendChild(pop); }
      __saOpenMenuPops.push(pop);
      var pw=pop.offsetWidth, ph=pop.offsetHeight;
      var top=r.bottom+6;
      var left=(r.right!=null ? (r.right - pw) : r.left);
      top=Math.max(6, Math.min(top, innerHeight - ph - 6));
      left=Math.max(6, Math.min(left, innerWidth - pw - 6));
      pop.style.top=top+'px';
      pop.style.left=left+'px';

      pop.querySelector('[data-act="close"]').onclick=function(ev){ ev.stopPropagation(); closeAllMenus(); };
      pop.onclick=function(ev){
        ev.stopPropagation();
        var t=ev.target;
        if(!t) return;
        var idxStr = t.getAttribute && t.getAttribute('data-idx');
        if(idxStr==null) return;
        var idx = parseInt(idxStr, 10);
        if(!isFinite(idx) || !items[idx]) return;
        if(items[idx].disabled) return;
        try{ items[idx].action && items[idx].action(); }catch(e){}
        // Refresh checkmarks in place (keep menu open like old behavior)
        setTimeout(function(){
          try{
            pop.querySelectorAll('button[data-idx]').forEach(function(btn){
              var i = parseInt(btn.getAttribute('data-idx'), 10);
              var it = items[i];
              if(!it) return;
              var base = String(it.label==null?'':it.label);
              var on = it.stateGetter ? !!it.stateGetter() : false;
              btn.innerHTML = (it.stateGetter ? (on?'✓ ':'') : '') + escapeHtml(base);
            });
          }catch(e2){}
        }, 40);
      };
    }

    b.onclick=function(e){
      e.stopPropagation();
      // Toggle (same button closes; different button switches)
      var isThisOpen = false;
      try{
        isThisOpen = !!(__saOpenMenuPops && __saOpenMenuPops.some(function(p){ return p && p.__ownerBtn === b; }));
      }catch(_){ isThisOpen = false; }
      closeAllMenus();
      if(!isThisOpen) buildPop();
    };

    d.appendChild(b);
    return d;
  }
  // Legend hover highlight (LineTrend-style)
  function legendTraceIndicesForLegendHover(gd){
    var d = (gd && gd.data && gd.data.length) ? gd.data : null;
    if(!d) return null;
    var idx=[];
    for(var i=0;i<d.length;i++){
      var tr=d[i];
      if(!tr) continue;
      var t=String(tr.type||'scatter');
      var eligible=(t==='scatter' || t==='scattergl' || t==='bar' || t==='histogram');
      if(!eligible) continue;
      var show=(tr.showlegend!==false) && (tr.visible!==false) && (tr.name!=null && String(tr.name)!=='');
      if(!show) continue;
      idx.push(i);
    }
    if(idx.length<2 || idx.length>60) return null;
    return idx;
  }

  function snapshotLegendHoverStyles(gd, idxs){
    var d=(gd && gd.data) ? gd.data : [];
    var snap={idxs: idxs.slice(), opacity: [], lineWidth: [], markerLineWidth: [], markerLineColor: []};
    function scalarNumOrNull(v){ return (typeof v==='number' && isFinite(v)) ? v : null; }
    for(var k=0;k<idxs.length;k++){
      var i=idxs[k];
      var tr=d[i]||{};
      snap.opacity.push((typeof tr.opacity==='number' && isFinite(tr.opacity)) ? tr.opacity : 1);
      snap.lineWidth.push(scalarNumOrNull(tr.line && tr.line.width));
      var mlw = tr.marker && tr.marker.line ? tr.marker.line.width : null;
      snap.markerLineWidth.push((mlw && mlw.length) ? null : scalarNumOrNull(mlw));
      var mlc = tr.marker && tr.marker.line ? tr.marker.line.color : null;
      snap.markerLineColor.push(mlc==null ? null : String(mlc));
    }
    return snap;
  }

  function legendTraceHighlight(gd, curveNumber){
    try{
      var idxs=legendTraceIndicesForLegendHover(gd);
      if(!idxs) return;
      var idx = (typeof curveNumber==='number' && isFinite(curveNumber)) ? curveNumber : null;
      if(idx==null || !gd.data || !gd.data[idx]) return;
      if(idxs.indexOf(idx)===-1) return;

      var now=Date.now();
      if(gd.__legendHoverLastIdx===idx && gd.__legendHoverLastTs && (now-gd.__legendHoverLastTs)<40) return;
      gd.__legendHoverLastIdx=idx;
      gd.__legendHoverLastTs=now;

      if(gd.__legendDimActive) legendTraceReset(gd);

      var hi = (STATE.theme==='dark') ? '#fbbf24' : '#f59e0b';
      var snap=snapshotLegendHoverStyles(gd, idxs);
      gd.__legendDimActive=true;
      gd.__legendDimSnapshot=snap;
      Plotly.restyle(gd, {opacity:0.22}, idxs);

      var tr=gd.data[idx]||{};
      var t=String(tr.type||'scatter');
      var upd={opacity:1};
      if(t==='bar' || t==='histogram'){
        upd['marker.line.width']=2.5;
        upd['marker.line.color']=hi;
      }else{
        var base = (tr.line && typeof tr.line.width==='number') ? tr.line.width : 2;
        upd['line.width']=Math.min(10, Math.max(2.8, (base||2)+1.6));
        upd['marker.line.color']=hi;
      }
      Plotly.restyle(gd, upd, [idx]);
    }catch(e){}
  }

  function legendTraceReset(gd){
    try{
      var snap=gd && gd.__legendDimSnapshot;
      if(!gd || !gd.__legendDimActive || !snap || !snap.idxs) return;
      Plotly.restyle(gd, {opacity:snap.opacity,'line.width':snap.lineWidth,'marker.line.width':snap.markerLineWidth,'marker.line.color':snap.markerLineColor}, snap.idxs);
      gd.__legendDimActive=false;
      gd.__legendDimSnapshot=null;
    }catch(e){}
  }

  function bindLegendHover(targetId){
    try{
      var gd=document.getElementById(targetId);
      if(!gd || gd.__legendHoverInit) return;
      gd.__legendHoverInit=true;
      gd.__legendDimActive=false;
      gd.__legendDimSnapshot=null;
      gd.__legendHoverLastIdx=null;
      gd.__legendHoverLastTs=0;
      gd.on('plotly_legendhover', function(ev){ legendTraceHighlight(gd, ev && ev.curveNumber); });
      gd.on('plotly_legendunhover', function(){ legendTraceReset(gd); });
    }catch(e){}
  }

  function addTableModebar(card){
    var modebar = card.modebar;

    function refreshTablesOnly(){
      try{
        if(!STATE.showTable) return;
        var isMultiAll = (ENABLE_MULTI_SECTION && STATE.currentSection === 'All' && sectionKeys.length > 1);
        if(isMultiAll){
          sectionKeys.forEach(function(sk, idx){
            try{ renderTableForSection(sk, idx); }catch(_){ }
          });
        } else {
          try{ renderTable(); }catch(_){ }
        }
      }catch(_){ }
    }

    // Table Filter (single-column between)
    (function(){
      var btn = document.createElement('button');
      btn.className = 'sa-btn';
      btn.title = 'Filter table';
      btn.innerHTML = iconSvg(filtI);
      btn.onclick = function(e){
        e.stopPropagation();
        var key = 'table-filter';
        var already = __saIsPopOpen(key);
        closeAllMenus();
        if(already) return;

        var cols = __saTableFilterCols();
        var curCol = (STATE.tableFilter && STATE.tableFilter.colLabel) ? String(STATE.tableFilter.colLabel) : '';
        var curMin = (STATE.tableFilter && STATE.tableFilter.min != null) ? String(STATE.tableFilter.min) : '';
        var curMax = (STATE.tableFilter && STATE.tableFilter.max != null) ? String(STATE.tableFilter.max) : '';
        if(!curCol && cols && cols.length) curCol = cols[0];

        var html = '';
        html += '<div class="group" style="max-width:340px">';
        html += '<div class="hdr" style="margin-top:6px">Column</div>';
        html += '<div class="row" style="gap:8px;align-items:center">'
          + '<select id="tf-col" style="width:100%;padding:6px 8px;border:1px solid #cdd0d4;border-radius:8px;background:#fff;color:inherit">'
          + (cols||[]).map(function(lbl){
              var s = String(lbl||'');
              var sel = (s === curCol) ? ' selected' : '';
              return '<option value="'+escapeHtml(s)+'"'+sel+'>'+escapeHtml(s)+'</option>';
            }).join('')
          + '</select>'
          + '</div>';

        html += '<div class="hdr" style="margin-top:10px">Between</div>';
        html += '<div class="row" style="gap:8px;align-items:center;flex-wrap:nowrap">'
          + '<input id="tf-min" type="text" placeholder="Min" value="'+escapeHtml(curMin)+'" style="width:50%;min-width:120px">'
          + '<input id="tf-max" type="text" placeholder="Max" value="'+escapeHtml(curMax)+'" style="width:50%;min-width:120px">'
          + '</div>';

        html += '<div style="margin-top:8px;opacity:.8">Applies to the Data Table only (charts are unchanged).</div>';
        html += '<div class="row" style="margin-top:10px">'
          + '<button class="item" data-act="tf-apply" type="button" style="flex:1">Apply</button>'
          + '<button class="item" data-act="tf-clear" type="button" style="flex:1">Clear</button>'
          + '</div>';
        html += '</div>';

        __saOpenMenuPop(key, btn, 'Table Filter', html, function(popEl){
          function applyFromUI(){
            try{
              var colEl = popEl.querySelector('#tf-col');
              var minEl = popEl.querySelector('#tf-min');
              var maxEl = popEl.querySelector('#tf-max');
              var col = colEl ? String(colEl.value||'').trim() : '';
              var minV = minEl ? String(minEl.value||'').trim() : '';
              var maxV = maxEl ? String(maxEl.value||'').trim() : '';
              if(!col || (!minV && !maxV)){
                STATE.tableFilter = { colLabel: null, min: '', max: '' };
              } else {
                STATE.tableFilter = { colLabel: col, min: minV, max: maxV };
              }
              refreshTablesOnly();
              try{ deferredLayoutRefresh({rerender:false}); }catch(_){ }
            }catch(_){ }
          }

          popEl.addEventListener('click', function(ev){
            var act = ev && ev.target && ev.target.getAttribute && ev.target.getAttribute('data-act');
            if(!act) return;
            if(act==='tf-apply'){
              applyFromUI();
              closeAllMenus();
              return;
            }
            if(act==='tf-clear'){
              try{ STATE.tableFilter = { colLabel: null, min: '', max: '' }; }catch(_){ }
              refreshTablesOnly();
              closeAllMenus();
              return;
            }
          });
        });
      };
      modebar.appendChild(btn);
    })();

    // Download (CSV / Excel / Copy)
    modebar.appendChild(createDropdownBtn(iconSvg(downI),'Download',[
      {label:'CSV', action:function(){ downloadTableCSV(); }},
      {label:'Excel', action:function(){ downloadReportExcel(); }},
      {label:'Copy', action:function(){
        try{
          var rows = getSortedRows();
          var lines = [];
          lines.push(COLS.map(function(c){ return String(c.label||''); }).join('\t'));
          rows.forEach(function(r){
            lines.push(COLS.map(function(c){
              var v = r[c.label];
              var s = (v==null) ? '' : String(v);
              return s.replace(/\r?\n/g,' ');
            }).join('\t'));
          });
          saCopyText(lines.join('\n'));
        }catch(_){ }
      }}
    ]));
    // Fullscreen toggle
    modebar.appendChild(createIconBtn(iconSvg(fullI),'Fullscreen', function(){
      if(card.card.classList.contains('sa-fullscreen')){
        card.card.classList.remove('sa-fullscreen');
      } else {
        card.card.classList.add('sa-fullscreen');
      }
    }));
  }

  function addChartModebar(card, which){
    // Extract numeric chart number from both formats (1, 2 or '1-0', '2-0')
    var chartNum = typeof which === 'string' ? parseInt(which.charAt(0)) : which;
    var modebar = card.modebar;
    var resetBtn = createIconBtn(iconSvg(homeI),'Reset', function(){
      var defC = CHART_DEFS[chartNum-1] || {};
      STATE.filterX={min:null,max:null};
      STATE.filterY={min:null,max:null};
      STATE.excludeOutliers=false;
      STATE.removedIndices={};
      STATE['showOutliers'+chartNum]=true;
      STATE['showAvgX'+chartNum]=true;
      STATE['showAvgY'+chartNum]=true;
      STATE['showRegression'+chartNum]=true;
      STATE['showCI'+chartNum]=true;
      STATE['showRegTicks'+chartNum]=false;
      STATE['removeMode'+chartNum]=false;
      STATE['yMode'+chartNum]='auto';
      STATE['yMin'+chartNum]=null;
      STATE['yMax'+chartNum]=null;
      STATE['yScale'+chartNum]='linear';
      STATE['xMin'+chartNum]=null;
      STATE['xMax'+chartNum]=null;
      STATE['chartType'+chartNum]=normChartType(defC.defaultType || DEFAULT_CHART_TYPE || 'scatter');
      STATE['dragMode'+chartNum]='zoom';
      STATE['regressionMethod'+chartNum]=String(defC.defaultRegressionMethod || 'linear');
      STATE['histBins'+chartNum]=20;
      // per-chart targets
      STATE['targetsOn'+chartNum]=false;
      STATE['tXMin'+chartNum]=null; STATE['tXMax'+chartNum]=null;
      STATE['tYMin'+chartNum]=null; STATE['tYMax'+chartNum]=null;
      STATE['tXBand'+chartNum]=false; STATE['tYBand'+chartNum]=false;
      renderChart(which);
    });

    // View / Chart Type (menu-pop + inline bins; no prompt)
    var viewBtn = null;
    (function(){
      var btn = document.createElement('button');
      btn.className='sa-btn';
      btn.title='View';
      btn.innerHTML = iconSvg(typeI);
      btn.onclick=function(e){
        e.stopPropagation();
        var key='ctype-'+chartNum;
        var curType = STATE['chartType'+chartNum] || 'scatter';
        var curBins = parseInt(STATE['histBins'+chartNum]||10,10);
        if(!isFinite(curBins) || curBins<1) curBins=10;
        var showBins = (curType==='histogram' || curType==='hist+kde');
        var html = '';
        html += '<div class="group">';
        html += '<div class="hdr" style="margin-top:6px">Type</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="ct" value="scatter" '+(curType==='scatter'?'checked':'')+'><span>Scatter</span></label>'
          + '<label class="seg"><input type="radio" name="ct" value="histogram" '+(curType==='histogram'?'checked':'')+'><span>Histogram</span></label>'
          + '<label class="seg"><input type="radio" name="ct" value="hist+kde" '+(curType==='hist+kde'?'checked':'')+'><span>Hist + KDE</span></label>'
          + '</div>';
        if(showBins){
          html += '<div class="hdr" style="margin-top:10px">Histogram bins</div>';
          html += '<div class="row" style="gap:6px;flex-wrap:wrap">'
            + '<label class="seg"><input type="radio" name="bins" value="10" '+(curBins===10?'checked':'')+'><span>10</span></label>'
            + '<label class="seg"><input type="radio" name="bins" value="20" '+(curBins===20?'checked':'')+'><span>20</span></label>'
            + '<label class="seg"><input type="radio" name="bins" value="30" '+(curBins===30?'checked':'')+'><span>30</span></label>'
            + '</div>';
          html += '<div class="row" style="align-items:center;margin-top:6px">'
            + '<input id="bins-custom" type="number" min="1" step="1" value="'+escapeHtml(String(curBins))+'" style="width:90px;flex:0 0 90px">'
            + '<button class="item" data-act="bins-apply" type="button" style="flex:1">Apply</button>'
            + '<button class="item" data-act="bins-reset" type="button" style="flex:1">Reset</button>'
            + '</div>';
          html += '<div class="row" style="margin-top:8px">'
            + '<label><input type="checkbox" id="hist-counts" '+(STATE.showHistCounts?'checked':'')+'> Show Bar Counts</label>'
            + '</div>';
        }
        html += '</div>';

        __saOpenMenuPop(key, btn, 'View', html, function(popEl){
          popEl.addEventListener('change', function(ev){
            var t=ev && ev.target;
            if(!t) return;
            if(t.name==='ct'){
              STATE['chartType'+chartNum]=String(t.value||'scatter');
              renderChart(which);
              closeAllMenus();
              setTimeout(function(){ try{ btn.click(); }catch(_){} }, 0);
              return;
            }
            if(t.name==='bins'){
              var n=parseInt(String(t.value||''),10);
              if(isFinite(n) && n>0){ STATE['histBins'+chartNum]=n; renderChart(which); }
              return;
            }
            if(t.id==='hist-counts'){
              STATE.showHistCounts = !!t.checked;
              renderChart(which);
              return;
            }
          }, {passive:true});

          popEl.addEventListener('click', function(ev){
            var act = ev && ev.target && ev.target.getAttribute && ev.target.getAttribute('data-act');
            if(!act) return;
            if(act==='bins-apply'){
              var inp = popEl.querySelector('#bins-custom');
              var n = inp ? parseInt(String(inp.value||'').trim(),10) : NaN;
              if(isFinite(n) && n>0){ STATE['histBins'+chartNum]=n; renderChart(which); }
              closeAllMenus();
              return;
            }
            if(act==='bins-reset'){
              STATE['histBins'+chartNum]=10;
              renderChart(which);
              closeAllMenus();
              return;
            }
          });
        });
      };
      viewBtn = btn;
    })();

    // Statistics (shown below the chart like BoxPlot)
    var tableBtn = document.createElement('button');
    tableBtn.className = 'sa-btn';
    tableBtn.title = 'Statistics';
    tableBtn.innerHTML = iconSvg(tableI);
    (function(){
      function isShown(el){
        if(!el) return false;
        if(el.style && el.style.display) return el.style.display !== 'none';
        try{ return window.getComputedStyle(el).display !== 'none'; }catch(_){ return false; }
      }
      function hidePanel(statsEl){
        try{ statsEl.style.display = 'none'; statsEl.innerHTML=''; }catch(_){ }
        try{ STATE['showStatsTable'+chartNum]=false; }catch(_2){ }
        try{ tableBtn.classList.remove('active'); }catch(_3){ }
        try{ deferredLayoutRefresh({rerender:false}); }catch(_4){ try{ requestAnimationFrame(function(){ resizeCharts(); }); }catch(_5){ setTimeout(resizeCharts, 30); } }
      }
      function showPanel(statsEl){
        var html = buildStatsPopoverHtml(chartNum, String(which));
        statsEl.innerHTML = '<div class="sa-panel-close" title="Close">&times;</div>' + html;
        var x = statsEl.querySelector('.sa-panel-close');
        if(x) x.onclick = function(ev){ try{ ev.stopPropagation(); }catch(_){ } hidePanel(statsEl); };
        try{
          var fs = statsEl.querySelector('[data-act="stats-fs"]');
          if(fs) fs.onclick = function(ev){
            try{ ev.stopPropagation(); }catch(_){ }
            try{
              var cardEl = document.getElementById(chartCardDomId(which));
              if(cardEl) toggleFullscreen(cardEl, which);
            }catch(_2){ }
          };
        }catch(_f){ }
        statsEl.style.display = 'block';
        try{ STATE['showStatsTable'+chartNum]=true; }catch(_2){ }
        try{ tableBtn.classList.add('active'); }catch(_3){ }
        try{ deferredLayoutRefresh({rerender:false}); }catch(_4){ try{ requestAnimationFrame(function(){ resizeCharts(); }); }catch(_5){ setTimeout(resizeCharts, 30); } }
      }

      tableBtn.onclick = function(e){
        e.stopPropagation();
        closeAllMenus();
        var statsEl = document.getElementById(chartStatsDomId(which));
        if(!statsEl) return;
        if(isShown(statsEl)) hidePanel(statsEl);
        else showPanel(statsEl);
      };

      // Restore panel open state after layout rebuild
      setTimeout(function(){
        try{
          if(STATE['showStatsTable'+chartNum]){
            var statsEl = document.getElementById(chartStatsDomId(which));
            if(statsEl && !isShown(statsEl)) showPanel(statsEl);
          }
        }catch(_){ }
      }, 0);
    })();

    // Points / Labels / Legend (LineTrend-style segmented popover)
    var pointsBtn = null;
    (function(){
      var btn = document.createElement('button');
      btn.className='sa-btn';
      btn.title='Points \u2022 Labels \u2022 Legend';
      btn.innerHTML = iconSvg(dotsI);
      btn.onclick=function(e){
        e.stopPropagation();
        var key='pts-'+chartNum;
        // Keep UI options constrained to LineTrend parity
        var om = String(STATE.outlierMethod || 'kmeans');
        if(om!=='kmeans' && om!=='distance' && om!=='hierarchical'){
          STATE.outlierMethod = 'kmeans';
        }
        var pm = String(STATE['pointsMode'+chartNum] || 'auto');
        if(pm!=='auto' && pm!=='none' && pm!=='all') pm='auto';
        var lbl = !!STATE['showLabels'+chartNum];
        var lshow = !!STATE['showLegend'+chartNum];
        var lpos = String(STATE['legendPos'+chartNum] || 'auto');
        if(!lpos) lpos='auto';
        var outMode = STATE.excludeOutliers ? 'exclude' : 'show';
        var hov = STATE.showCell ? 'on' : 'off';

        var html='';
        html += '<div class="group">';
        html += '<div class="hdr">Points</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="pm" value="auto" '+(pm==='auto'?'checked':'')+'><span>Auto</span></label>'
          + '<label class="seg"><input type="radio" name="pm" value="none" '+(pm==='none'?'checked':'')+'><span>None</span></label>'
          + '<label class="seg"><input type="radio" name="pm" value="all" '+(pm==='all'?'checked':'')+'><span>All</span></label>'
          + '</div>';
        html += '<div class="hdr">Labels</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="lbl" value="off" '+(!lbl?'checked':'')+'><span>Off</span></label>'
          + '<label class="seg"><input type="radio" name="lbl" value="on" '+(lbl?'checked':'')+'><span>On</span></label>'
          + '</div>';
        html += '<div class="hdr">Legend</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="lshow" value="1" '+(lshow?'checked':'')+'><span>Show</span></label>'
          + '<label class="seg"><input type="radio" name="lshow" value="0" '+(!lshow?'checked':'')+'><span>Hide</span></label>'
          + '</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="lpos" value="auto" '+(lpos==='auto'?'checked':'')+'><span>Auto</span></label>'
          + '<label class="seg"><input type="radio" name="lpos" value="top" '+(lpos==='top'?'checked':'')+'><span>Top</span></label>'
          + '<label class="seg"><input type="radio" name="lpos" value="bottom" '+(lpos==='bottom'?'checked':'')+'><span>Bottom</span></label>'
          + '</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="lpos" value="left" '+(lpos==='left'?'checked':'')+'><span>Left</span></label>'
          + '<label class="seg"><input type="radio" name="lpos" value="right" '+(lpos==='right'?'checked':'')+'><span>Right</span></label>'
          + '</div>';

        html += '<div class="hdr">Outliers</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="out" value="show" '+(outMode==='show'?'checked':'')+'><span>Show</span></label>'
          + '<label class="seg"><input type="radio" name="out" value="exclude" '+(outMode==='exclude'?'checked':'')+'><span>Exclude</span></label>'
          + '</div>';

        html += '<div class="hdr">Hover</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="hov" value="on" '+(hov==='on'?'checked':'')+'><span>Cell On</span></label>'
          + '<label class="seg"><input type="radio" name="hov" value="off" '+(hov==='off'?'checked':'')+'><span>Cell Off</span></label>'
          + '</div>';

        html += '<div class="hdr">Detection</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="om" value="kmeans" '+(STATE.outlierMethod==='kmeans'?'checked':'')+'><span>KMeans</span></label>'
          + '<label class="seg"><input type="radio" name="om" value="distance" '+(STATE.outlierMethod==='distance'?'checked':'')+'><span>Distance</span></label>'
          + '<label class="seg"><input type="radio" name="om" value="hierarchical" '+(STATE.outlierMethod==='hierarchical'?'checked':'')+'><span>Hier</span></label>'
          + '</div>';
        html += '</div>';

        __saOpenMenuPop(key, btn, 'Points / Labels / Legend', html, function(popEl){
          popEl.addEventListener('change', function(ev){
            var t = ev && ev.target;
            if(!t) return;
            if(t.name==='pm'){ STATE['pointsMode'+chartNum]=String(t.value||'auto'); renderChart(which); return; }
            if(t.name==='lbl'){ STATE['showLabels'+chartNum]=(String(t.value)==='on'); renderChart(which); return; }
            if(t.name==='lshow'){ STATE['showLegend'+chartNum]=(String(t.value)==='1'); renderChart(which); return; }
            if(t.name==='lpos'){ STATE['legendPos'+chartNum]=String(t.value||'auto'); STATE['showLegend'+chartNum]=true; renderChart(which); return; }
            if(t.name==='out'){
              if(String(t.value)==='exclude'){ STATE.excludeOutliers=true; }
              else { STATE.excludeOutliers=false; STATE['showOutliers'+chartNum]=true; }
              renderChart(which);
              return;
            }
            if(t.name==='hov'){ STATE.showCell=(String(t.value)==='on'); renderChart(which); return; }
            if(t.name==='om'){ STATE.outlierMethod=String(t.value||'kmeans'); renderChart(which); return; }
          }, {passive:true});
        });
      };
      pointsBtn = btn;
    })();

    // Filter (menu-pop; replaces legacy .sa-dropdown-content)
    var filterBtn = null;
    (function(){
      var btn = document.createElement('button');
      btn.className='sa-btn';
      btn.title='Filter';
      try{ btn.setAttribute('data-kind','filter'); }catch(_){ }
      btn.innerHTML = iconSvg(filtI);

      function isFilterActive(){
        try{
          var fx = STATE.filterX || {}; var fy = STATE.filterY || {};
          return !!STATE.excludeOutliers || fx.min!=null || fx.max!=null || fy.min!=null || fy.max!=null;
        }catch(_){ return false; }
      }
      try{ btn.classList.toggle('active', isFilterActive()); }catch(_x){ }

      btn.onclick=function(e){
        e.stopPropagation();
        var key='filter-'+chartNum;
        var html = '';
        html += '<div class="group">';
        html += '<div class="hdr" style="margin-top:6px">X values between</div>';
        html += '<div class="row" style="gap:8px">'
          + '<input id="fx-min" type="number" placeholder="Min" step="0.01" style="width:110px;flex:0 0 110px">'
          + '<input id="fx-max" type="number" placeholder="Max" step="0.01" style="width:110px;flex:0 0 110px">'
          + '</div>';
        html += '<div class="hdr" style="margin-top:10px">Y values between</div>';
        html += '<div class="row" style="gap:8px">'
          + '<input id="fy-min" type="number" placeholder="Min" step="0.01" style="width:110px;flex:0 0 110px">'
          + '<input id="fy-max" type="number" placeholder="Max" step="0.01" style="width:110px;flex:0 0 110px">'
          + '</div>';
        html += '<div class="row" style="margin-top:10px">'
          + '<label><input type="checkbox" id="f-ex-out"> Exclude outliers</label>'
          + '</div>';
        html += '<div class="row" style="margin-top:10px">'
          + '<button class="item" data-act="f-apply" type="button" style="flex:1">Apply</button>'
          + '<button class="item" data-act="f-clear" type="button" style="flex:1">Clear</button>'
          + '</div>';
        html += '</div>';

        __saOpenMenuPop(key, btn, 'Filter', html, function(popEl){
          var xMinInput = popEl.querySelector('#fx-min');
          var xMaxInput = popEl.querySelector('#fx-max');
          var yMinInput = popEl.querySelector('#fy-min');
          var yMaxInput = popEl.querySelector('#fy-max');
          var exOutCheck = popEl.querySelector('#f-ex-out');
          if(xMinInput) xMinInput.value = (STATE.filterX && STATE.filterX.min!=null) ? STATE.filterX.min : '';
          if(xMaxInput) xMaxInput.value = (STATE.filterX && STATE.filterX.max!=null) ? STATE.filterX.max : '';
          if(yMinInput) yMinInput.value = (STATE.filterY && STATE.filterY.min!=null) ? STATE.filterY.min : '';
          if(yMaxInput) yMaxInput.value = (STATE.filterY && STATE.filterY.max!=null) ? STATE.filterY.max : '';
          if(exOutCheck) exOutCheck.checked = !!STATE.excludeOutliers;

          popEl.addEventListener('click', function(ev){
            var act = ev && ev.target && ev.target.getAttribute && ev.target.getAttribute('data-act');
            if(!act) return;
            if(act==='f-clear'){
              STATE.filterX = {min:null,max:null};
              STATE.filterY = {min:null,max:null};
              STATE.excludeOutliers=false;
              try{ btn.classList.toggle('active', false); }catch(_){ }
              renderChart(which);
              closeAllMenus();
              return;
            }
            if(act==='f-apply'){
              var fxMin = xMinInput ? parseFloat(String(xMinInput.value||'').trim()) : NaN;
              var fxMax = xMaxInput ? parseFloat(String(xMaxInput.value||'').trim()) : NaN;
              var fyMin = yMinInput ? parseFloat(String(yMinInput.value||'').trim()) : NaN;
              var fyMax = yMaxInput ? parseFloat(String(yMaxInput.value||'').trim()) : NaN;
              STATE.filterX = {min: isFinite(fxMin)?fxMin:null, max: isFinite(fxMax)?fxMax:null};
              STATE.filterY = {min: isFinite(fyMin)?fyMin:null, max: isFinite(fyMax)?fyMax:null};
              STATE.excludeOutliers = !!(exOutCheck && exOutCheck.checked);
              try{ btn.classList.toggle('active', isFilterActive()); }catch(_2){ }
              renderChart(which);
              closeAllMenus();
              return;
            }
          });
        });
      };
      filterBtn = btn;
    })();

    // Remove-mode toggle (click a point to remove)
    var removeBtn = document.createElement('button');
    removeBtn.className = 'sa-btn' + (STATE['removeMode'+chartNum] ? ' active' : '');
    removeBtn.title = 'Remove point';
    try{ removeBtn.setAttribute('data-kind','remove'); }catch(_){ }
    removeBtn.innerHTML = iconSvg(removeI);
    removeBtn.onclick = function(e){
      e.stopPropagation();
      closeAllMenus();
      STATE['removeMode'+chartNum] = !STATE['removeMode'+chartNum];
      renderChart(which);
      try{ removeBtn.classList.toggle('active', !!STATE['removeMode'+chartNum]); }catch(_){ }
    };

    // Stats (LineTrend-style segmented popover)
    var statusBtn = null;
    (function(){
      var btn = document.createElement('button');
      btn.className='sa-btn';
      btn.title='Stats';
      btn.innerHTML = iconSvg(statusI);
      btn.onclick=function(e){
        e.stopPropagation();
        var key='status-'+chartNum;
        var rm = String(STATE['regressionMethod'+chartNum] || 'linear');
        var html='';
        html += '<div class="group">';
        html += '<div class="hdr">Regression</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="rm" value="none" '+(rm==='none'?'checked':'')+'><span>Off</span></label>'
          + '<label class="seg"><input type="radio" name="rm" value="linear" '+(rm!=='none'?'checked':'')+'><span>Regression</span></label>'
          + '</div>';

        html += '<div class="hdr">Display</div>';
        html += '<div class="row">'
          + '<button class="item" type="button" data-act="disp-none">None</button>'
          + '<button class="item" type="button" data-act="disp-all">All</button>'
          + '</div>';

        function seg2(name, on, label){
          return '<div class="row" style="justify-content:space-between">'
            + '<div style="opacity:.9">'+label+'</div>'
            + '<div>'
            + '<label class="seg"><input type="radio" name="'+name+'" value="1" '+(on?'checked':'')+'><span>On</span></label>'
            + '<label class="seg"><input type="radio" name="'+name+'" value="0" '+(!on?'checked':'')+'><span>Off</span></label>'
            + '</div></div>';
        }

        html += seg2('ov_reg', !!STATE['showRegression'+chartNum], 'Regression line');
        html += seg2('ov_ticks', !!STATE['showRegTicks'+chartNum], 'Tick marks');
        html += seg2('ov_ci', !!STATE['showCI'+chartNum], '95% CI band');
        html += seg2('ov_xm', !!STATE['showAvgX'+chartNum], 'X mean');
        html += seg2('ov_ym', !!STATE['showAvgY'+chartNum], 'Y mean');
        html += '</div>';

        __saOpenMenuPop(key, btn, 'Stats', html, function(popEl){
          popEl.addEventListener('change', function(ev){
            var t=ev && ev.target;
            if(!t) return;
            if(t.name==='rm'){
              var v = String(t.value||'linear');
              STATE['regressionMethod'+chartNum] = (v==='none') ? 'none' : 'linear';
              STATE['showRegression'+chartNum] = (v!=='none');
              renderChart(which);
              return;
            }
            if(t.name==='ov_reg'){ STATE['showRegression'+chartNum]=(String(t.value)==='1'); renderChart(which); return; }
            if(t.name==='ov_ticks'){ STATE['showRegTicks'+chartNum]=(String(t.value)==='1'); renderChart(which); return; }
            if(t.name==='ov_ci'){ STATE['showCI'+chartNum]=(String(t.value)==='1'); renderChart(which); return; }
            if(t.name==='ov_xm'){ STATE['showAvgX'+chartNum]=(String(t.value)==='1'); renderChart(which); return; }
            if(t.name==='ov_ym'){ STATE['showAvgY'+chartNum]=(String(t.value)==='1'); renderChart(which); return; }
          }, {passive:true});
          popEl.addEventListener('click', function(ev){
            var act = ev && ev.target && ev.target.getAttribute && ev.target.getAttribute('data-act');
            if(!act) return;
            if(act==='disp-none'){
              STATE['showRegression'+chartNum]=false;
              STATE['showCI'+chartNum]=false;
              STATE['showAvgX'+chartNum]=false;
              STATE['showAvgY'+chartNum]=false;
              STATE['showRegTicks'+chartNum]=false;
              renderChart(which);
              closeAllMenus();
              return;
            }
            if(act==='disp-all'){
              STATE['showRegression'+chartNum]=true;
              STATE['showCI'+chartNum]=true;
              STATE['showAvgX'+chartNum]=true;
              STATE['showAvgY'+chartNum]=true;
              renderChart(which);
              closeAllMenus();
              return;
            }
          });
        });
      };
      statusBtn = btn;
    })();

    // Y axis (auto / manual / to-zero + log)
    var yBtn = null;
    (function(){
      var btn = document.createElement('button');
      btn.className='sa-btn';
      btn.title='Y axis';
      btn.innerHTML = iconSvg(yI);
      btn.onclick=function(e){
        e.stopPropagation();
        var key='yaxis-'+chartNum;
        var curMode = String(STATE['yMode'+chartNum] || 'auto');
        var curScale = String(STATE['yScale'+chartNum] || 'linear');
        var curType = String(STATE['chartType'+chartNum] || 'scatter');
        var html = '';
        html += '<div class="group">';
        html += '<div class="hdr" style="margin-top:6px">Scale</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="ys" value="linear" '+(curScale==='linear'?'checked':'')+'><span>Linear</span></label>'
          + '<label class="seg"><input type="radio" name="ys" value="log" '+(curScale==='log'?'checked':'')+'><span>Log</span></label>'
          + '</div>';
        html += '<div class="hdr" style="margin-top:10px">Range</div>';
        html += '<div class="row">'
          + '<label class="seg"><input type="radio" name="ym" value="auto" '+(curMode==='auto'?'checked':'')+'><span>Auto</span></label>'
          + '<label class="seg"><input type="radio" name="ym" value="tozero" '+(curMode==='tozero'?'checked':'')+'><span>0-based</span></label>'
          + '<label class="seg"><input type="radio" name="ym" value="manual" '+(curMode==='manual'?'checked':'')+'><span>Manual</span></label>'
          + '</div>';
        html += '<div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">'
          + '<input id="y-min" type="number" step="0.01" placeholder="Min" style="width:110px;flex:0 0 110px">'
          + '<input id="y-max" type="number" step="0.01" placeholder="Max" style="width:110px;flex:0 0 110px">'
          + '</div>';
        html += '<div class="row" style="margin-top:10px">'
          + '<button class="item" data-act="y-apply" type="button" style="flex:1">Apply</button>'
          + '<button class="item" data-act="y-reset" type="button" style="flex:1">Reset</button>'
          + '</div>';

        // Scatter: allow X-axis manual range entry inside this menu
        if(curType === 'scatter'){
          html += '<div class="sep"></div>';
          html += '<div class="hdr" style="margin-top:6px">X range (Scatter)</div>';
          html += '<div class="row" style="gap:8px;flex-wrap:wrap;margin-top:6px">'
            + '<input id="x-min" type="number" step="0.01" placeholder="Min" style="width:110px;flex:0 0 110px">'
            + '<input id="x-max" type="number" step="0.01" placeholder="Max" style="width:110px;flex:0 0 110px">'
            + '</div>';
          html += '<div class="row" style="margin-top:10px">'
            + '<button class="item" data-act="x-apply" type="button" style="flex:1">Apply</button>'
            + '<button class="item" data-act="x-reset" type="button" style="flex:1">Reset</button>'
            + '</div>';
        }
        html += '</div>';

        __saOpenMenuPop(key, btn, 'Y axis', html, function(popEl){
          var yMinI = popEl.querySelector('#y-min');
          var yMaxI = popEl.querySelector('#y-max');
          var xMinI = popEl.querySelector('#x-min');
          var xMaxI = popEl.querySelector('#x-max');
          if(yMinI) yMinI.value = (STATE['yMin'+chartNum]!=null && isFinite(STATE['yMin'+chartNum])) ? STATE['yMin'+chartNum] : '';
          if(yMaxI) yMaxI.value = (STATE['yMax'+chartNum]!=null && isFinite(STATE['yMax'+chartNum])) ? STATE['yMax'+chartNum] : '';
          if(xMinI) xMinI.value = (STATE['xMin'+chartNum]!=null && isFinite(STATE['xMin'+chartNum])) ? STATE['xMin'+chartNum] : '';
          if(xMaxI) xMaxI.value = (STATE['xMax'+chartNum]!=null && isFinite(STATE['xMax'+chartNum])) ? STATE['xMax'+chartNum] : '';

          function syncManualEnabled(){
            var m = String((popEl.querySelector('input[name="ym"]:checked')||{}).value||'auto');
            var on = (m==='manual');
            if(yMinI) yMinI.disabled = !on;
            if(yMaxI) yMaxI.disabled = !on;
          }
          popEl.addEventListener('change', function(ev){
            var t = ev && ev.target;
            if(!t) return;
            if(t && t.name==='ym') syncManualEnabled();
          }, {passive:true});
          syncManualEnabled();

          popEl.addEventListener('click', function(ev){
            var act = ev && ev.target && ev.target.getAttribute && ev.target.getAttribute('data-act');
            if(!act) return;
            if(act==='y-reset'){
              STATE['yMode'+chartNum]='auto';
              STATE['yMin'+chartNum]=null;
              STATE['yMax'+chartNum]=null;
              STATE['yScale'+chartNum]='linear';
              renderChart(which);
              closeAllMenus();
              return;
            }
            if(act==='x-reset'){
              STATE['xMin'+chartNum]=null;
              STATE['xMax'+chartNum]=null;
              renderChart(which);
              closeAllMenus();
              return;
            }
            if(act==='y-apply'){
              var m = String((popEl.querySelector('input[name="ym"]:checked')||{}).value||'auto');
              var s = String((popEl.querySelector('input[name="ys"]:checked')||{}).value||'linear');
              STATE['yMode'+chartNum] = (m==='manual' || m==='tozero') ? m : 'auto';
              STATE['yScale'+chartNum] = (s==='log') ? 'log' : 'linear';
              var nyMin = yMinI ? parseFloat(String(yMinI.value||'').trim()) : NaN;
              var nyMax = yMaxI ? parseFloat(String(yMaxI.value||'').trim()) : NaN;
              STATE['yMin'+chartNum] = isFinite(nyMin) ? nyMin : null;
              STATE['yMax'+chartNum] = isFinite(nyMax) ? nyMax : null;
              renderChart(which);
              closeAllMenus();
              return;
            }
            if(act==='x-apply'){
              var nxMin = xMinI ? parseFloat(String(xMinI.value||'').trim()) : NaN;
              var nxMax = xMaxI ? parseFloat(String(xMaxI.value||'').trim()) : NaN;
              STATE['xMin'+chartNum] = isFinite(nxMin) ? nxMin : null;
              STATE['xMax'+chartNum] = isFinite(nxMax) ? nxMax : null;
              renderChart(which);
              closeAllMenus();
              return;
            }
          });
        });
      };
      yBtn = btn;
    })();

    // Targets (X/Y min/max + optional band)
    var targetsBtn = null;
    (function(){
      var btn = document.createElement('button');
      btn.className='sa-btn';
      btn.title='Targets';
      btn.innerHTML = iconSvg(targetI);
      btn.onclick=function(e){
        e.stopPropagation();
        var key='targets-'+chartNum;
        var html = '';
        html += '<div class="group">';
        html += '<label><input type="checkbox" id="tg-on" '+(STATE['targetsOn'+chartNum]?'checked':'')+'> Show targets</label>';
        html += '<div class="hdr" style="margin-top:10px">Line Band</div>';
        html += '<div class="row" style="gap:10px;flex-wrap:wrap">'
          + '<label><input type="checkbox" id="tg-xband" '+(STATE['tXBand'+chartNum]?'checked':'')+'> X band</label>'
          + '<label><input type="checkbox" id="tg-yband" '+(STATE['tYBand'+chartNum]?'checked':'')+'> Y band</label>'
          + '</div>';
        html += '<div class="hdr" style="margin-top:10px">X Target</div>';
        html += '<div class="row" style="gap:8px;flex-wrap:wrap">'
          + '<input id="tg-xmin" type="number" step="0.01" placeholder="Min" style="width:110px;flex:0 0 110px">'
          + '<input id="tg-xmax" type="number" step="0.01" placeholder="Max" style="width:110px;flex:0 0 110px">'
          + '</div>';
        html += '<div class="hdr" style="margin-top:10px">Y Target</div>';
        html += '<div class="row" style="gap:8px;flex-wrap:wrap">'
          + '<input id="tg-ymin" type="number" step="0.01" placeholder="Min" style="width:110px;flex:0 0 110px">'
          + '<input id="tg-ymax" type="number" step="0.01" placeholder="Max" style="width:110px;flex:0 0 110px">'
          + '</div>';
        html += '<div class="row" style="margin-top:10px">'
          + '<button class="item" data-act="tg-apply" type="button" style="flex:1">Apply</button>'
          + '<button class="item" data-act="tg-clear" type="button" style="flex:1">Clear</button>'
          + '</div>';
        html += '</div>';

        __saOpenMenuPop(key, btn, 'Targets', html, function(popEl){
          var cb = popEl.querySelector('#tg-on');
          var xb = popEl.querySelector('#tg-xband');
          var yb = popEl.querySelector('#tg-yband');
          var xMinI = popEl.querySelector('#tg-xmin');
          var xMaxI = popEl.querySelector('#tg-xmax');
          var yMinI = popEl.querySelector('#tg-ymin');
          var yMaxI = popEl.querySelector('#tg-ymax');

          if(xMinI) xMinI.value = (STATE['tXMin'+chartNum]!=null && isFinite(STATE['tXMin'+chartNum])) ? STATE['tXMin'+chartNum] : '';
          if(xMaxI) xMaxI.value = (STATE['tXMax'+chartNum]!=null && isFinite(STATE['tXMax'+chartNum])) ? STATE['tXMax'+chartNum] : '';
          if(yMinI) yMinI.value = (STATE['tYMin'+chartNum]!=null && isFinite(STATE['tYMin'+chartNum])) ? STATE['tYMin'+chartNum] : '';
          if(yMaxI) yMaxI.value = (STATE['tYMax'+chartNum]!=null && isFinite(STATE['tYMax'+chartNum])) ? STATE['tYMax'+chartNum] : '';

          function applyTargetsFromUI(){
            STATE['targetsOn'+chartNum] = !!(cb && cb.checked);
            STATE['tXBand'+chartNum] = !!(xb && xb.checked);
            STATE['tYBand'+chartNum] = !!(yb && yb.checked);
            var nxMin = xMinI ? parseFloat(String(xMinI.value||'').trim()) : NaN;
            var nxMax = xMaxI ? parseFloat(String(xMaxI.value||'').trim()) : NaN;
            var nyMin = yMinI ? parseFloat(String(yMinI.value||'').trim()) : NaN;
            var nyMax = yMaxI ? parseFloat(String(yMaxI.value||'').trim()) : NaN;
            STATE['tXMin'+chartNum] = isFinite(nxMin) ? nxMin : null;
            STATE['tXMax'+chartNum] = isFinite(nxMax) ? nxMax : null;
            STATE['tYMin'+chartNum] = isFinite(nyMin) ? nyMin : null;
            STATE['tYMax'+chartNum] = isFinite(nyMax) ? nyMax : null;
          }

          if(cb){
            cb.addEventListener('change', function(){
              STATE['targetsOn'+chartNum] = !!cb.checked;
              renderChart(which);
            }, {passive:true});
          }
          popEl.addEventListener('click', function(ev){
            var act = ev && ev.target && ev.target.getAttribute && ev.target.getAttribute('data-act');
            if(!act) return;
            if(act==='tg-clear'){
              STATE['targetsOn'+chartNum]=false;
              STATE['tXMin'+chartNum]=null; STATE['tXMax'+chartNum]=null;
              STATE['tYMin'+chartNum]=null; STATE['tYMax'+chartNum]=null;
              STATE['tXBand'+chartNum]=false; STATE['tYBand'+chartNum]=false;
              renderChart(which);
              closeAllMenus();
              return;
            }
            if(act==='tg-apply'){
              applyTargetsFromUI();
              renderChart(which);
              closeAllMenus();
              return;
            }
          });
        });
      };
      targetsBtn = btn;
    })();
    
    // Zoom (LineTrend-style popover)
    var zoomBtn = null;
    (function(){
      var btn = document.createElement('button');
      btn.className='sa-btn';
      btn.title='Zoom';
      btn.innerHTML = iconSvg(zoomI);
      btn.onclick=function(e){
        e.stopPropagation();
        var key='zoom-'+chartNum;
        var already = __saIsPopOpen(key);
        closeAllMenus();
        if(already) return;

        function seg2(name, on, label){
          return '<div class="row" style="justify-content:space-between">'
            + '<div style="opacity:.9">'+label+'</div>'
            + '<div>'
            + '<label class="seg"><input type="radio" name="'+name+'" value="1" '+(on?'checked':'')+'><span>On</span></label>'
            + '<label class="seg"><input type="radio" name="'+name+'" value="0" '+(!on?'checked':'')+'><span>Off</span></label>'
            + '</div></div>';
        }

        var html='';
        html += '<div class="group">';
        html += '<div class="hdr">X-axis</div>';
        html += '<div class="row">'
          + '<button class="item" type="button" data-act="x-in" style="flex:1">X +</button>'
          + '<button class="item" type="button" data-act="x-out" style="flex:1">X −</button>'
          + '<button class="item" type="button" data-act="x-reset" style="flex:1">Reset</button>'
          + '</div>';
        html += seg2('xrs', !!STATE['xRangeSlider'+chartNum], 'Range slider');
        html += '<div class="hdr" style="margin-top:10px">Y-axis</div>';
        html += '<div class="row">'
          + '<button class="item" type="button" data-act="y-in" style="flex:1">Y +</button>'
          + '<button class="item" type="button" data-act="y-out" style="flex:1">Y −</button>'
          + '<button class="item" type="button" data-act="y-reset" style="flex:1">Reset</button>'
          + '</div>';
        html += '<div class="hdr" style="margin-top:10px">Interaction</div>';
        html += seg2('pan', STATE['dragMode'+chartNum]==='pan', 'Pan (drag)');
        html += '<div class="row" style="margin-top:10px">'
          + '<button class="item" type="button" data-act="reset-both" style="flex:1">Reset both</button>'
          + '</div>';
        html += '</div>';

        __saOpenMenuPop(key, btn, 'Zoom', html, function(popEl){
          popEl.addEventListener('change', function(ev){
            var t=ev && ev.target;
            if(!t) return;
            if(t.name==='xrs'){ STATE['xRangeSlider'+chartNum] = (String(t.value)==='1'); renderChart(which); return; }
            if(t.name==='pan'){
              STATE['dragMode'+chartNum] = (String(t.value)==='1') ? 'pan' : 'zoom';
              applyDragMode(which);
              return;
            }
          }, {passive:true});
          popEl.addEventListener('click', function(ev){
            var act = ev && ev.target && ev.target.getAttribute && ev.target.getAttribute('data-act');
            if(!act) return;
            if(act==='x-in'){ zoomAxis(which,'x',0.8); return; }
            if(act==='x-out'){ zoomAxis(which,'x',1.25); return; }
            if(act==='x-reset'){ Plotly.relayout(chartInnerDomId(which), {'xaxis.autorange': true}); return; }
            if(act==='y-in'){ zoomAxis(which,'y',0.8); return; }
            if(act==='y-out'){ zoomAxis(which,'y',1.25); return; }
            if(act==='y-reset'){ Plotly.relayout(chartInnerDomId(which), {'yaxis.autorange': true}); return; }
            if(act==='reset-both'){ Plotly.relayout(chartInnerDomId(which), {'xaxis.autorange': true, 'yaxis.autorange': true}); return; }
          });
        });
      };
      zoomBtn = btn;
    })();

    // Theme
    var themeBtn = createDropdownBtn(iconSvg(themeI),'Theme',[
      {label:'Light', stateGetter:function(){return STATE.theme==='light';}, action:function(){ STATE.theme='light'; updateTheme(); }},
      {label:'Paper', stateGetter:function(){return STATE.theme==='paper';}, action:function(){ STATE.theme='paper'; updateTheme(); }},
      {label:'Dark', stateGetter:function(){return STATE.theme==='dark';}, action:function(){ STATE.theme='dark'; updateTheme(); }}
    ]);

    function csvEscape(v){
      var s = String(v==null?'':v);
      return '"' + s.replace(/\r?\n/g,' ').replace(/"/g,'""') + '"';
    }
    function withSectionFromKey(whichKey, fn){
      var originalSection = null;
      try{
        if(typeof whichKey === 'string'){
          var di = whichKey.indexOf('-');
          if(di > 0){
            var idx = parseInt(whichKey.slice(di+1), 10);
            if(isFinite(idx) && sectionKeys && sectionKeys[idx] != null){
              originalSection = STATE.currentSection;
              STATE.currentSection = sectionKeys[idx];
            }
          }
        }
      }catch(_s){}
      try{ return fn(); }
      finally{ try{ if(originalSection!=null) STATE.currentSection = originalSection; }catch(_r){} }
    }

    function chartPointsToCSVText(whichNum, whichKey){
      return withSectionFromKey(whichKey, function(){
        var pts = getChartPoints(whichNum);
        var yLbl = getYLabel(whichNum);
        var cols = ['Cell', combLabel, yLbl];
        var lines = [ cols.map(csvEscape).join(',') ];
        pts.forEach(function(p){ lines.push([p.cell, p.x, p.y].map(csvEscape).join(',')); });
        return lines.join('\n');
      });
    }

    function chartStatsToCSVText(whichNum, whichKey){
      return withSectionFromKey(whichKey, function(){
        var pts = getChartPoints(whichNum);
        var s = statsSummaryForPoints(pts);
        var yLbl = getYLabel(whichNum);
        var rows = [];
        rows.push(['Metric', combLabel, yLbl]);
        if(!s || !s.x || !s.y){
          return rows.map(function(r){ return r.map(csvEscape).join(','); }).join('\n');
        }
        rows.push(['N', s.n, s.n]);
        rows.push(['Mean', fmtNum(s.x.mean, DEC_X), fmtNum(s.y.mean, getDecY(whichNum))]);
        rows.push(['Std', fmtNum(s.x.std, DEC_X), fmtNum(s.y.std, getDecY(whichNum))]);
        rows.push(['Min', fmtNum(s.x.min, DEC_X), fmtNum(s.y.min, getDecY(whichNum))]);
        rows.push(['Q1', fmtNum(s.x.q1, DEC_X), fmtNum(s.y.q1, getDecY(whichNum))]);
        rows.push(['Median', fmtNum(s.x.median, DEC_X), fmtNum(s.y.median, getDecY(whichNum))]);
        rows.push(['Q3', fmtNum(s.x.q3, DEC_X), fmtNum(s.y.q3, getDecY(whichNum))]);
        rows.push(['Max', fmtNum(s.x.max, DEC_X), fmtNum(s.y.max, getDecY(whichNum))]);
        rows.push(['IQR', fmtNum(s.x.iqr, DEC_X), fmtNum(s.y.iqr, getDecY(whichNum))]);
        rows.push(['Lower fence', fmtNum(s.x.lfence, DEC_X), fmtNum(s.y.lfence, getDecY(whichNum))]);
        rows.push(['Upper fence', fmtNum(s.x.ufence, DEC_X), fmtNum(s.y.ufence, getDecY(whichNum))]);

        var reg = null;
        try{ reg = (whichKey!=null) ? (STATE['lastRegKey:'+String(whichKey)] || null) : null; }catch(_){ reg = null; }
        if(!reg) reg = STATE['lastReg'+whichNum] || null;
        rows.push(['', '', '']);
        rows.push(['Regression method', reg && reg.method ? reg.method : 'none', '']);
        if(reg && reg.method && reg.method !== 'none'){
          rows.push(['Slope', fmtNum(reg.slope, 6), '']);
          rows.push(['Intercept', fmtNum(reg.intercept, 6), '']);
          rows.push(['R2', fmtNum(reg.r2, 4), '']);
        }
        return rows.map(function(r){ return r.map(csvEscape).join(','); }).join('\n');
      });
    }

    function chartStatsToAOA(whichNum, whichKey){
      return withSectionFromKey(whichKey, function(){
        var pts = getChartPoints(whichNum);
        var s = statsSummaryForPoints(pts);
        var yLbl = getYLabel(whichNum);
        var rows = [];
        rows.push(['Metric', combLabel, yLbl]);
        if(!s || !s.x || !s.y) return rows;
        rows.push(['N', s.n, s.n]);
        rows.push(['Mean', fmtNum(s.x.mean, DEC_X), fmtNum(s.y.mean, getDecY(whichNum))]);
        rows.push(['Std', fmtNum(s.x.std, DEC_X), fmtNum(s.y.std, getDecY(whichNum))]);
        rows.push(['Min', fmtNum(s.x.min, DEC_X), fmtNum(s.y.min, getDecY(whichNum))]);
        rows.push(['Q1', fmtNum(s.x.q1, DEC_X), fmtNum(s.y.q1, getDecY(whichNum))]);
        rows.push(['Median', fmtNum(s.x.median, DEC_X), fmtNum(s.y.median, getDecY(whichNum))]);
        rows.push(['Q3', fmtNum(s.x.q3, DEC_X), fmtNum(s.y.q3, getDecY(whichNum))]);
        rows.push(['Max', fmtNum(s.x.max, DEC_X), fmtNum(s.y.max, getDecY(whichNum))]);
        rows.push(['IQR', fmtNum(s.x.iqr, DEC_X), fmtNum(s.y.iqr, getDecY(whichNum))]);
        rows.push(['Lower fence', fmtNum(s.x.lfence, DEC_X), fmtNum(s.y.lfence, getDecY(whichNum))]);
        rows.push(['Upper fence', fmtNum(s.x.ufence, DEC_X), fmtNum(s.y.ufence, getDecY(whichNum))]);

        var reg = null;
        try{ reg = (whichKey!=null) ? (STATE['lastRegKey:'+String(whichKey)] || null) : null; }catch(_){ reg = null; }
        if(!reg) reg = STATE['lastReg'+whichNum] || null;
        rows.push(['', '', '']);
        rows.push(['Regression method', reg && reg.method ? reg.method : 'none', '']);
        if(reg && reg.method && reg.method !== 'none'){
          rows.push(['Slope', fmtNum(reg.slope, 6), '']);
          rows.push(['Intercept', fmtNum(reg.intercept, 6), '']);
          rows.push(['R2', fmtNum(reg.r2, 4), '']);
        }
        return rows;
      });
    }

    function chartRawRowsToCSVText(whichNum, whichKey){
      return withSectionFromKey(whichKey, function(){
        var pts = getChartPoints(whichNum);
        var idxs = {};
        pts.forEach(function(p){ if(p && p.idx!=null) idxs[p.idx]=true; });
        var headers = (KEYS || []).slice();
        var lines = [ headers.map(csvEscape).join(',') ];
        Object.keys(idxs).sort(function(a,b){ return Number(a)-Number(b); }).forEach(function(k){
          var i = parseInt(k, 10);
          var row = rowsRaw && isFinite(i) ? rowsRaw[i] : null;
          if(!row) return;
          lines.push(headers.map(function(h){ return csvEscape(row[h]); }).join(','));
        });
        return lines.join('\n');
      });
    }
    function downloadTextFile(name, text, mime){
      try{
        var blob = new Blob([text], {type:(mime||'text/plain;charset=utf-8;')});
        var a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = name;
        a.click();
      }catch(e){}
    }
    function chartFilenameBase(){
      var base = 'chart' + chartNum;
      var reg = null;
      try{ reg = STATE['lastRegKey:'+String(which)] || null; }catch(_){ reg = null; }
      if(!reg) reg = STATE['lastReg'+chartNum];
      if(reg && reg.r2 !== undefined) base += '_R2_' + (reg.r2 * 100).toFixed(2);
      return base;
    }
    function downloadChartPDF(){
      try{
        if(typeof window.jspdf==='undefined' || !window.jspdf || !window.jspdf.jsPDF) return alert('PDF export library not available');
        var gd = document.getElementById(chartInnerDomId(which));
        if(!gd || !window.Plotly) return;
        Plotly.toImage(gd, {format:'png', width:1200, height:800}).then(function(img){
          var pdf = new window.jspdf.jsPDF('l','pt','a4');
          var pageW = pdf.internal.pageSize.getWidth();
          var pageH = pdf.internal.pageSize.getHeight();
          var margin = 24;
          var w = pageW - margin*2;
          var h = pageH - margin*2;
          pdf.addImage(img, 'PNG', margin, margin, w, h);
          pdf.save(chartFilenameBase()+'.pdf');
        });
      }catch(e){ alert('PDF export failed'); }
    }

    // Download (LineTrend-like grouping)
    var dlBtn = createDropdownBtn(iconSvg(downI),'Download',[
      {label:'Chart PNG', action:function(){
        var gd=document.getElementById(chartInnerDomId(which));
        if(!gd) return;
        Plotly.downloadImage(gd, {format:'png', scale:2, filename: chartFilenameBase()});
      }},
      {label:'Chart PDF', action:function(){ downloadChartPDF(); }},
      {label:'─── Chart Data ───', action:function(){}},
      {label:'Chart Data Excel', action:function(){
        try{
          if(typeof window.XLSX!=='undefined' && window.XLSX.utils && window.XLSX.writeFile){
            var aoa = withSectionFromKey(String(which), function(){
              var pts=getChartPoints(chartNum);
              var yLbl=getYLabel(chartNum);
              var a=[[ 'Cell', combLabel, yLbl ]];
              pts.forEach(function(p){ a.push([p.cell, p.x, p.y]); });
              return a;
            });
            var wb=window.XLSX.utils.book_new();
            var ws=window.XLSX.utils.aoa_to_sheet(aoa);
            window.XLSX.utils.book_append_sheet(wb, ws, 'Data');
            window.XLSX.writeFile(wb, chartFilenameBase()+'.xlsx');
            return;
          }
        }catch(_){ }
        alert('XLSX export library not available');
      }},
      {label:'Chart Data Copy', action:function(){ saCopyText(chartPointsToCSVText(chartNum, String(which))); }},
      {label:'─── Stats Data ───', action:function(){}},
      {label:'Stats Data Excel', action:function(){
        try{
          if(typeof window.XLSX!=='undefined' && window.XLSX.utils && window.XLSX.writeFile){
            var aoa = chartStatsToAOA(chartNum, String(which));
            var wb=window.XLSX.utils.book_new();
            var ws=window.XLSX.utils.aoa_to_sheet(aoa);
            window.XLSX.utils.book_append_sheet(wb, ws, 'Stats');
            window.XLSX.writeFile(wb, chartFilenameBase()+'_stats.xlsx');
            return;
          }
        }catch(_){ }
        alert('XLSX export library not available');
      }},
      {label:'Stats Data Copy', action:function(){ saCopyText(chartStatsToCSVText(chartNum, String(which))); }},
      {label:'─── Rawdata ───', action:function(){}},
      {label:'Rawdata Excel', action:function(){
        try{
          if(typeof window.XLSX!=='undefined' && window.XLSX.utils && window.XLSX.writeFile){
            var aoa = withSectionFromKey(String(which), function(){
              var pts=getChartPoints(chartNum);
              var idxs={}; pts.forEach(function(p){ if(p && p.idx!=null) idxs[p.idx]=true; });
              var headers=(KEYS||[]).slice();
              var a=[headers];
              Object.keys(idxs).sort(function(a,b){ return Number(a)-Number(b); }).forEach(function(k){
                var i=parseInt(k,10);
                var row=rowsRaw && isFinite(i) ? rowsRaw[i] : null;
                if(!row) return;
                a.push(headers.map(function(h){ return row[h]; }));
              });
              return a;
            });
            var wb=window.XLSX.utils.book_new();
            var ws=window.XLSX.utils.aoa_to_sheet(aoa);
            window.XLSX.utils.book_append_sheet(wb, ws, 'Raw');
            window.XLSX.writeFile(wb, chartFilenameBase()+'_raw.xlsx');
            return;
          }
        }catch(_){ }
        alert('XLSX export library not available');
      }},
      {label:'Rawdata Copy', action:function(){ saCopyText(chartRawRowsToCSVText(chartNum, String(which))); }}
    ]);

    // Ensure fullscreen is last
    var fsBtn = createIconBtn(iconSvg(fullI),'Fullscreen', function(){ toggleFullscreen(card.card, which); applyFullscreenFontScale(which); });

    // Append in LineTrend order
    modebar.appendChild(resetBtn);
    if(viewBtn) modebar.appendChild(viewBtn);
    modebar.appendChild(tableBtn);
    modebar.appendChild(pointsBtn);
    if(filterBtn) modebar.appendChild(filterBtn);
    modebar.appendChild(removeBtn);
    modebar.appendChild(statusBtn);
    if(yBtn) modebar.appendChild(yBtn);
    if(targetsBtn) modebar.appendChild(targetsBtn);
    modebar.appendChild(zoomBtn);
    modebar.appendChild(themeBtn);
    modebar.appendChild(dlBtn);
    modebar.appendChild(fsBtn);
  }

  function toggleFullscreen(cardEl, whichKey){ 
    if(cardEl.classList.contains('sa-fullscreen')){ 
      cardEl.classList.remove('sa-fullscreen'); 
      setTimeout(function(){
        try{ deferredLayoutRefresh({rerender:true}); }catch(_){ }
        try{ renderChart(whichKey); }catch(_){ }
        for(var i=1;i<=CHART_COUNT;i++) applyFullscreenFontScale(i);
      },150);
    } else { 
      layoutRoot.querySelectorAll('.sa-fullscreen').forEach(function(c){c.classList.remove('sa-fullscreen');}); 
      cardEl.classList.add('sa-fullscreen'); 
      setTimeout(function(){
        try{ deferredLayoutRefresh({rerender:true}); }catch(_){ }
        try{ renderChart(whichKey); }catch(_){ }
        if(whichKey!=null) applyFullscreenFontScale(whichKey);
      },150);
    } 
  }

  function whichKeyFromInnerDomId(id){
    try{
      var m = String(id||'').match(/^sa-s(\d+)-card-inner(.*)$/);
      if(!m) return null;
      var n = parseInt(m[1], 10);
      if(!isFinite(n)) return null;
      var suf = m[2] || '';
      if(suf && suf.charAt(0)==='-') return String(n) + suf;
      return n;
    }catch(_){ return null; }
  }

  function rerenderAllChartsInDom(){
    try{
      var els = document.querySelectorAll('[id^="sa-s"][id*="-card-inner"]');
      for(var i=0;i<els.length;i++){
        var key = whichKeyFromInnerDomId(els[i].id);
        if(key==null) continue;
        try{ renderChart(key); }catch(_){ }
      }
    }catch(_){ }
  }

  function deferredLayoutRefresh(opts){
    // Multiple passes: OAS can momentarily report 0px sizes during fullscreen/table toggles.
    var rerender = !!(opts && opts.rerender);
    var delays = [0, 30, 160, 420];
    delays.forEach(function(d){
      setTimeout(function(){
        try{ applyAutoSizing(); }catch(_){ }
        try{ resizeCharts(); }catch(_){ }
        if(rerender) try{ rerenderAllChartsInDom(); }catch(_){ }
        try{ resizeCharts(); }catch(_){ }
      }, d);
    });
  }
  function resizeCharts(){
    if(!window.Plotly) return;
    try{
      var els = document.querySelectorAll('[id^="sa-s"][id*="-card-inner"]');
      for(var i=0;i<els.length;i++){
        try{ Plotly.relayout(els[i], {autosize:true}); }catch(_r){ }
        try{ Plotly.Plots.resize(els[i]); }catch(_){ }
      }
    }catch(e){}
  }
  // Respond to browser resize
  window.addEventListener('resize', function(){ applyAutoSizing(); resizeCharts(); });

  // Report-level fullscreen (browser Fullscreen API): re-measure + re-render to avoid missing legends after exit.
  try{
    document.addEventListener('fullscreenchange', function(){
      try{ deferredLayoutRefresh({rerender:true}); }catch(_){ }
    });
  }catch(_){ }
  function applyFullscreenFontScale(which){
    var chartNum = chartNumFromKey(which);
    var targetId = chartInnerDomId(which);
    var cardId = chartCardDomId(which);
    if(!document.getElementById(targetId)) return;
    var cardEl = document.getElementById(cardId);
    var isFullscreen = cardEl && cardEl.classList.contains('sa-fullscreen');
    var scale = isFullscreen ? FULLSCREEN_FONT_SCALE : 1;
    var titleSize = Math.round(AXIS_TITLE_FONT_SIZE * scale);
    var tickSize  = Math.round(AXIS_TICK_FONT_SIZE  * scale);
    var legendSize = Math.round(Math.max(10, AXIS_TICK_FONT_SIZE * 0.95) * scale);
    var titleFontSize = Math.round((TITLE_FONT_SIZE || 16) * scale);
    // keep legend position as per STATE; only scale fonts + margins a bit
    var relayout = {
      'font.size': tickSize,
      'xaxis.title.font.size': titleSize,
      'yaxis.title.font.size': titleSize,
      'xaxis.tickfont.size': tickSize,
      'yaxis.tickfont.size': tickSize,
      'legend.font.size': legendSize,
      'title.font.size': titleFontSize
    };
    if(isFullscreen){
      relayout['margin.left'] = 90;
      relayout['margin.right'] = 60;
      relayout['margin.bottom'] = 140;
      relayout['margin.top'] = 90;
      // y2 axis (hist+kde)
      relayout['yaxis2.title.font.size'] = titleSize;
      relayout['yaxis2.tickfont.size'] = tickSize;
    }
    try{ Plotly.relayout(targetId, relayout); }catch(_){ }
  }

  function renderTableForSection(section, idx) {
    var tbl = document.getElementById('sa-table-sec' + idx);
    if (!tbl) return;

    __saApplyTableFilterSummary('sa-table-filter-summary-sec' + idx);
		
    // Filter rows for this section only
    var rows = getSortedRows().filter(function(r) {
      return String(r[sectionLabel] || '') === section;
    });
		
    var html='<thead><tr>';
    COLS.forEach(function(c,idx2){
      var sym = (STATE.sortCol===idx2) ? (STATE.sortDir>0?'▲':'▼') : '';
      html+='<th data-idx="'+idx2+'" title="'+escapeHtml(c.label)+'"><div class="sa-thwrap">'+escapeHtml(c.label)+'</div>' + (sym?('<span class="sa-sort">'+sym+'</span>'):'') + '</th>';
    });
    html+='</tr></thead><tbody>';
    rows.forEach(function(r){ html+='<tr>'; COLS.forEach(function(c,ci){ var val=r[c.label]; var disp=val===undefined||val===null?'':String(val); var bg=c.label===cfColLabel?applyCF(r):''; var cls=(ci===0?' sa-firstcol':'') + (c.isNum?' sa-num':''); var tt=(ci===0 && disp && disp.length>12)?(' title="'+escapeHtml(disp)+'"'):''; html+='<td class="'+cls+'"'+tt+' style="'+(bg?'background:'+bg+';':'')+'">'+disp+'</td>'; }); html+='</tr>'; }); html+='</tbody>'; tbl.innerHTML=html;
    tuneDataTableSizing(tbl);
    adjustTableWrapHeight('sa-table-wrap-sec' + idx, tbl, rows.length);
  }

  function adjustTableWrapHeight(wrapId, tbl, fallbackRowsLen){
    // PV_TableRows should cap table height in both single and multi-section views,
    // including fill-height mode (prevents large tables forcing chart heights).
    try{
      var wrap = document.getElementById(wrapId);
      if(!wrap || !tbl) return;
      var bodyRows = 0;
      try{ bodyRows = (tbl.tBodies && tbl.tBodies[0] && tbl.tBodies[0].rows) ? tbl.tBodies[0].rows.length : 0; }catch(_){ bodyRows = 0; }
      if(!bodyRows && isFinite(fallbackRowsLen)) bodyRows = fallbackRowsLen;

      // PV_TableRows: cap the visible height so roughly TABLE_ROWS are visible before scrolling.
      // This keeps the UI consistent while still rendering all rows.
      try{
        if(isFinite(TABLE_ROWS) && TABLE_ROWS > 0){
          var cap = (isFinite(TABLE_HEIGHT) && TABLE_HEIGHT>0) ? TABLE_HEIGHT : 500;
          var rowH = 22;
          var headH = 28;
          try{
            var b0 = (tbl.tBodies && tbl.tBodies[0] && tbl.tBodies[0].rows && tbl.tBodies[0].rows[0]) ? tbl.tBodies[0].rows[0] : null;
            if(b0 && b0.getBoundingClientRect){
              var br = b0.getBoundingClientRect();
              if(br && isFinite(br.height) && br.height > 0) rowH = br.height;
            }
          }catch(_rh){ }
          try{
            var th = (tbl.tHead && tbl.tHead.getBoundingClientRect) ? tbl.tHead.getBoundingClientRect() : null;
            if(th && isFinite(th.height) && th.height > 0) headH = th.height;
          }catch(_hh){ }

          var visibleRows = Math.max(1, Math.floor(TABLE_ROWS));
          var desired = Math.floor(headH + (visibleRows * rowH) + 10);
          desired = Math.min(cap, Math.max(140, desired));
          wrap.style.maxHeight = desired + 'px';
          wrap.style.height = 'auto';
          wrap.style.minHeight = '0px';
        }
      }catch(_tr){ }

      // If table is tiny, shrink the wrapper so it doesn't waste space.
      if(bodyRows <= 1){
        setTimeout(function(){
          try{
            var cap = (isFinite(TABLE_HEIGHT) && TABLE_HEIGHT>0) ? TABLE_HEIGHT : 500;
            var measured = tbl.scrollHeight || 0;
            var target = Math.min(cap, Math.max(140, measured + 18));
            wrap.style.maxHeight = target + 'px';
            wrap.style.height = 'auto';
            wrap.style.minHeight = '0px';
          }catch(e){}
        }, 0);
      }
    }catch(e){}
  }

  function renderChartForSection(which, section) {
    // Temporarily set currentSection for filtering
    // Temporarily set currentSection for filtering
    var originalSection = STATE.currentSection;
    STATE.currentSection = section;

    // Render using the string key (e.g. '3-0') so renderChart targets the suffixed DOM ids
    renderChart(which);
		
    // Restore
    STATE.currentSection = originalSection;
  }

  function renderTable(){
    dbg('DEBUG renderTable: called');
    var tbl = document.getElementById('sa-table');
    dbg('DEBUG renderTable: table element =', tbl);
    if (!tbl) {
      dbgWarn('WARNING renderTable: table element not found!');
      return;
    }
		
  __saApplyTableFilterSummary('sa-table-filter-summary');
		
    var rows=getSortedRows(); var display=rows; /* Show ALL rows with scrollbar */
    dbg('DEBUG renderTable: rows count =', rows.length, ', COLS count =', COLS.length);
    var html='<thead><tr>';
    COLS.forEach(function(c,idx){
      var sym = (STATE.sortCol===idx) ? (STATE.sortDir>0?'▲':'▼') : '';
      html+='<th data-idx="'+idx+'"><div class="sa-thwrap">'+escapeHtml(c.label)+'</div>' + (sym?('<span class="sa-sort">'+sym+'</span>'):'') + '</th>';
    });
    html+='</tr></thead><tbody>';
    display.forEach(function(r){ html+='<tr>'; COLS.forEach(function(c,ci){ var val=r[c.label]; var disp=val===undefined||val===null?'':String(val); var bg=c.label===cfColLabel?applyCF(r):''; var cls=(ci===0?' sa-firstcol':'') + (c.isNum?' sa-num':''); var tt=(ci===0 && disp && disp.length>12)?(' title="'+escapeHtml(disp)+'"'):''; html+='<td class="'+cls+'"'+tt+' style="'+(bg?'background:'+bg+';':'')+'">'+disp+'</td>'; }); html+='</tr>'; }); html+='</tbody>'; tbl.innerHTML=html;
    tuneDataTableSizing(tbl);
    tbl.querySelectorAll('thead th').forEach(function(th){ th.addEventListener('click', function(){ var idx=parseInt(th.getAttribute('data-idx'),10); if(STATE.sortCol===idx){ STATE.sortDir=-STATE.sortDir; } else { STATE.sortCol=idx; STATE.sortDir=1; } renderTable(); }); });
    adjustTableWrapHeight('sa-table-wrap', tbl, rows.length);
  }

  function tuneDataTableSizing(tbl){
    try{
      if(!tbl) return;
      var colCount = (COLS && COLS.length) ? COLS.length : 0;
      if(!colCount){
        try{ colCount = (tbl.tHead && tbl.tHead.rows && tbl.tHead.rows[0]) ? tbl.tHead.rows[0].cells.length : 0; }catch(_){ colCount = 0; }
      }

      // Per-column widths based on header length (prevents equal-width columns).
      var widths = [];
      var minPx = 46;
      var maxPx = 150;
      var numPx = 70;
      for(var i=0;i<colCount;i++){
        var label = '';
        try{ label = (COLS && COLS[i] && COLS[i].label) ? String(COLS[i].label) : ''; }catch(_l){ label = ''; }
        var isNum = false;
        try{ isNum = !!(COLS && COLS[i] && COLS[i].isNum); }catch(_n){ isNum = false; }
        if(isNum){ widths.push(numPx); continue; }
        var len = label ? label.length : 6;
        var w = Math.round(28 + (len * 4.8));
        w = Math.max(minPx, Math.min(maxPx, w));
        widths.push(w);
      }
      var sumW = widths.reduce(function(a,b){ return a + (b||0); }, 0);
      var wrapW = 0;
      try{ wrapW = tbl.parentElement ? (tbl.parentElement.clientWidth || 0) : 0; }catch(_w){ wrapW = 0; }

      // When space is constrained, reduce font size for header + values together.
      try{
        if(wrapW > 0 && colCount > 0){
          var perCol = wrapW / colCount;
          var fs = '';
          if(perCol < 80) fs = '10px';
          else if(perCol < 100) fs = '11px';
          else if(perCol < 120) fs = '12px';
          tbl.style.fontSize = fs;
        }
      }catch(_fs){ }

      // If the computed total exceeds available wrapper width, scale columns down to fit.
      // This strongly reduces horizontal scrollbars while keeping a sensible minimum width.
      if(wrapW > 0 && sumW > wrapW){
        var target = Math.max(260, wrapW - 6);
        var scale = target / sumW;
        if(scale < 1){
          for(var si=0; si<widths.length; si++){
            var baseMin = (COLS && COLS[si] && COLS[si].isNum) ? 54 : 42;
            widths[si] = Math.max(baseMin, Math.floor(widths[si] * scale));
          }
          sumW = widths.reduce(function(a,b){ return a + (b||0); }, 0);
        }
      }

      // Build/update colgroup
      try{
        var cg = tbl.querySelector('colgroup');
        if(cg && cg.parentNode) cg.parentNode.removeChild(cg);
      }catch(_d){ }
      var colgroup = document.createElement('colgroup');
      for(var j=0;j<widths.length;j++){
        var col = document.createElement('col');
        col.style.width = widths[j] + 'px';
        colgroup.appendChild(col);
      }
      try{ tbl.insertBefore(colgroup, tbl.firstChild); }catch(_i){ try{ tbl.appendChild(colgroup); }catch(_j){} }

      tbl.style.width = '100%';
      tbl.style.tableLayout = 'fixed';
      // Prefer avoiding horizontal scroll; allow ellipsis truncation instead.
      tbl.style.minWidth = '100%';
    }catch(_){ }
  }

  function downloadTableCSV(){ var rows=getSortedRows(); var csv=COLS.map(function(c){return '"'+c.label.replace(/"/g,'""')+'"';}).join(',')+'\n'; rows.forEach(function(r){ csv+=COLS.map(function(c){ var val=r[c.label]; var str=val===undefined||val===null?'':String(val); return '"'+str.replace(/"/g,'""')+'"'; }).join(',')+'\n'; }); var blob=new Blob([csv],{type:'text/csv'}); var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='report_'+Date.now()+'.csv'; a.click(); }

  function downloadReport(kind){
    try{
      kind = String(kind || '').toLowerCase();
      if(kind==='table-xlsx') return downloadReportExcel();
      if(kind==='raw-xlsx') return downloadRawDataExcel();
      if(kind==='chart-pdf') return downloadReportPDF(false);
      // Back-compat
      if(kind==='xlsx') return downloadReportExcel();
      if(kind==='pdf') return downloadReportPDF(true);
      alert('Unknown download type: ' + kind);
    }catch(e){
      alert('Download failed: ' + (e && e.message ? e.message : e));
    }
  }

  function getRawFilteredCalc(){
    var yMin = STATE.filterY && STATE.filterY.min!==undefined ? STATE.filterY.min : null;
    var yMax = STATE.filterY && STATE.filterY.max!==undefined ? STATE.filterY.max : null;
    var out = [];
    calc.forEach(function(d, idx){
      if(STATE.removedIndices && STATE.removedIndices[idx]) return;
      if(STATE.currentSection !== 'All' && d.section !== STATE.currentSection) return;
      if(d.x===null || !isFinite(d.x) || Math.abs(d.x) < 1e-12) return;
      if(STATE.filterX.min!==null && STATE.filterX.min!==undefined && d.x < STATE.filterX.min) return;
      if(STATE.filterX.max!==null && STATE.filterX.max!==undefined && d.x > STATE.filterX.max) return;

      var passY = true;
      if((yMin!==null && yMin!==undefined) || (yMax!==null && yMax!==undefined)){
        passY = false;
        [d.yLatest, d.yProp].forEach(function(y){
          if(y===null || !isFinite(y) || Math.abs(y) < 1e-12) return;
          if(yMin!==null && yMin!==undefined && y < yMin) return;
          if(yMax!==null && yMax!==undefined && y > yMax) return;
          passY = true;
        });
      }
      if(!passY) return;
      out.push(d);
    });
    return out;
  }

  function csvEscape(v){
    if(v===undefined || v===null) return '""';
    var s = String(v);
    return '"' + s.replace(/"/g,'""') + '"';
  }

  function buildRawCSV(){
    var header = KEYS.slice();
    // Include computed values (useful even if source columns are renamed)
    header.push('__section');
    header.push('__x');
    header.push('__y_latest');
    header.push('__y_proposed');
    var lines = [];
    lines.push(header.map(csvEscape).join(','));
    getRawFilteredCalc().forEach(function(d){
      var row = [];
      KEYS.forEach(function(k){ row.push(d.raw && d.raw[k]!==undefined ? d.raw[k] : ''); });
      row.push(d.section);
      row.push(d.x);
      row.push(d.yLatest);
      row.push(d.yProp);
      lines.push(row.map(csvEscape).join(','));
    });
    return lines.join('\n') + '\n';
  }

  function downloadRawDataCSV(){
    var csv = buildRawCSV();
    var blob = new Blob([csv], {type:'text/csv'});
    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'raw_data_' + Date.now() + '.csv';
    a.click();
  }

  function copyRawDataCSV(){
    var csv = buildRawCSV();
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(csv).then(function(){ alert('Raw CSV copied to clipboard'); }, function(){ alert('Copy failed'); });
      return;
    }
    try{
      var ta=document.createElement('textarea');
      ta.value=csv;
      ta.style.position='fixed'; ta.style.left='-9999px';
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      alert('Raw CSV copied to clipboard');
    }catch(e){ alert('Copy failed'); }
  }

  function downloadRawDataExcel(){
    try{
      if(typeof window.XLSX==='undefined' || !window.XLSX || !window.XLSX.utils){
        alert('XLSX library not loaded.');
        return;
      }
      var wb = window.XLSX.utils.book_new();
      var header = KEYS.slice();
      header.push('__section','__x','__y_latest','__y_proposed');
      var table = [header];
      getRawFilteredCalc().forEach(function(d){
        var row = [];
        KEYS.forEach(function(k){ row.push(d.raw && d.raw[k]!==undefined ? d.raw[k] : ''); });
        row.push(d.section);
        row.push(d.x);
        row.push(d.yLatest);
        row.push(d.yProp);
        table.push(row);
      });
      var ws = window.XLSX.utils.aoa_to_sheet(table);
      window.XLSX.utils.book_append_sheet(wb, ws, 'RawData');
      window.XLSX.writeFile(wb, 'raw_data_' + Date.now() + '.xlsx');
    }catch(e){
      alert('Raw Excel export failed: ' + (e && e.message ? e.message : e));
    }
  }

  function downloadReportExcel(){
    try{ 
      dbg('Checking for XLSX library...', typeof window.XLSX);
      if(typeof window.XLSX==='undefined' || !window.XLSX || !window.XLSX.utils){ 
        alert('XLSX library not loaded.\n\nExpected path:\n/analyticsRes/vendor/export/xlsx.full.min.js\n\nPlease ensure the file is accessible and loaded before this script.'); 
        console.error('XLSX library not found. Check if /analyticsRes/vendor/export/xlsx.full.min.js is loaded.');
        console.error('window.XLSX:', window.XLSX);
        return; 
      }
			
      dbg('Starting Excel export...');
      var wb=window.XLSX.utils.book_new(); 
      var rows=getSortedRows(); 
			
      // Data sheet
      var table=[[COLS.map(function(c){return c.label; })][0]]; 
      rows.forEach(function(r){ 
        table.push(COLS.map(function(c){ 
          var v=r[c.label]; 
          return v===undefined||v===null?'':v; 
        })); 
      });
      var ws=window.XLSX.utils.aoa_to_sheet(table); 
      window.XLSX.utils.book_append_sheet(wb, ws, 'Data');
			
      // Summary sheet with regression stats
      var chartLabels = [];
      for(var i=1;i<=CHART_COUNT;i++){
        if(!isChartShown(i)) continue;
        var def = CHART_DEFS[i-1] || {};
        chartLabels.push(def.title || ('Chart ' + i));
      }
      if(!chartLabels.length) chartLabels = ['(no charts)'];
      var summary=[];
      summary.push(["Metric"].concat(chartLabels));
      var metrics = [
        {name:'R²', get:function(reg){ return (reg && reg.r2!=null) ? reg.r2.toFixed(4) : 'N/A'; }},
        {name:'Slope', get:function(reg){ return (reg && reg.slope!=null) ? reg.slope.toFixed(6) : 'N/A'; }},
        {name:'Intercept', get:function(reg){ return (reg && reg.intercept!=null) ? reg.intercept.toFixed(6) : 'N/A'; }},
        {name:'Count', get:function(reg){ return (reg && reg.n!=null) ? reg.n : 'N/A'; }}
      ];
      metrics.forEach(function(m){
        var row = [m.name];
        for(var i=1;i<=CHART_COUNT;i++){
          if(!isChartShown(i)) continue;
          row.push(m.get(STATE['lastReg'+i]));
        }
        summary.push(row);
      });
      summary.push([""]);
      summary.push(["Note: Chart images are exported separately as Excel does not support embedded images via SheetJS."]); 
      summary.push(["To include charts, please use PDF export option."]);
      var ws2=window.XLSX.utils.aoa_to_sheet(summary); 
      window.XLSX.utils.book_append_sheet(wb, ws2, 'Summary');
			
      // Save Excel file
      window.XLSX.writeFile(wb, 'scatter_report_'+Date.now()+'.xlsx');
      dbg('Excel export completed successfully');
			
      // Ask before downloading chart images
      setTimeout(function(){
        var chartEls = [];
        for(var i=1;i<=CHART_COUNT;i++){
          if(!isChartShown(i)) continue;
          var el = document.getElementById(chartInnerId(i));
          if(el) chartEls.push({num:i, el:el});
        }
        if(chartEls.length && typeof Plotly !== 'undefined'){
          if(confirm('Excel file downloaded successfully.\n\nWould you like to also download chart images (PNG)?\n\nClick OK to download images, Cancel to skip.')){
            chartEls.forEach(function(it, idx){
              setTimeout(function(){
                var reg = STATE['lastReg'+it.num];
                var r2Text = (reg && reg.r2!=null) ? ('_R2_' + (reg.r2 * 100).toFixed(2)) : '';
                Plotly.downloadImage(it.el, {format:'png', filename:'chart'+it.num+r2Text+'_'+Date.now()});
              }, idx * 450);
            });
          }
        }
      }, 500);
			
    } catch(e){ 
      console.error('Excel export error:', e); 
      alert('Excel export failed: ' + e.message);
    }
  }

  function downloadReportPDF(includeTable){
    dbg('Starting PDF export...');
    dbg('- html2canvas:', typeof window.html2canvas);
    dbg('- jspdf:', typeof window.jspdf);
		
    if(typeof window.html2canvas==='undefined' || typeof window.jspdf==='undefined'){ 
      var msg = 'PDF export libraries not available.\n\n';
      if(typeof window.html2canvas==='undefined'){
        msg += 'Missing: html2canvas\n';
        msg += 'Expected: /analyticsRes/vendor/export/html2canvas.min.js\n\n';
      } else {
        msg += 'html2canvas - LOADED\n\n';
      }
      if(typeof window.jspdf==='undefined'){
        msg += 'Missing: jsPDF\n';
        msg += 'Expected: /analyticsRes/vendor/export/jspdf.umd.min.js\n\n';
      } else {
        msg += 'jsPDF - LOADED\n\n';
      }
      alert(msg); 
      console.error('Missing PDF libraries');
      return; 
    }
		
    dbg('Generating PDF with charts...');
		
    try{
      includeTable = (includeTable===undefined) ? true : !!includeTable;
      var pdf = new window.jspdf.jsPDF('p','pt','a4');
      var pageW = pdf.internal.pageSize.getWidth();
      var pageH = pdf.internal.pageSize.getHeight();
      var margin = 20;
      var currentPage = 0;
			
      // Use Plotly's built-in toImage for charts instead of html2canvas
      var chartEls = [];
      for(var i=1;i<=CHART_COUNT;i++){
        if(!isChartShown(i)) continue;
        var el = document.getElementById(chartInnerId(i));
        if(el) chartEls.push({num:i, el:el});
      }
			
      if(!chartEls.length){
        alert('No charts found to export');
        return;
      }
			
      var promises = [];
			
      if(typeof Plotly !== 'undefined'){
        chartEls.forEach(function(it){
          promises.push(
            Plotly.toImage(it.el, {format:'png', width:1200, height:800})
              .then(function(dataUrl){
                return {chart: it.num, dataUrl: dataUrl};
              })
          );
        });
      }
			
      Promise.all(promises).then(function(results){
        dbg('All charts captured, adding to PDF...');
				
        // Add charts first
        results.forEach(function(result, idx){
          if(idx > 0) pdf.addPage();
					
          var def = CHART_DEFS[result.chart-1] || {};
          var title = 'Chart ' + result.chart + ': ' + (def.title || ('Chart ' + result.chart));
          var reg = STATE['lastReg'+result.chart];
					
          if(reg && reg.r2 !== undefined){
            title += ' (R² = ' + (reg.r2 * 100).toFixed(2) + '%)';
          }
					
          pdf.setFontSize(12);
          pdf.text(title, margin, margin + 15);
					
          var imgW = pageW - (margin * 2);
          var imgH = (imgW * 800) / 1200;
					
          if(imgH > pageH - margin * 3){
            imgH = pageH - margin * 3;
            imgW = (imgH * 1200) / 800;
          }
					
          pdf.addImage(result.dataUrl, 'PNG', margin, margin + 30, imgW, imgH);
        });

        if(!includeTable){
          pdf.save('scatter_charts_' + Date.now() + '.pdf');
          dbg('PDF saved successfully (charts only)');
          return;
        }

        // Now add table as last page
        var tableWrap = document.getElementById('sa-table-wrap') || document.querySelector('[id^="sa-table-wrap"]');
        if(tableWrap && typeof window.html2canvas !== 'undefined'){
          dbg('Capturing table...');
          window.html2canvas(tableWrap, {
            scale: 1.5,
            useCORS: true,
            logging: false,
            timeout: 10000,
            backgroundColor: '#ffffff'
          }).then(function(tableCanvas){
            dbg('Table captured, adding to PDF...');
						
            pdf.addPage();
            var tableImg = tableCanvas.toDataURL('image/png');
            var tImgW = pageW - (margin * 2);
            var tImgH = (tableCanvas.height * tImgW) / tableCanvas.width;
						
            pdf.setFontSize(12);
            pdf.text('Data Table', margin, margin + 15);
						
            if(tImgH > pageH - margin * 3){
              tImgH = pageH - margin * 3;
              tImgW = (tableCanvas.width * tImgH) / tableCanvas.height;
            }
						
            pdf.addImage(tableImg, 'PNG', margin, margin + 30, tImgW, tImgH);
						
            pdf.save('scatter_report_' + Date.now() + '.pdf');
            dbg('PDF with table saved successfully');
						
          }).catch(function(tableErr){
            console.error('Table capture failed:', tableErr);
            // Save PDF without table if capture fails
            pdf.save('scatter_charts_' + Date.now() + '.pdf');
            dbg('PDF saved (without table due to capture error)');
          });
        } else {
          dbg('Table not found or html2canvas not available, saving PDF without table...');
          pdf.save('scatter_charts_' + Date.now() + '.pdf');
          dbg('PDF saved successfully');
        }
				
      }).catch(function(err){
        console.error('PDF generation error:', err);
        alert('PDF export failed: ' + err.message + '\n\nPlease try PNG export instead.');
      });
			
    } catch(e){ 
      console.error('PDF function error:', e); 
      alert('PDF export error: ' + e.message + '\n\nPlease use PNG export instead.'); 
    }
  }

  function downloadReportImage(){ 
    if(typeof Plotly === 'undefined'){ 
      alert('Plotly library not available for image export'); 
      return; 
    }
    var chartEls = [];
    for(var i=1;i<=CHART_COUNT;i++){
      if(!isChartShown(i)) continue;
      var el = document.getElementById(chartInnerId(i));
      if(el) chartEls.push({num:i, el:el});
    }
		
    if(!chartEls.length){
      alert('No charts found to export');
      return;
    }
		
    var chartCount = chartEls.length;
    var message = 'Download ' + chartCount + ' chart image' + (chartCount > 1 ? 's' : '') + ' as PNG files?';
		
    if(confirm(message)){
      chartEls.forEach(function(it, idx){
        setTimeout(function(){
          var reg = STATE['lastReg'+it.num];
          var r2Text = (reg && reg.r2!=null) ? ('_R2_' + (reg.r2 * 100).toFixed(2)) : '';
          Plotly.downloadImage(it.el, {format:'png', filename:'chart'+it.num+r2Text+'_'+Date.now()});
        }, idx * 450);
      });
    }
  }

  // Chart helpers
  function getChartPoints(which){ 
    dbg('DEBUG getChartPoints: which =', which, ', currentSection =', STATE.currentSection, ', calc.length =', calc.length);
    var pts=[]; 
    calc.forEach(function(d,idx){ 
      if(STATE.removedIndices[idx]) return; 
      if(STATE.currentSection !== 'All' && d.section !== STATE.currentSection) return;
      var yVal = (d.ys && d.ys[which] != null) ? d.ys[which] : (which===1?d.yLatest:d.yProp);
      if(d.x===null || !isFinite(d.x) || Math.abs(d.x) < 1e-12 || yVal===null || !isFinite(yVal) || Math.abs(yVal) < 1e-12) return;
      if(STATE.filterX.min!==null && d.x<STATE.filterX.min) return; 
      if(STATE.filterX.max!==null && d.x>STATE.filterX.max) return; 
      if(STATE.filterY.min!==null && yVal<STATE.filterY.min) return; 
      if(STATE.filterY.max!==null && yVal>STATE.filterY.max) return; 
      // Build extra hover fields per narrative indices
      var extra = [];
      var cfg = which===1 ? HOVER_COLS_1 : HOVER_COLS_2;
      if(cfg.length){ cfg.forEach(function(colIndexStr){ var colIdx=parseInt(colIndexStr,10); if(!isNaN(colIdx) && KEYS[colIdx]!==undefined){ extra.push(KEYS[colIdx]+': '+(d.raw[KEYS[colIdx]] ?? '')); } }); }
      pts.push({x:d.x,y:yVal,cell:d.cell,idx:idx, extra: extra}); 
    }); 
    return pts; 
  }

  // Legend label helper to reduce overly long items
  function truncateLegendLabel(str){
    if(str == null) return '';
    var s = String(str);
    var max = LEGEND_LABEL_MAX || 24;
    return s.length > max ? (s.slice(0, max - 1) + '…') : s;
  }

  function computeRegression(points, method){ 
    if(!points||points.length<2) return null;
    method = method || 'linear';
    var n=points.length,sumX=0,sumY=0,sumXY=0,sumXX=0; 
    points.forEach(function(p){sumX+=p.x; sumY+=p.y; sumXY+=p.x*p.y; sumXX+=p.x*p.x;}); 
    var meanY=sumY/n, meanX=sumX/n;
    var xs=points.map(function(p){return p.x;}).sort(function(a,b){return a-b;}); 
    var xMin=xs[0], xMax=xs[xs.length-1];

    var slope, intercept, coeffs, predictFunc;

    if(method === 'linear') {
      var denom=n*sumXX - sumX*sumX; 
      if(Math.abs(denom)<1e-10) return null; 
      slope=(n*sumXY - sumX*sumY)/denom; 
      intercept=(sumY - slope*sumX)/n;
      predictFunc = function(x){ return slope*x + intercept; };
    } else if(method === 'poly2' || method === 'poly3') {
      var degree = method === 'poly2' ? 2 : 3;
      coeffs = polynomialRegression(points, degree);
      if(!coeffs) return null;
      predictFunc = function(x){ var y=0; for(var i=0;i<coeffs.length;i++){ y += coeffs[i] * Math.pow(x, i); } return y; };
    } else if(method === 'exponential') {
      // y = a * e^(bx) => ln(y) = ln(a) + bx
      var validPts = points.filter(function(p){ return p.y > 0; });
      if(validPts.length < 2) return null;
      var lnY = validPts.map(function(p){ return Math.log(p.y); });
      var sumLnY = lnY.reduce(function(a,b){return a+b;}, 0);
      var sumXLnY = validPts.reduce(function(a,p,i){return a + p.x*lnY[i];}, 0);
      var sumXValid = validPts.reduce(function(a,p){return a+p.x;}, 0);
      var sumXXValid = validPts.reduce(function(a,p){return a+p.x*p.x;}, 0);
      var nValid = validPts.length;
      var denomExp = nValid*sumXXValid - sumXValid*sumXValid;
      if(Math.abs(denomExp) < 1e-10) return null;
      var b = (nValid*sumXLnY - sumXValid*sumLnY) / denomExp;
      var lnA = (sumLnY - b*sumXValid) / nValid;
      var a = Math.exp(lnA);
      predictFunc = function(x){ return a * Math.exp(b*x); };
      coeffs = [a, b];
    } else if(method === 'logarithmic') {
      // y = a + b*ln(x)
      var validPts = points.filter(function(p){ return p.x > 0; });
      if(validPts.length < 2) return null;
      var lnX = validPts.map(function(p){ return Math.log(p.x); });
      var sumLnX = lnX.reduce(function(a,b){return a+b;}, 0);
      var sumYValid = validPts.reduce(function(a,p){return a+p.y;}, 0);
      var sumLnXY = validPts.reduce(function(a,p,i){return a + lnX[i]*p.y;}, 0);
      var sumLnXX = lnX.reduce(function(a,b){return a+b*b;}, 0);
      var nValid = validPts.length;
      var denomLog = nValid*sumLnXX - sumLnX*sumLnX;
      if(Math.abs(denomLog) < 1e-10) return null;
      var b = (nValid*sumLnXY - sumLnX*sumYValid) / denomLog;
      var a = (sumYValid - b*sumLnX) / nValid;
      predictFunc = function(x){ return x > 0 ? a + b*Math.log(x) : a; };
      coeffs = [a, b];
    } else if(method === 'power') {
      // y = a * x^b => ln(y) = ln(a) + b*ln(x)
      var validPts = points.filter(function(p){ return p.x > 0 && p.y > 0; });
      if(validPts.length < 2) return null;
      var lnX = validPts.map(function(p){ return Math.log(p.x); });
      var lnY = validPts.map(function(p){ return Math.log(p.y); });
      var sumLnX = lnX.reduce(function(a,b){return a+b;}, 0);
      var sumLnY = lnY.reduce(function(a,b){return a+b;}, 0);
      var sumLnXLnY = lnX.reduce(function(a,v,i){return a + v*lnY[i];}, 0);
      var sumLnXX = lnX.reduce(function(a,v){return a+v*v;}, 0);
      var nValid = validPts.length;
      var denomPow = nValid*sumLnXX - sumLnX*sumLnX;
      if(Math.abs(denomPow) < 1e-10) return null;
      var b = (nValid*sumLnXLnY - sumLnX*sumLnY) / denomPow;
      var lnA = (sumLnY - b*sumLnX) / nValid;
      var a = Math.exp(lnA);
      predictFunc = function(x){ return x > 0 ? a * Math.pow(x, b) : 0; };
      coeffs = [a, b];
    } else {
      // Default to linear
      var denom=n*sumXX - sumX*sumX; 
      if(Math.abs(denom)<1e-10) return null; 
      slope=(n*sumXY - sumX*sumY)/denom; 
      intercept=(sumY - slope*sumX)/n;
      predictFunc = function(x){ return slope*x + intercept; };
    }

    var ssTot=0, ssRes=0; 
    points.forEach(function(p){ 
      var yHat=predictFunc(p.x); 
      ssTot+=(p.y-meanY)*(p.y-meanY); 
      ssRes+=(p.y-yHat)*(p.y-yHat);
    }); 
    var r2=ssTot===0?0:1-ssRes/ssTot; 
    var rmse=Math.sqrt(ssRes/n);
    var sxx=xs.reduce(function(a,x){return a+(x-meanX)*(x-meanX);},0);

    return {n:n,slope:slope,intercept:intercept,coeffs:coeffs,r2:r2,rmse:rmse,meanX:meanX,meanY:meanY,xMin:xMin,xMax:xMax,predict:predictFunc,sxx:sxx}; 
  }

  function polynomialRegression(points, degree) {
    var n = points.length;
    if(n < degree + 1) return null;
    var X = [];
    for(var i = 0; i < n; i++) {
      var row = [];
      for(var j = 0; j <= degree; j++) {
        row.push(Math.pow(points[i].x, j));
      }
      X.push(row);
    }
    var Y = points.map(function(p){ return p.y; });
    // Solve using normal equations: (X'X)c = X'Y
    var XT = transpose(X);
    var XTX = matrixMultiply(XT, X);
    var XTY = matrixMultiply(XT, Y.map(function(y){return [y];}));
    var coeffs = gaussianElimination(XTX, XTY.map(function(r){return r[0];}));
    return coeffs;
  }

  function transpose(matrix) {
    return matrix[0].map(function(_, i){ return matrix.map(function(row){ return row[i]; }); });
  }

  function matrixMultiply(A, B) {
    var result = [];
    for(var i = 0; i < A.length; i++) {
      var row = [];
      for(var j = 0; j < B[0].length; j++) {
        var sum = 0;
        for(var k = 0; k < A[0].length; k++) {
          sum += A[i][k] * B[k][j];
        }
        row.push(sum);
      }
      result.push(row);
    }
    return result;
  }

  function gaussianElimination(A, b) {
    var n = b.length;
    var augmented = A.map(function(row, i){ return row.concat([b[i]]); });
    for(var i = 0; i < n; i++) {
      var maxRow = i;
      for(var k = i + 1; k < n; k++) {
        if(Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
          maxRow = k;
        }
      }
      var tmp = augmented[i];
      augmented[i] = augmented[maxRow];
      augmented[maxRow] = tmp;
      for(var k = i + 1; k < n; k++) {
        var factor = augmented[k][i] / augmented[i][i];
        for(var j = i; j <= n; j++) {
          augmented[k][j] -= factor * augmented[i][j];
        }
      }
    }
    var x = new Array(n);
    for(var i = n - 1; i >= 0; i--) {
      x[i] = augmented[i][n];
      for(var j = i + 1; j < n; j++) {
        x[i] -= augmented[i][j] * x[j];
      }
      x[i] /= augmented[i][i];
    }
    return x;
  }

  // Outlier Detection Methods
  function distanceBasedOutliers(points, threshold) {
    if(!points.length) return [];
    // Calculate mean distance from each point to all others
    var distances = points.map(function(p) {
      var sumDist = 0;
      for(var i=0; i<points.length; i++) {
        var dx = p.x - points[i].x, dy = p.y - points[i].y;
        sumDist += Math.sqrt(dx*dx + dy*dy);
      }
      return sumDist / points.length;
    });
    var meanDist = distances.reduce(function(a,b){return a+b;},0) / distances.length;
    var stdDist = Math.sqrt(distances.reduce(function(a,d){return a+Math.pow(d-meanDist,2);},0) / distances.length);
    var threshold_val = threshold || (meanDist + 2*stdDist);
    return distances.map(function(d){return d > threshold_val;});
  }

  function isoForestOutliers(points) {
    // Simplified Isolation Forest: random splits
    if(!points.length) return [];
    var scores = new Array(points.length).fill(0);
    for(var tree=0; tree<50; tree++) {
      var pathLengths = isolationTree(points, 0, points.length, 0);
      for(var i=0; i<scores.length; i++) scores[i] += pathLengths[i];
    }
    var avgScore = scores.reduce(function(a,b){return a+b;},0) / scores.length;
    var stdScore = Math.sqrt(scores.reduce(function(a,s){return a+Math.pow(s-avgScore,2);},0) / scores.length);
    var threshold = avgScore + stdScore;
    return scores.map(function(s){return s > threshold;});
  }

  function isolationTree(points, start, end, depth) {
    if(end - start <= 1) {
      var result = new Array(points.length).fill(0);
      for(var i=start; i<end; i++) result[i] = depth;
      return result;
    }
    var axis = depth % 2 === 0 ? 'x' : 'y';
    var values = points.slice(start, end).map(function(p){return p[axis];});
    var splitVal = values[Math.floor(Math.random() * values.length)];
    var leftEnd = start;
    for(var i=start; i<end; i++) {
      if(points[i][axis] < splitVal) {
        var tmp = points[i]; points[i] = points[leftEnd]; points[leftEnd] = tmp;
        leftEnd++;
      }
    }
    var left = isolationTree(points, start, leftEnd, depth+1);
    var right = isolationTree(points, leftEnd, end, depth+1);
    return left.map(function(v,i){return i<leftEnd?v:right[i];});
  }

  function hierarchicalOutliers(points) {
    if(!points.length) return [];
    // Agglomerative clustering - identify smallest clusters as outliers
    var clusters = points.map(function(p,i){return [i];});
    while(clusters.length > Math.max(2, Math.floor(Math.sqrt(points.length)))) {
      var minDist = Infinity, minI = 0, minJ = 1;
      for(var i=0; i<clusters.length; i++) {
        for(var j=i+1; j<clusters.length; j++) {
          var d = clusterDistance(points, clusters[i], clusters[j]);
          if(d < minDist) { minDist = d; minI = i; minJ = j; }
        }
      }
      clusters[minI] = clusters[minI].concat(clusters[minJ]);
      clusters.splice(minJ, 1);
    }
    var outlierIndices = new Object();
    if(clusters.length > 1) {
      var smallestCluster = clusters.reduce(function(a,b){return a.length < b.length ? a : b;});
      smallestCluster.forEach(function(idx){outlierIndices[idx] = true;});
    }
    return points.map(function(p,i){return outlierIndices[i] || false;});
  }

  function clusterDistance(points, cluster1, cluster2) {
    var minDist = Infinity;
    for(var i=0; i<cluster1.length; i++) {
      for(var j=0; j<cluster2.length; j++) {
        var p1 = points[cluster1[i]], p2 = points[cluster2[j]];
        var dx = p1.x - p2.x, dy = p1.y - p2.y;
        var d = Math.sqrt(dx*dx + dy*dy);
        if(d < minDist) minDist = d;
      }
    }
    return minDist;
  }

  function dbscanOutliers(points, eps, minPts) {
    if(!points.length) return [];
    eps = eps || 0.5;
    minPts = minPts || 3;
    var cluster = new Array(points.length).fill(-1);
    var clusterId = 0;
    for(var i=0; i<points.length; i++) {
      if(cluster[i] !== -1) continue;
      var neighbors = getNeighbors(points, i, eps);
      if(neighbors.length < minPts) continue;
      expandCluster(points, cluster, i, neighbors, clusterId++, eps, minPts);
    }
    return cluster.map(function(c){return c === -1;});
  }

  function getNeighbors(points, idx, eps) {
    var neighbors = [];
    for(var i=0; i<points.length; i++) {
      var dx = points[i].x - points[idx].x, dy = points[i].y - points[idx].y;
      if(Math.sqrt(dx*dx + dy*dy) <= eps) neighbors.push(i);
    }
    return neighbors;
  }

  function expandCluster(points, cluster, idx, neighbors, clusterId, eps, minPts) {
    cluster[idx] = clusterId;
    for(var i=0; i<neighbors.length; i++) {
      var nIdx = neighbors[i];
      if(cluster[nIdx] === -1) {
        cluster[nIdx] = clusterId;
        var newNeighbors = getNeighbors(points, nIdx, eps);
        if(newNeighbors.length >= minPts) {
          neighbors = neighbors.concat(newNeighbors);
        }
      }
    }
  }

  function localOutlierFactor(points) {
    if(!points.length) return [];
    var k = Math.min(5, Math.floor(Math.sqrt(points.length)));
    var lofs = new Array(points.length);
    var kdist = new Array(points.length); // k-distance
    var reachDist = new Array(points.length).fill(0);
		
    // Calculate k-distances
    for(var i=0; i<i++;){}
    for(var i=0; i<points.length; i++) {
      var distances = [];
      for(var j=0; j<points.length; j++) {
        if(i !== j) {
          var dx = points[i].x - points[j].x, dy = points[i].y - points[j].y;
          distances.push({idx:j, dist:Math.sqrt(dx*dx + dy*dy)});
        }
      }
      distances.sort(function(a,b){return a.dist - b.dist;});
      kdist[i] = distances[Math.min(k-1, distances.length-1)].dist;
    }
		
    // Calculate LOF
    for(var i=0; i<points.length; i++) {
      var reachDistances = [];
      for(var j=0; j<points.length; j++) {
        if(i !== j) {
          var dx = points[i].x - points[j].x, dy = points[i].y - points[j].y;
          var d = Math.sqrt(dx*dx + dy*dy);
          reachDistances.push(Math.max(d, kdist[j]));
        }
      }
      var lrd = k / reachDistances.reduce(function(a,b){return a+b;},0);
			
      var lofSum = 0;
      for(var j=0; j<points.length; j++) {
        if(i !== j) {
          var dx = points[i].x - points[j].x, dy = points[i].y - points[j].y;
          var d = Math.sqrt(dx*dx + dy*dy);
          var jReachDist = Math.max(d, kdist[j]);
          var jLrd = k / reachDistances.reduce(function(a,b){return a+b;},0);
          lofSum += jLrd / lrd;
        }
      }
      lofs[i] = lofSum / Math.max(1, points.length - 1);
    }
		
    var meanLof = lofs.reduce(function(a,b){return a+b;},0) / lofs.length;
    var stdLof = Math.sqrt(lofs.reduce(function(a,l){return a+Math.pow(l-meanLof,2);},0) / lofs.length);
    var threshold = meanLof + stdLof;
    return lofs.map(function(l){return l > threshold;});
  }

  function getOutliers(points, method) {
    method = method || 'kmeans';
    if(method === 'kmeans') return kmeansOutliers(points);
    if(method === 'distance') return distanceBasedOutliers(points, null);
    if(method === 'isolation') return isoForestOutliers(points);
    if(method === 'hierarchical') return hierarchicalOutliers(points);
    if(method === 'dbscan') return dbscanOutliers(points, 0.5, 3);
    if(method === 'lof') return localOutlierFactor(points);
    return kmeansOutliers(points);
  }

  function kmeansOutliers(points){ 
    if(!points.length) return []; 
    var data=points.map(function(p){return [p.x,p.y];}); 
    var c1=data[0], c2=data[data.length-1]; 
    var assign=new Array(data.length); 
    for(var iter=0; iter<10; iter++){ 
      for(var i=0;i<data.length;i++){ 
        var d1=Math.pow(data[i][0]-c1[0],2)+Math.pow(data[i][1]-c1[1],2); 
        var d2=Math.pow(data[i][0]-c2[0],2)+Math.pow(data[i][1]-c2[1],2); 
        assign[i]=d1<d2?0:1; 
      } 
      var s1=[0,0,0], s2=[0,0,0]; 
      for(i=0;i<data.length;i++){ 
        var s=assign[i]===0?s1:s2; 
        s[0]+=data[i][0]; s[1]+=data[i][1]; s[2]++; 
      } 
      if(s1[2]) c1=[s1[0]/s1[2], s1[1]/s1[2]]; 
      if(s2[2]) c2=[s2[0]/s2[2], s2[1]/s2[2]]; 
    }
    var count1=assign.filter(function(a){return a===0;}).length; 
    var count2=assign.filter(function(a){return a===1;}).length; 
    var outlierCluster=count1<count2?0:1; 
    return assign.map(function(a){return a===outlierCluster;}); 
  }

  function computeKDE(values){ 
    if(!values.length) return {xs:[],ys:[]}; 
    var sorted=values.slice().sort(function(a,b){return a-b;}); 
    var n=sorted.length; 
    var mean=sorted.reduce(function(s,v){return s+v;},0)/n; 
    var std=Math.sqrt(sorted.reduce(function(s,v){return s+Math.pow(v-mean,2);},0)/n)||1; 
    var h=1.06*std*Math.pow(n,-1/5); 
    if(!isFinite(h)||h<=0) h=0.1; 
    var min=sorted[0], max=sorted[sorted.length-1]; 
    var step=(max-min)/30 || 1; 
    var xs=[], ys=[]; 
    var norm=1/(n*h*Math.sqrt(2*Math.PI)); 
    for(var x=min-2*step; x<=max+2*step; x+=step){ 
      var sum=0; 
      for(var i=0;i<n;i++){ 
        var u=(x-sorted[i])/h; 
        sum+=Math.exp(-0.5*u*u); 
      } 
      xs.push(x); ys.push(norm*sum); 
    } 
    return {xs:xs, ys:ys}; 
  }

  function loess(x, y, bandwidth) {
    var n = x.length;
    var y_hat = new Array(n);
    for (var i = 0; i < n; i++) {
      var xi = x[i];
      var weights = new Array(n);
      var sumWeights = 0;
      for (var j = 0; j < n; j++) {
        var dist = Math.abs(x[j] - xi);
        var u = dist / bandwidth;
        var w = (u < 1) ? Math.pow(1 - Math.pow(u, 3), 3) : 0;
        weights[j] = w;
        sumWeights += w;
      }
      var sumWX = 0, sumWY = 0, sumWXY = 0, sumWXX = 0;
      for (var j = 0; j < n; j++) {
        var w = weights[j];
        sumWX += w * x[j];
        sumWY += w * y[j];
        sumWXY += w * x[j] * y[j];
        sumWXX += w * x[j] * x[j];
      }
      var denom = sumWeights * sumWXX - sumWX * sumWX;
      if (Math.abs(denom) < 1e-9) {
        y_hat[i] = sumWeights > 0 ? sumWY / sumWeights : 0;
      } else {
        var slope = (sumWeights * sumWXY - sumWX * sumWY) / denom;
        var intercept = (sumWY - slope * sumWX) / sumWeights;
        y_hat[i] = slope * xi + intercept;
      }
    }
    return y_hat;
  }

  function chartCardId(which){ return 'sa-s' + String(which) + '-card'; }
  function chartInnerId(which){ return chartCardId(which) + '-inner'; }
  function chartR2Id(which){ return chartCardId(which) + '-r2'; }
  function chartStatsId(which){ return chartCardId(which) + '-stats'; }

  function chartKeySuffix(key){
    if(typeof key !== 'string') return '';
    var idx = key.indexOf('-');
    return idx >= 0 ? key.slice(idx) : '';
  }
  function chartNumFromKey(key){
    if(typeof key === 'number') return key;
    var n = parseInt(String(key||''), 10);
    return isFinite(n) ? n : 1;
  }
  function chartCardDomId(key){
    var n = chartNumFromKey(key);
    return chartCardId(n) + chartKeySuffix(key);
  }
  function chartInnerDomId(key){
    var n = chartNumFromKey(key);
    return chartInnerId(n) + chartKeySuffix(key);
  }
  function chartR2DomId(key){
    var n = chartNumFromKey(key);
    return chartR2Id(n) + chartKeySuffix(key);
  }
  function chartStatsDomId(key){
    var n = chartNumFromKey(key);
    return chartStatsId(n) + chartKeySuffix(key);
  }

  function applyDragMode(which){
    var n = chartNumFromKey(which);
    Plotly.relayout(chartInnerDomId(which), {dragmode: STATE['dragMode'+n]});
  }

  function zoomAxis(which, axis, factor) {
    var targetId = chartInnerDomId(which);
    var gd = document.getElementById(targetId);
    if(!gd || !gd.layout) return;
    var axisKey = axis === 'x' ? 'xaxis' : 'yaxis';
    var currentRange = gd.layout[axisKey].range;
    if(!currentRange || currentRange.length !== 2) return;
    var center = (currentRange[0] + currentRange[1]) / 2;
    var span = (currentRange[1] - currentRange[0]) / 2;
    var newSpan = span * factor;
    var update = {};
    update[axisKey + '.range'] = [center - newSpan, center + newSpan];
    Plotly.relayout(targetId, update);
  }

  function renderChart(which){
    dbg('DEBUG renderChart: called with which =', which);
    // Handle both numeric (1, 2) and string ('1-0', '2-0') formats
    var chartNum = chartNumFromKey(which);
    var targetId = chartInnerDomId(which);
    var r2ElId = chartR2DomId(which);
    dbg('DEBUG renderChart: chartNum =', chartNum, ', targetId =', targetId);
    renderChartInternal(chartNum, targetId, r2ElId, String(which));
  }

  function renderChartInternal(which, targetId, r2ElId, whichKey){
    dbg('DEBUG renderChartInternal: which =', which, ', targetId =', targetId);
    var pts = getChartPoints(which);
    dbg('DEBUG renderChartInternal: points count =', pts.length);
    if(!pts.length){ 
      console.warn('WARNING renderChartInternal: No points to plot for chart', which);
      Plotly.newPlot(targetId, [], {xaxis:{title:combLabel},yaxis:{title:getYLabel(which)}}, {responsive:true, displayModeBar:false}); 
      var r2El = document.getElementById(r2ElId);
      if(r2El) r2El.textContent = '';
      return; 
    }

    var chartType = STATE['chartType'+which] || 'scatter';
    try{
      if(chartType !== 'scatter'){
        STATE['lastReg'+which] = null;
        if(whichKey!=null) STATE['lastRegKey:'+String(whichKey)] = null;
      }
    }catch(_cr){}
    var reg = null; var traces=[]; var annotations=[];
    var values = pts.map(function(p){ return p.y; });

    // Dynamic legend label truncation based on chart width
    try{
      var lp = STATE['legendPos'+which] || 'bottom';
      if(lp==='auto') lp='bottom';
      var el = document.getElementById(targetId);
      var w = el ? (el.getBoundingClientRect().width || 0) : 0;
      var approx = w>0 ? Math.floor(w / 14) : 24;
      var max = Math.max(18, Math.min(60, approx));
      if(lp==='left' || lp==='right') max = Math.max(18, Math.min(32, max));
      LEGEND_LABEL_MAX = max;
    }catch(e){ LEGEND_LABEL_MAX = 24; }

    if(chartType==='histogram' || chartType==='hist+kde'){
      var histBins = STATE['histBins'+which] || 10;
      if(which > 2){
        var histLabel = getYLabel(which);
        var dec = getDecY(which);
        var histTrace = { x: pts.map(function(p){ return p.y; }), type:'histogram', name:truncateLegendLabel(histLabel), marker:{color:NORMAL_COLOR, opacity:0.75}, xbins:{}, nbinsx: histBins };
        histTrace.hovertemplate = '<b>'+histLabel+'</b><br>Value: %{x:.'+dec+'f}<br>Count: %{y}<extra></extra>';
        if(!STATE.showHistCounts) {
          histTrace.histnorm = 'probability density';
        } else {
          histTrace.text = 'auto';
          histTrace.textposition = 'outside';
          histTrace.texttemplate = '%{y}';
        }
        traces.push(histTrace);
        if(chartType==='hist+kde'){
          var kde=computeKDE(histTrace.x);
          traces.push({ x:kde.xs, y:kde.ys, mode:'lines', yaxis:'y2', line:{color:NORMAL_COLOR, width:2}, name:truncateLegendLabel('Density '+histLabel), hovertemplate:'<b>Density</b><br>Value: %{x:.'+dec+'f}<br>Density: %{y:.4f}<extra></extra>' });
        }
      } else {
        // Two-bar histogram: Chart1 vs Chart2
        var values1 = pts.map(function(p){
          var y1 = (calc[p.idx] && calc[p.idx].ys) ? calc[p.idx].ys[1] : calc[p.idx].yLatest;
          return which===1 ? p.y : y1;
        });
        var values2 = pts.map(function(p){
          var y2 = (calc[p.idx] && calc[p.idx].ys) ? calc[p.idx].ys[2] : calc[p.idx].yProp;
          return which===1 ? y2 : p.y;
        });

        var hist1Label = getYLabel(1);
        var hist2Label = getYLabel(2);

        var histTrace1 = { x: values1, type:'histogram', name:truncateLegendLabel(hist1Label), marker:{color:NORMAL_COLOR, opacity:0.75}, xbins:{}, offsetgroup:1, nbinsx: histBins };
        var histTrace2 = { x: values2, type:'histogram', name:truncateLegendLabel(hist2Label), marker:{color:OUTLIER_COLOR, opacity:0.75}, xbins:{}, offsetgroup:2, nbinsx: histBins };

        histTrace1.hovertemplate = '<b>'+hist1Label+'</b><br>Value: %{x:.'+getDecY(1)+'f}<br>Count: %{y}<extra></extra>';
        histTrace2.hovertemplate = '<b>'+hist2Label+'</b><br>Value: %{x:.'+getDecY(2)+'f}<br>Count: %{y}<extra></extra>';

        if(!STATE.showHistCounts) {
          histTrace1.histnorm = 'probability density';
          histTrace2.histnorm = 'probability density';
        } else {
          histTrace1.text = 'auto';
          histTrace1.textposition = 'outside';
          histTrace1.texttemplate = '%{y}';
          histTrace2.text = 'auto';
          histTrace2.textposition = 'outside';
          histTrace2.texttemplate = '%{y}';
        }

        traces.push(histTrace1, histTrace2);

        if(chartType==='hist+kde'){
          var kde1=computeKDE(values1);
          var kde2=computeKDE(values2);
          traces.push({ x:kde1.xs, y:kde1.ys, mode:'lines', yaxis:'y2', line:{color:NORMAL_COLOR, width:2}, name:truncateLegendLabel('Density '+hist1Label), hovertemplate:'<b>Density</b><br>Value: %{x:.'+getDecY(1)+'f}<br>Density: %{y:.4f}<extra></extra>' });
          traces.push({ x:kde2.xs, y:kde2.ys, mode:'lines', yaxis:'y2', line:{color:OUTLIER_COLOR, width:2, dash:'dash'}, name:truncateLegendLabel('Density '+hist2Label), hovertemplate:'<b>Density</b><br>Value: %{x:.'+getDecY(2)+'f}<br>Density: %{y:.4f}<extra></extra>' });
        }
      }
    } else {
      var outliers = getOutliers(pts, STATE.outlierMethod);
      var normal=[], outlierPts=[];
      pts.forEach(function(p,i){ var isOut=outliers[i]; if(STATE.excludeOutliers && isOut) return; if(STATE['showOutliers'+which] && isOut) outlierPts.push(p); else normal.push(p); });
      var regressionPts = STATE.excludeOutliers ? normal : normal.concat(outlierPts);
      var regressionMethod = STATE['regressionMethod'+which];
      reg = computeRegression(regressionPts, regressionMethod);
      STATE['lastReg'+which] = reg;
      try{ if(whichKey!=null) STATE['lastRegKey:'+String(whichKey)] = reg; }catch(_k){}

      // Points/labels controls (LineTrend-style)
      var pointsMode = String(STATE['pointsMode'+which] || 'auto');
      if(pointsMode !== 'none' && pointsMode !== 'all' && pointsMode !== 'auto') pointsMode = 'auto';
      var showPoints = (pointsMode !== 'none');
      var showLabels = !!STATE['showLabels'+which];

      var yLabel = getYLabel(which);
      var cellHead = STATE.showCell ? '<b>%{text}</b><br>' : '';

      if(showPoints){
        var baseMode = showLabels ? 'markers+text' : 'markers';
        var txtPos = 'top center';
        var txtFont = {size: Math.max(10, Math.min(14, AXIS_TICK_FONT_SIZE)), color: TREND_COLOR};

        traces.push({ 
          x: normal.map(function(p){return p.x;}), 
          y: normal.map(function(p){return p.y;}), 
          mode: baseMode,
          type:'scatter', 
          marker:{size:7, color:NORMAL_COLOR, symbol:'circle', line:{width:0.5, color:'#fff'}}, 
          name:'Normal', 
          customdata: normal.map(function(p){return (p.extra||[]).join('<br>');}),
          hovertemplate:cellHead+'Type: Normal<br>'+combLabel+': %{x:.'+DEC_X+'f}<br>'+yLabel+': %{y:.'+getDecY(which)+'f}<extra></extra>',
          text: normal.map(function(p){return p.cell;}),
          textposition: txtPos,
          textfont: txtFont
        });

        if(outlierPts.length>0){ 
          var useOutlierColor = OUTLIER_COLORED;
          traces.push({ 
            x: outlierPts.map(function(p){return p.x;}), 
            y: outlierPts.map(function(p){return p.y;}), 
            mode: baseMode,
            type:'scatter', 
            marker:{size:8, color:(useOutlierColor? OUTLIER_COLOR : NORMAL_COLOR), symbol:'circle', line:{width:0.5, color:'#fff'}}, 
            name:'Outlier', 
            customdata: outlierPts.map(function(p){return (p.extra||[]).join('<br>');}),
            hovertemplate:cellHead+'Type: Outlier<br>'+combLabel+': %{x:.'+DEC_X+'f}<br>'+yLabel+': %{y:.'+getDecY(which)+'f}<extra></extra>',
            text: outlierPts.map(function(p){return p.cell;}),
            textposition: txtPos,
            textfont: txtFont
          }); 
        }
      }

      if(reg){
        var xMin=Math.min.apply(null, pts.map(function(p){return p.x;})); 
        var xMax=Math.max.apply(null, pts.map(function(p){return p.x;}));
        var yMin=Math.min.apply(null, pts.map(function(p){return p.y;})); 
        var yMax=Math.max.apply(null, pts.map(function(p){return p.y;}));
				
      // Mean lines - visible on chart by default
      if(STATE['showAvgX'+which]) {
        traces.push({ x:[reg.meanX, reg.meanX], y:[yMin, yMax], mode:'lines', line:{color:'#9ca3af', width:1.5, dash:'dash'}, name:'X Mean', hoverinfo:'x+name', showlegend:true });
        annotations.push({x:reg.meanX, y:yMax, text:'X: '+fmtFixedTrim(reg.meanX, DEC_X), showarrow:false, font:{size:10, color:'#6b7280'}, yshift:12});
      }
      if(STATE['showAvgY'+which]) {
        annotations.push({x:(xMin + (xMax-xMin)*0.02), y:reg.meanY, text:'Y: '+fmtFixedTrim(reg.meanY, getDecY(which)), showarrow:false, font:{size:10, color:'#6b7280'}, xanchor:'left', yanchor:'bottom', yshift:5});
        annotations.push({x:(xMin + (xMax-xMin)*0.02), y:reg.meanY, text:'Y: '+reg.meanY.toFixed(AXIS_DEC), showarrow:false, font:{size:10, color:'#6b7280'}, xanchor:'left', yanchor:'bottom', yshift:5});
      }
        // CI Band (only for linear regression)
        if(STATE['showCI'+which] && regressionMethod === 'linear' && reg.slope !== undefined){
          var xBand=[], yLower=[], yUpper=[], n=pts.length, t=1.96;
          for(var i=0;i<=40;i++){ 
            var xVal=reg.xMin + ((reg.xMax - reg.xMin)*i)/40; 
          var yHat=reg.predict(xVal); 
          var se=reg.rmse * Math.sqrt(1/n + (xVal-reg.meanX)*(xVal-reg.meanX)/reg.sxx); 
          xBand.push(xVal); 
          yLower.push(yHat - t*se); 
          yUpper.push(yHat + t*se); 
        }
        // Add lower bound line (invisible)
        traces.push({ x:xBand, y:yLower, mode:'lines', line:{color:'rgba(0,0,0,0)'}, name:'CI Lower', hoverinfo:'skip', showlegend:false });
        // Add upper bound with fill to previous trace
        traces.push({ x:xBand, y:yUpper, mode:'lines', fill:'tonexty', fillcolor:rgba(BAND_COLOR, BAND_OPACITY), line:{color:'rgba(0,0,0,0)'}, name:'95% CI', hoverinfo:'skip', showlegend:true });
        }
        // Regression line
        if(STATE['showRegression'+which] && STATE['regressionMethod'+which] !== 'none'){
          var sortedPts = regressionPts.slice().sort(function(a,b){return a.x - b.x;});
          var trendName = 'Trend';
          if(regressionMethod === 'linear') trendName = 'Linear';
          else if(regressionMethod === 'poly2') trendName = 'Poly (2)';
          else if(regressionMethod === 'poly3') trendName = 'Poly (3)';
          else if(regressionMethod === 'exponential') trendName = 'Exponential';
          else if(regressionMethod === 'logarithmic') trendName = 'Logarithmic';
          else if(regressionMethod === 'power') trendName = 'Power';
          else if(regressionMethod === 'loess') trendName = 'LOESS';

          if(regressionMethod === 'loess'){
            if(sortedPts.length > 300) { var step = Math.ceil(sortedPts.length / 300); sortedPts = sortedPts.filter(function(_, i){ return i % step === 0; }); }
            var lx = sortedPts.map(function(p){return p.x;});
            var ly = sortedPts.map(function(p){return p.y;});
            var bandwidth = (reg.xMax - reg.xMin) * 0.4;
            var ly_hat = loess(lx, ly, bandwidth);
            traces.push({ x: lx, y: ly_hat, mode:'lines', line:{color:TREND_COLOR, width:2.5}, name:truncateLegendLabel(trendName), hoverinfo:'x+y+name', showlegend:true });

            if(STATE['showRegTicks'+which]){
              var tickX=[], tickY=[];
              var tickCount = 14;
              var stride = Math.max(1, Math.floor(lx.length / tickCount));
              for(var ti=0; ti<lx.length; ti+=stride){ tickX.push(lx[ti]); tickY.push(ly_hat[ti]); }
              traces.push({ x: tickX, y: tickY, mode:'markers', type:'scatter', marker:{symbol:'line-ns-open', size:12, color:TREND_COLOR, line:{width:2, color:TREND_COLOR}}, name:'', hoverinfo:'skip', showlegend:false });
            }
          } else {
            var lineX = [], lineY = [];
            for(var i=0; i<=100; i++){
              var xVal = reg.xMin + ((reg.xMax - reg.xMin)*i)/100;
              lineX.push(xVal);
              lineY.push(reg.predict(xVal));
            }
            traces.push({ x: lineX, y: lineY, mode:'lines', line:{color:TREND_COLOR, width:2.5}, name:truncateLegendLabel(trendName), hoverinfo:'x+y+name', showlegend:true });

            if(STATE['showRegTicks'+which]){
              var tX=[], tY=[];
              var tCount = 14;
              var tStride = Math.max(1, Math.floor(lineX.length / tCount));
              for(var tj=0; tj<lineX.length; tj+=tStride){ tX.push(lineX[tj]); tY.push(lineY[tj]); }
              traces.push({ x: tX, y: tY, mode:'markers', type:'scatter', marker:{symbol:'line-ns-open', size:12, color:TREND_COLOR, line:{width:2, color:TREND_COLOR}}, name:'', hoverinfo:'skip', showlegend:false });
            }
          }
        }
      }
    }

    // Data-driven ranges - tight to data with small percentage padding only
    var xDataMin=null, xDataMax=null, yDataMin=null, yDataMax=null;
    if(chartType==='scatter'){
      for(var ii=0; ii<pts.length; ii++){
        var px = pts[ii].x, py = pts[ii].y;
        if(xDataMin===null||px<xDataMin) xDataMin=px; if(xDataMax===null||px>xDataMax) xDataMax=px;
        if(yDataMin===null||py<yDataMin) yDataMin=py; if(yDataMax===null||py>yDataMax) yDataMax=py;
      }
      var xPad = (xDataMax - xDataMin) * 0.03 || 0.01; var yPad = (yDataMax - yDataMin) * 0.03 || 0.01;
      xDataMin = xDataMin - xPad; xDataMax = xDataMax + xPad;
      yDataMin = yDataMin - yPad; yDataMax = yDataMax + yPad;
    }

    var isDark = (STATE.theme==='dark');
    var isPaper = (STATE.theme==='paper');
    var bg = isDark ? '#0f172a' : (isPaper ? '#f8fafc' : '#ffffff');
    var gridColor = isDark ? '#1e293b' : '#f3f4f6';
    var spikeColor = isDark ? '#06b6d4' : '#0891b2';
    var text = isDark ? '#e2e8f0' : '#111827';
    var legendBg = isDark ? 'rgba(15,23,42,0.95)' : (isPaper ? 'rgba(248,250,252,0.95)' : 'rgba(255,255,255,0.95)');
    var legendText = isDark ? '#e2e8f0' : '#111827';
    // Legend sizing: responsive to actual chart height (prevents legend looking oversized/undersized)
    var legendFontSize = (function(){
      try{
        var el = document.getElementById(targetId);
        var h = el ? (el.getBoundingClientRect().height || 0) : 0;
        var baseH = Math.max(260, (CHART_HEIGHT||380));
        var scale = (h>0) ? (h / baseH) : 1;
        scale = Math.max(0.85, Math.min(1.15, scale));
        // Fullscreen charts get a bit more scaling (aligned with PV_FullscreenFontScale)
        var card = el ? el.closest('.sa-card') : null;
        var fs = (card && card.classList && card.classList.contains('sa-fullscreen')) ? FULLSCREEN_FONT_SCALE : 1;
        var v = AXIS_TICK_FONT_SIZE * 0.95 * scale * fs;
        return Math.max(9, Math.min(15, Math.round(v)));
      }catch(_){
        return Math.max(9, Math.round(AXIS_TICK_FONT_SIZE * 0.95));
      }
    })();
    var legendPos = STATE['legendPos'+which] || 'bottom';
    if(legendPos==='auto') legendPos = 'bottom';
    var showLegend = !!STATE['showLegend'+which];
    // Default legend: bottom, outside plot, compact margin
    var legendCfg = {borderwidth:1, bordercolor:gridColor, bgcolor:legendBg, font:{color:legendText, size:legendFontSize}, orientation:'h', tracegroupgap:2, valign:'middle', x:0, xanchor:'left', y:-0.18, yanchor:'top', traceorder:'normal'};
    var marginCfg = {l:70,r:24,t:30,b:70, pad: 1};

    if(showLegend){
      if(legendPos==='bottom'){
        legendCfg.y=-0.24;
        legendCfg.yanchor='top';
        legendCfg.orientation='h';
        // Ensure enough room for BOTH x-axis title and the external legend (avoids overlap after stats panel toggles)
        var xTitleSpace = Math.max(20, Math.round(AXIS_TITLE_FONT_SIZE * 1.15) + 18);
        var legendSpace = Math.max(40, Math.round(legendFontSize * 2.8) + 18);
        marginCfg.b = Math.max(74, xTitleSpace + legendSpace);
      }
      else if(legendPos==='top'){
        // Standard Plotly convention: y slightly above plot, anchored from bottom
        legendCfg.y=1.02;
        legendCfg.yanchor='bottom';
        legendCfg.x=0.5;
        legendCfg.xanchor='center';
        legendCfg.orientation='h';
      }
      else if(legendPos==='left'){ legendCfg.orientation='v'; legendCfg.x=-0.18; legendCfg.y=1; legendCfg.xanchor='right'; legendCfg.yanchor='top'; marginCfg.l=Math.max(160, 120 + legendFontSize*2); }
      else if(legendPos==='right'){ legendCfg.orientation='v'; legendCfg.x=1.02; legendCfg.y=1; legendCfg.xanchor='left'; legendCfg.yanchor='top'; marginCfg.r=Math.max(160, 120 + legendFontSize*2); }
    }
		
    // Build chart title with R² value
    var chartTitle = '';
    if(chartType === 'scatter' && reg && reg.r2 !== undefined){
      var yLabel = which===1 ? latestLabel : propLabel;
      chartTitle = '<b>' + yLabel + ' vs ' + combLabel + ' (R² = ' + (reg.r2 * 100).toFixed(2) + '%)</b>';
      marginCfg.t = 50; // Add space for title
    }

    function wrapTitleByWidth(containerId, text, fontSize){
      try{
        var el = document.getElementById(containerId);
        if(!el || !text) return {txt:text, lines:1};
        var w = el.getBoundingClientRect().width || 0;
        if(w <= 0) return {txt:text, lines:1};
        // crude chars-per-line estimate
        var cpl = Math.max(20, Math.floor(w / (Math.max(10, fontSize) * 0.62)));
        // Strip <b> wrapper to compute, reinject later
        var raw = String(text).replace(/^<b>|<\/b>$/g,'');
        var parts = raw.split(' ');
        var lines = [];
        var cur = '';
        parts.forEach(function(p){
          if((cur + (cur ? ' ' : '') + p).length > cpl){
            if(cur) lines.push(cur);
            cur = p;
          } else {
            cur = cur ? (cur + ' ' + p) : p;
          }
        });
        if(cur) lines.push(cur);
        var wrapped = '<b>' + lines.join('<br>') + '</b>';
        return {txt: wrapped, lines: Math.max(1, lines.length)};
      }catch(e){ return {txt:text, lines:1}; }
    }


    var effectiveChartTitle = (SHOW_PLOT_TITLES ? chartTitle : '');
    var wrappedTitle = effectiveChartTitle ? wrapTitleByWidth(targetId, effectiveChartTitle, TITLE_FONT_SIZE) : {txt: undefined, lines: 0};
		
    var yAxisTitle = (chartType==='histogram' || chartType==='hist+kde') ? 'Count' : (which===1?latestLabel:propLabel);
    // Adjust top margin dynamically for title lines (and a bit if top legend)
    if(effectiveChartTitle){
      var titleLines = Math.max(1, wrappedTitle.lines || 1);
      marginCfg.t = Math.max(marginCfg.t, (titleLines * (TITLE_FONT_SIZE + 4)) + ((showLegend && legendPos==='top') ? (legendFontSize + 18) : 8));
    }

    var layout = {
      title: wrappedTitle.txt ? {text: wrappedTitle.txt, font:{size:TITLE_FONT_SIZE, color:text, family:'Arial, sans-serif'}, x:0.5, xanchor:'center'} : undefined,
      showlegend: showLegend,
      xaxis:{ title:{ text: combLabel, font:{size:AXIS_TITLE_FONT_SIZE, color:text, family:'Arial, sans-serif'}, standoff: Math.max(12, Math.round(AXIS_TITLE_FONT_SIZE * 0.9)) }, automargin:true, showgrid:true, gridwidth:1, gridcolor:gridColor, color:text, tickfont:{size:AXIS_TICK_FONT_SIZE}, showspikes:false, autorange: xDataMin===null, rangemode: 'normal', nticks: 8 },
      yaxis:{ title:{ text: yAxisTitle, font:{size:AXIS_TITLE_FONT_SIZE, color:text, family:'Arial, sans-serif'}, standoff: Math.max(12, Math.round(AXIS_TITLE_FONT_SIZE * 0.9)) }, automargin:true, showgrid:true, gridwidth:1, gridcolor:gridColor, color:text, tickfont:{size:AXIS_TICK_FONT_SIZE}, showspikes:false, autorange: yDataMin===null, rangemode: 'normal', nticks: 8 },
      margin: marginCfg, hovermode:'closest', plot_bgcolor:bg, paper_bgcolor:bg, font:{color:text, family:'Arial, sans-serif', size:11}, legend:legendCfg, dragmode: STATE['dragMode'+which], annotations: annotations,
      barmode: (chartType==='histogram' || chartType==='hist+kde') ? 'group' : undefined
    };

    // Zoom menu parity: X-axis range slider toggle
    try{
      var xrs = !!STATE['xRangeSlider'+which];
      layout.xaxis = layout.xaxis || {};
      layout.xaxis.rangeslider = {visible: xrs};
    }catch(_){ }

    // Targets (per-chart X/Y min/max + optional band)
    (function(){
      var targetsOn = !!STATE['targetsOn'+which];
      if(!targetsOn) return;
      var txMin = STATE['tXMin'+which], txMax = STATE['tXMax'+which];
      var tyMin = STATE['tYMin'+which], tyMax = STATE['tYMax'+which];
      var xBand = !!STATE['tXBand'+which];
      var yBand = !!STATE['tYBand'+which];
      var hasAny = (isFinite(txMin) || isFinite(txMax) || (chartType==='scatter' && (isFinite(tyMin) || isFinite(tyMax))));
      if(!hasAny) return;

      layout.shapes = layout.shapes || [];
      var lineStyle = {color: TARGET_COLOR_DEFAULT, width: TARGET_WIDTH_DEFAULT, dash: TARGET_DASH_DEFAULT};
      var fillColor = TARGET_COLOR_DEFAULT;

      // X targets (scatter + histogram)
      if(isFinite(txMin)) layout.shapes.push({type:'line', xref:'x', yref:'paper', x0:txMin, x1:txMin, y0:0, y1:1, line: lineStyle});
      if(isFinite(txMax)) layout.shapes.push({type:'line', xref:'x', yref:'paper', x0:txMax, x1:txMax, y0:0, y1:1, line: lineStyle});
      if(xBand && isFinite(txMin) && isFinite(txMax)){
        layout.shapes.push({type:'rect', xref:'x', yref:'paper', x0:Math.min(txMin,txMax), x1:Math.max(txMin,txMax), y0:0, y1:1,
          line:{width:0}, fillcolor: fillColor, opacity: 0.08, layer:'below'});
      }

      // Y targets (scatter only)
      if(chartType==='scatter'){
        if(isFinite(tyMin)) layout.shapes.push({type:'line', xref:'paper', yref:'y', x0:0, x1:1, y0:tyMin, y1:tyMin, line: lineStyle});
        if(isFinite(tyMax)) layout.shapes.push({type:'line', xref:'paper', yref:'y', x0:0, x1:1, y0:tyMax, y1:tyMax, line: lineStyle});
        if(yBand && isFinite(tyMin) && isFinite(tyMax)){
          layout.shapes.push({type:'rect', xref:'paper', yref:'y', x0:0, x1:1, y0:Math.min(tyMin,tyMax), y1:Math.max(tyMin,tyMax),
            line:{width:0}, fillcolor: fillColor, opacity: 0.08, layer:'below'});
        }
      }
    })();

    if(xDataMin!==null && xDataMax!==null){ layout.xaxis.range = [xDataMin, xDataMax]; }

    // Scatter: manual X range override (entered via Y axis menu)
    if(chartType==='scatter'){
      var xMinM = STATE['xMin'+which];
      var xMaxM = STATE['xMax'+which];
      if(isFinite(xMinM) && isFinite(xMaxM)){
        layout.xaxis = layout.xaxis || {};
        layout.xaxis.range = [xMinM, xMaxM];
        layout.xaxis.autorange = false;
      }
    }

    // Y axis controls (LineTrend-style)
    var yMode = String(STATE['yMode'+which] || 'auto');
    var yScale = String(STATE['yScale'+which] || 'linear');
    layout.yaxis = layout.yaxis || {};

    if(yScale === 'log'){
      layout.yaxis.type = 'log';
      layout.yaxis.autorange = true;
      try{ delete layout.yaxis.range; }catch(_){ }
    }else{
      layout.yaxis.type = 'linear';
    }

    if(yMode === 'manual'){
      var yMinM = STATE['yMin'+which];
      var yMaxM = STATE['yMax'+which];
      if(isFinite(yMinM) && isFinite(yMaxM) && yScale !== 'log'){
        layout.yaxis.range = [yMinM, yMaxM];
        layout.yaxis.autorange = false;
      }
    }else if(yMode === 'tozero'){
      layout.yaxis.rangemode = 'tozero';
      if(yScale !== 'log' && yDataMin!==null && yDataMax!==null){
        layout.yaxis.range = [Math.min(0, yDataMin), yDataMax];
        layout.yaxis.autorange = false;
      }
    }else{
      if(yScale !== 'log' && yDataMin!==null && yDataMax!==null){
        layout.yaxis.range = [yDataMin, yDataMax];
        layout.yaxis.autorange = false;
      }
    }

    if(chartType==='hist+kde'){
      layout.yaxis2 = {title:{text:'Density', font:{size:AXIS_TITLE_FONT_SIZE, color:text}}, tickfont:{size:AXIS_TICK_FONT_SIZE, color:text}, overlaying:'y', side:'right', showgrid:false, zeroline:false};
      layout.margin = layout.margin || {};
      layout.margin.r = Math.max(layout.margin.r||20, 60);
    }

    Plotly.newPlot(targetId, traces, layout, {responsive:true, displayModeBar:false});
    bindLegendHover(targetId);
    applyFullscreenFontScale(which);

    try{
      var gdEl = document.getElementById(targetId);
      if(gdEl) gdEl.style.cursor = (STATE['removeMode'+which] ? 'crosshair' : '');
    }catch(_){ }

    // Dynamic axis value display - DISABLED to remove blue/orange labels on hover
    // To re-enable, uncomment this block
    /* ... omitted for brevity ... */
		
    // Remove points (Remove-mode or Ctrl+Click)
    document.getElementById(targetId).on('plotly_click', function(data) {
      try{
        var ev = data && data.event;
        var removeMode = !!STATE['removeMode'+which];
        var isRemove = removeMode || !!(ev && ev.ctrlKey);
        if(!isRemove) return;

        var pt = data && data.points ? data.points[0] : null;
        if(pt && (pt.data.name === 'Normal' || pt.data.name === 'Outlier')) {
          var clickedX = pt.x; var clickedY = pt.y;
          calc.forEach(function(d, idx) {
            var yVal = which===1 ? d.yLatest : d.yProp;
            if(Math.abs(d.x - clickedX) < 1e-9 && Math.abs(yVal - clickedY) < 1e-9) { STATE.removedIndices[idx] = true; }
          });
          renderChart(which);
        }
        if(ev && ev.preventDefault){ ev.preventDefault(); }
        return false;
      }catch(e){ }
    });
    document.getElementById(targetId).addEventListener('contextmenu', function(e) { e.preventDefault(); return false; });

    // Title is now shown in Plotly chart layout, no need for separate r2El display
    // var r2El = document.getElementById(r2ElId);
    // if(r2El){ r2El.textContent = ''; }
  }

  function updateTheme(){ 
    var cards = [];
    if(tableCard) cards.push(tableCard.card);
    if(s1Card) cards.push(s1Card.card);
    if(s2Card) cards.push(s2Card.card);
    Object.keys(sectionCards).forEach(function(sk) {
      if(sectionCards[sk].table) cards.push(sectionCards[sk].table.card);
      if(sectionCards[sk].chart1) cards.push(sectionCards[sk].chart1.card);
      if(sectionCards[sk].chart2) cards.push(sectionCards[sk].chart2.card);
    });
    var isDark = (STATE.theme==='dark');
    var isPaper = (STATE.theme==='paper');
    cards.forEach(function(c){
      if(!c) return;
      c.classList.toggle('dark', isDark);
      c.classList.toggle('paper', isPaper);
    });
    header.classList.toggle('dark', isDark);
    header.classList.toggle('paper', isPaper);
    filterDialog.classList.toggle('dark', isDark);
    filterDialog.classList.toggle('paper', isPaper);
    try{ rootHost.setAttribute('data-theme', STATE.theme); }catch(e){}
    rebuildLayout();
  }

  // Initial render
  setTimeout(function(){ renderTable(); applyAutoSizing(); renderChart(1); renderChart(2); }, 150);

})();

</script>

</div><!-- End #sa-narrative-container -->
